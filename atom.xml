<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高尚的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gaoshangs.github.io/"/>
  <updated>2018-02-23T11:53:49.077Z</updated>
  <id>https://gaoshangs.github.io/</id>
  
  <author>
    <name>Gason Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP7 新特性</title>
    <link href="https://gaoshangs.github.io/2018-02-23-php7.html"/>
    <id>https://gaoshangs.github.io/2018-02-23-php7.html</id>
    <published>2018-02-23T10:21:00.000Z</published>
    <updated>2018-02-23T11:53:49.077Z</updated>
    
    <content type="html"><![CDATA[<p>官方的文档显示，PHP7可以达到PHP5.x版本<strong>两倍</strong>的性能。同时还提供了很多其他语言流行的语法格式。另外其PHP7的兼容性也是非常好的。</p><ol><li><p>函数参数支持标量类型声明<br>在PHP5中，可以将函数参数指定为类名、接口名、数组和回调类型中的一种，但是无法将类型指定为标量。PHP7中新增了对函数参数声明为四种标量类型的支持，即可以指定参数类型为整型（int）、浮点型（float）、字符串（string）以及布尔型（bool）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//指定函数参数必须为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkOpenid</span><span class="params">(string $sOpenid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preg_match(<span class="string">'/^[a-zA-Z_-]&#123;28&#125;$/'</span>, $sOpenid);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>新增函数返回类型声明<br>PHP7新增了对函数返回类型声明的支持，支持的类型与参数类型相同（在PHP7.1中支持返回void类型）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//指定函数返回值必须为整型</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkOpenid</span><span class="params">(string $sOpenid)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preg_match(<span class="string">'/^[a-zA-Z_-]&#123;28&#125;$/'</span>, $sOpenid);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>define定义常量数组<br>PHP5.6及以后版本中可以通过const关键字来定义常量数组，PHP7中新增可以通过define定义常量数组功能。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//php5.6中通过const定义常量数组</span></span><br><span class="line">    <span class="keyword">const</span> FRUITS = [<span class="string">'peach'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//php7 中通过define定义常量数组数组</span></span><br><span class="line">    define(<span class="string">'FRUITS1'</span>, [<span class="string">'peach'</span>,<span class="string">'banana'</span>,<span class="string">'pear'</span>,<span class="string">'orange'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>生成器的返回值和引入其他生成器<br>在PHP5.5引入生成器的概念。生成器函数每执行一次就得到一个yield标识的值。在PHP7中，当生成器迭代完成后，可以获取该生成器函数的返回值。通过Generator::getReturn()得到。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"a"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$generatorClass = (<span class="string">"generator"</span>)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($generatorClass <span class="keyword">as</span> $val) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $val.” “;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $generatorClass-&gt;getReturn();</span><br><span class="line"><span class="comment">//运行结果：1 2 3 a</span></span><br></pre></td></tr></table></figure></li></ol><p>在生成器中可以引入另一个或几个生成器，只需要写yield from functionName1<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> from generator2();</span><br><span class="line">    <span class="keyword">yield</span> from generator3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (generator1() <span class="keyword">as</span> $val)&#123;</span><br><span class="line">    <span class="keyword">echo</span> $val, <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure></p><ol><li><p>NULL合并运算符<br>后端CGI在接收用户传入的数据时通常会先判断变量是否存在，如果存在获取对应的值，如果不存在，在设置一个默认值或者报错处理。这里就会用到 三元运算符和isset。在PHP7中新增了一个语法糖??。如果第一个操作数存在且不为null则返回第一个操作数的值，否则返回第二个操作数的值。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//获取用户openid.先从$_GET中获取，如果没有从$_POST中获取，如果还是不存在，就默认空</span></span><br><span class="line">    <span class="comment">//PHP7之前的写法</span></span><br><span class="line">    $sOpenid = <span class="keyword">isset</span>($_GET[<span class="string">'iuin'</span>]) ? $_GET[<span class="string">'iuin'</span>] : (<span class="keyword">isset</span>($_POST[<span class="string">'iuin'</span>]) ? $_POST[<span class="string">'iuin'</span>] : <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//php7中新增的??语法糖</span></span><br><span class="line">    $sOpenid = $_GET[<span class="string">'iuin'</span>] ?? $_POST[<span class="string">'iuin'</span>] ?? <span class="string">''</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>组合比较符<br>该操作符也称为太空船操作符，用于对2个表达式进行比较并返回比较结果。使用语法：$exp1 &lt;=&gt; $exp2。如果$exp1小于$exp2返回-1，$exp1等于$exp2返回0，$exp1大于$exp2返回1。比较的原则是沿用 PHP 的常规比较规则进行的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="number">10</span> &lt;=&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="number">10</span> &lt;=&gt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="number">10</span> &lt;=&gt; <span class="string">'10'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># -1</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure></li><li><p>Closure::call()<br>Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;<span class="keyword">public</span> $name = <span class="string">"lixuan"</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PHP7和PHP5.6都可以</span></span><br><span class="line">$getNameFunc = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;&#125;;</span><br><span class="line">$name = $getNameFunc-&gt;bindTo(<span class="keyword">new</span> Test, <span class="string">'Test'</span>);</span><br><span class="line"><span class="keyword">echo</span> $name();</span><br><span class="line"></span><br><span class="line"><span class="comment">//PHP7可以,PHP5.6报错</span></span><br><span class="line">$getX = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;&#125;;</span><br><span class="line"><span class="keyword">echo</span> $getX-&gt;call(<span class="keyword">new</span> Test);</span><br></pre></td></tr></table></figure></li><li><p>foreach不再改变内部数组指针<br>在PHP7之前，当数组通过 foreach 迭代时，数组指针会移动。现在开始，不再如此，见下面代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> &amp;$val) &#123;</span><br><span class="line">    var_dump(current($array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PHP5输出：</span></span><br><span class="line"><span class="comment">int(1)</span></span><br><span class="line"><span class="comment">int(2)</span></span><br><span class="line"><span class="comment">bool(false)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">PHP7输出：</span></span><br><span class="line"><span class="comment">int(0)</span></span><br><span class="line"><span class="comment">int(0)</span></span><br><span class="line"><span class="comment">int(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="http://php.net/manual/zh/migration70.new-features.php" target="_blank" rel="noopener">PHP7新特性</a></li><li><a href="https://cloud.tencent.com/developer/article/1005077" target="_blank" rel="noopener">PHP7 新特性简介</a></li><li><a href="https://www.36nu.com/post/184.html" target="_blank" rel="noopener">PHP7新功能及语法变化总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方的文档显示，PHP7可以达到PHP5.x版本&lt;strong&gt;两倍&lt;/strong&gt;的性能。同时还提供了很多其他语言流行的语法格式。另外其PHP7的兼容性也是非常好的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;函数参数支持标量类型声明&lt;br&gt;在PHP5中，可以将函数参数指定为类名
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP面试知识点汇总</title>
    <link href="https://gaoshangs.github.io/2018-02-09-php-interview-knowledge-point.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-php-interview-knowledge-point.html</id>
    <published>2018-02-09T02:50:00.000Z</published>
    <updated>2018-02-23T03:26:14.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><a href="https://gaoshangs.github.io/2018-01-15-knowledge-point.html">面试知识点总结(持续更新~~)</a></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><a href="https://gaoshangs.github.io/2018-02-05-algorithm-php.html">常见算法</a></li><li><a href="https://gaoshangs.github.io/2018-02-07-algorithm-merging-sorting.html">归并排序算法</a></li><li><a href="https://gaoshangs.github.io/2018-02-08-algorithm-consistent-hashing.html">一致性hash算法和应用</a></li><li><a href="https://gaoshangs.github.io/2018-02-09-algorithm-skip-list.html">跳跃表算法</a></li></ul><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul><li><a href="https://gaoshangs.github.io/2018-02-09-php-Interview-question-1.html">PHP面试题汇总(一)</a></li><li><a href="https://gaoshangs.github.io/2018-02-09-php-interview-question-2.html">php面试题汇总(二)</a></li><li><a href="https://gaoshangs.github.io/2018-02-09-php-Interview-question-3.html">PHP面试题汇总(三)</a></li><li><a href="https://gaoshangs.github.io/2018-02-05-design-pattern.html">设计模式</a></li><li><a href="https://gaoshangs.github.io/2018-02-06-design-pattern-interview-question.html">设计模式面试题</a></li><li><a href="http://www.cnblogs.com/datang6777/p/6747764.html" target="_blank" rel="noopener">2017最新PHP面试题</a></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="https://gaoshangs.github.io/2018-02-09-http.html">http协议详解</a></li><li><a href="https://gaoshangs.github.io/2018-02-07-linux-failure-analysis-command.html">Linux服务器网站故障分析常用的命令</a></li><li><a href="https://gaoshangs.github.io/2018-02-05-linux-network-program.html">linux网络编程</a></li><li><a href="https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html">TCP/IP知识点</a></li><li><a href="https://gaoshangs.github.io/2018-02-08-curl-usage.html">CURL用法</a></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li><a href="https://gaoshangs.github.io/2018-02-07-mysql-innodb-index.html">MySQL InnoDB索引底层原理详解</a></li><li><a href="https://gaoshangs.github.io/2018-02-05-mysql.html">MySQL知识点</a></li><li><a href="http://www.cnblogs.com/datang6777/p/6888659.html" target="_blank" rel="noopener">MySQL性能优化总结</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><ul><li><a href="https://gaoshangs.github.io/2018-02-09-redis-memecached-diff.html">redis和memcached的区别</a></li><li><a href="https://gaoshangs.github.io/2018-02-05-nosql-db.html">NoSQL数据库知识点</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gaoshangs.github.io/2018-01-15-knowledge-po
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP面试题汇总(三)</title>
    <link href="https://gaoshangs.github.io/2018-02-09-php-Interview-question-3.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-php-Interview-question-3.html</id>
    <published>2018-02-09T02:40:00.000Z</published>
    <updated>2018-02-23T16:10:00.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序算法原理"><a href="#归并排序算法原理" class="headerlink" title="归并排序算法原理"></a>归并排序算法原理</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote><p>时间复杂度：O(nlogn) </p></blockquote><ol><li>把 n 个记录看成 n 个长度为 l 的有序子表</li><li>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</li><li>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>两个正序数组，如[3 4 7 9], [2  6  8] 如何合并成一个正序数组<br>假设：<br>序列A：3 4 7 9<br>序列B：2  6  8<br>序列C：空<br>合并思路是：先申请一个序列，将指针分别指向3和2，这时候进行比较，3大于2，所以把2放到序列C，序列B指针后移到6，这时候序列A的3小于6，把3放到序列C，A序列指针后移<br>4小于序列B的6，把4放到序列C，依次类推。。。直到最后只剩下序列A中的9，把9合并到序列C，完成归并排序</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://gaoshangs.github.io/2018-02-07-algorithm-merging-sorting.html">归并排序算法</a></li></ul><h2 id="一致性HASH原理和应用"><a href="#一致性HASH原理和应用" class="headerlink" title="一致性HASH原理和应用"></a>一致性HASH原理和应用</h2><blockquote><p>问题：单机redis20G如何承载500G的cache（考虑redis集群应用）</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>如何对<strong>请求与缓存服务器之间进行精准映射,以及优雅的扩展，剔除缓存服务器</strong>，提升缓存服务的容错性和扩展性</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>一致性哈希将整个哈希空间组织成一个虚拟的圆环，假如整个哈希函数的值空间为0 - 2^32 -1(一个32位的无符号整形)，如下图:整个空间按顺时针方向组织,0和232-1在零点中方向重合</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-761c7ac38078a2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/425" alt="一致性HASH闭环"></p><p><strong>第一步：在哈希闭环中确定各台服务器位置</strong></p><p>将各台服务器的ip或主机名为关键字通过H函数得到一个哈希值，然后在哈希闭环中标注位置。如下图3台redis服务：</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-cdb684dc8afcafbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt=""></p><p><strong>第二步：定位数据访问的服务器</strong></p><p>将数据key使用相同的函数H计算出哈希值h，通根据h确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器</p><p>例如我们缓存服务器中有A、B、C、D四个key对应的数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-99c54dadceb7f18b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt="一致性hash函数值空间"></p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://gaoshangs.github.io/2018-02-08-algorithm-consistent-hashing.html">一致性hash算法和应用</a></li><li><a href="http://blueskykong.com/2018/01/09/rediscluster2/" target="_blank" rel="noopener">Redis Cluster深入与实践</a></li></ul><h2 id="MySQL索引知识点"><a href="#MySQL索引知识点" class="headerlink" title="MySQL索引知识点"></a>MySQL索引知识点</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p><strong>1. 从数据结构角度</strong></p><ul><li>B+树索引(O(nlogn))</li><li>hash索引：检索效率最高，仅能使用”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询和排序<br><strong>2. 从物理存储角度</strong></li><li>聚簇索引</li><li>非聚簇索引</li></ul><p><strong>3. 从逻辑角度</strong></p><ul><li>主键索引</li><li>普通索引</li><li>复合索引</li><li>唯一索引</li></ul><h3 id="InnoDB-B-Tree索引原理"><a href="#InnoDB-B-Tree索引原理" class="headerlink" title="InnoDB B+Tree索引原理"></a>InnoDB B+Tree索引原理</h3><p><strong>1. B+Tree数据结构</strong></p><ul><li>所有非叶子结点至多拥有两个儿子, 非叶子结点的左指针指向小于其关键字，右指针指向大于其关键字 </li><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的指针自小而大顺序连接</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li></ul><p><strong>2. InnoDB数据页结构</strong></p><ul><li>页是InnoDB存储引擎管理数据库的最小磁盘单位(16K)</li><li>叶子节点(页与页之间)是双向链表串起来的,头连上一页的尾，尾连下一页的头</li><li>每个数据页中有两个虚拟的行记录，用来限定记录的边界</li><li>页目录(Page Directory)通过顺序排放的 <strong>记录指针(也叫槽)</strong> 存放了记录的相对位置，通过这些槽找到具体的数据位置</li></ul><p><strong>3. 查询B+树索引的流程</strong><br>首先通过B+树索引找到叶节点，再找到对应的数据页，然后将数据页加载到内存中，通过二分查找页目录中的指针，查找出一个链表,然后就可以遍历这个链表找到具体的数据。</p><h3 id="聚簇索引和非聚簇索引实现原理和区别"><a href="#聚簇索引和非聚簇索引实现原理和区别" class="headerlink" title="聚簇索引和非聚簇索引实现原理和区别"></a>聚簇索引和非聚簇索引实现原理和区别</h3><p><strong>区别</strong></p><ul><li>聚簇索引一般是为主键索引，一张表只能有一个聚簇索引，B+树的叶子节点存储了行数据和主键。</li><li>非聚簇索引可以有多个，叶节点除了包含关键字键值外还包含聚集索引的主键</li></ul><p><strong>非聚簇索引的查询流程</strong><br>先查到主键值，然后InnoDB再根据查到的主键值通过主键索引找到对应的数据块。</p><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://gaoshangs.github.io/2018-02-07-mysql-innodb-index.html">MySQL InnoDB索引底层原理详解</a></li></ul><h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><ol><li><strong>Redis支持除key-value之外更多的数据类型</strong></li><li><strong>内存使用效率对比</strong>：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached</li><li><strong>性能对比</strong>:由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis。结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡）</li><li><strong>数据持久化和同步</strong>:memcache不支持，redis支持</li><li><strong>网络IO模型方面：</strong>Memcached是多线程，分为监听线程、worker线程，引入锁，带来了性能损耗。Redis使用单线程的IO复用模型，将速度优势发挥到最大，也提供了较简单的计算功能</li><li>集群管理的不同:memcached只能通过分布式算法来实现Memcached的分布式存储，redis 高级版本redis Cluster在服务端做了支持，并且引入了Master节点和Slave节点，保证单点故障下的数据可用性</li></ol><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://gaoshangs.github.io/2018-02-09-redis-memecached-diff.html">redis和memcached的区别</a></li></ul><h2 id="进程、线程、协程-轻量级线程-和go中的Goroutine"><a href="#进程、线程、协程-轻量级线程-和go中的Goroutine" class="headerlink" title="进程、线程、协程(轻量级线程)和go中的Goroutine"></a>进程、线程、协程(轻量级线程)和go中的Goroutine</h2><h3 id="进程、线程-和-协程-之间概念的区别"><a href="#进程、线程-和-协程-之间概念的区别" class="headerlink" title="进程、线程 和 协程 之间概念的区别"></a>进程、线程 和 协程 之间概念的区别</h3><blockquote><p>需要区分进程、线程(内核级线程)、协程(用户态的轻量级的线程)三个概念</p></blockquote><ul><li>对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行抢占式调度（有多种调度算法）</li><li>对于协程(用户态的轻量级的线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。<br>因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的CPU控制权切换到其他进程/线程。<br>通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。<br>ps：所以说协程是不需要进行内核态的切换的。</li></ul><h3 id="goroutine-和协程区别"><a href="#goroutine-和协程区别" class="headerlink" title="goroutine 和协程区别"></a>goroutine 和协程区别</h3><p>本质上，goroutine 就是协程。不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，<br>当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU转让出去，让其他 goroutine 能被调度并执行，<br><strong>也就是 Golang 从语言层面支持了协程</strong> 。<br>Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。</p><h3 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别?"></a>线程和协程的区别?</h3><p>一旦创建完线程，你就无法决定他什么时候获得时间片，什么时候让出时间片了，你把它交给了内核。<br>而协程编写者可以有：<strong> 一是可控的切换时机</strong> ，<strong> 二是很小的切换代价</strong><br>从操作系统有没有调度权上看，协程就是因为不需要进行内核态的切换，所以会使用它，会有这么个东西。<br>这个定义相对准确：<strong> 协程－用户态的轻量级的线程 </strong></p><h3 id="进程、线程、协程的联系与区别"><a href="#进程、线程、协程的联系与区别" class="headerlink" title="进程、线程、协程的联系与区别"></a>进程、线程、协程的联系与区别</h3><ul><li>进程是系统进行资源分配和调度的独立单位，也就是说不同进程拥有自己独立的堆和栈，既不共享堆也不共享栈</li><li>线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位，它拥有<strong>独立的栈</strong>和<strong>共享的堆</strong>。</li><li>协程又称”微线程”，它和线程一样拥有独立的栈和共享的堆。是由<strong>程序员调度的执行单元</strong>，<br>它自带CPU上下文，当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到),<br>这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程</li></ul><h3 id="区别和优缺点"><a href="#区别和优缺点" class="headerlink" title="区别和优缺点"></a>区别和优缺点</h3><ol><li>一个程序至少拥有一个进程，一个进程至少拥有一个线程（主线程）</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</li><li>协程、线程不能够独立执行，必须依存在进程中，应当使用互斥锁机制来加以控制</li><li>进程之间可以通过MQ来传递数据，而线程、协程之间的全局变量是共享的</li><li>进程和线程都是由操作系统调度的，而协程的调度是用户(程序员)控制的</li><li>在IO操作密集型的程序使用协程可以很好的避免CPU的浪费，将CPU的资源主动让出给其他协程使用。<br>操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。<br>所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住</li></ol><h3 id="内存分配中的堆与栈"><a href="#内存分配中的堆与栈" class="headerlink" title="内存分配中的堆与栈"></a>内存分配中的堆与栈</h3><p>程序中用来存放数据的内存分为四块:</p><ol><li>全局区(静态区)（static）:全局变量和静态变量会存放在这里,程序结束时系统会释放这块资源.</li><li>文字常量区：我们定义的常量字符串就放在这块地方,也叫常量池，程序结束时系统会释放这块资源.</li><li>栈区（stack）：<strong>存放函数的参数和局部变量的值</strong> .在进入作用域时分配内存空间，离开时就会释放这部分内存</li><li>堆区（heap） ： <strong>一般由程序员分配释放</strong>，若程序员不释放，程序结束时可能由系统回收。<br>由于这个原因，在C和C++中就有能产生大量程序员分配但忘记释放的堆区内存，造成可使用内存越来越少，这个被称之为内存泄露.<br>我们使用new进行实例化后分配的内存就在这部分区域</li></ol><h3 id="并行和并发区别"><a href="#并行和并发区别" class="headerlink" title="并行和并发区别"></a>并行和并发区别</h3><ul><li><strong>并行是指程序的运行状态</strong>，要有两个线程正在执行才能算是Parallelism；要在多核或者多处理器情况下才能做到。</li><li><strong>并发指程序的逻辑结构</strong> ，Concurrency则只要有两个以上线程还在执行过程中即可，不一定是多核处理器</li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://blog.csdn.net/sinat_29297223/article/details/77943117" target="_blank" rel="noopener">进程、线程、协程的联系与区别</a><br><a href="http://www.cnblogs.com/shenguanpu/archive/2013/05/05/3060616.html" target="_blank" rel="noopener">进程、线程、轻量级进程、协程和go中的Goroutine 那些事儿</a><br><a href="https://www.centos.bz/2017/08/golang-goroutine-intro/" target="_blank" rel="noopener">Golang协程详解</a><br><a href="http://blog.csdn.net/u012331102/article/details/43838157" target="_blank" rel="noopener">内存分配中的堆与栈</a></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>考察：三次握手、四次挥手、为什么需要三次握手？为什么需要2MSL？</p><h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html">TCP/IP知识点</a></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h4 id="关于-Cache-Control-max-age-秒-和-Expires"><a href="#关于-Cache-Control-max-age-秒-和-Expires" class="headerlink" title="关于 Cache-Control: max-age=秒 和 Expires"></a>关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的截止时间，<strong>允许客户端在这个时间之前不去检查（发请求）</strong><br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br><strong>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</strong></p><p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p><p><strong>Expires =max-age +   “每次下载时的当前的request时间”</strong></p><p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p><h4 id="http-code与缓存层"><a href="#http-code与缓存层" class="headerlink" title="http code与缓存层"></a>http code与缓存层</h4><ul><li>200状态：当浏览器本地没有缓存或下一层失效时或用户点击CTRL+F5，直接去服务器下载最新数据</li><li>304状态：这一层由last-modify/etag控制。当下一层失效或用户点击F5时，浏览器会发送请求给服务器，如果服务端没有变化，则返回304给浏览器<br>  ps:etag是对url进行标记，检测标记是否存在，但是由于分布式系统中各个机器生成的标记不同，所以一般会关闭掉</li><li>200(from cache)：这一层由expires/cache-control控制。<br>  <strong>1. expires(http1.0版有效)是绝对时间。</strong><br>  <strong>2. cache-control(http1.1版本有效)，相对时间，两者都存在时，cache-control覆盖expires</strong>只要没有失效，浏览器只访问自己的缓存</li></ul><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br><code>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT</code></p><p>客户端第二次请求此URL时，根据HTTP协议的规定，<strong>浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过</strong>：</p><p><code>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT</code></p><p>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p><p>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>200 OK<br>301 永久重定向<br>302 临时重定向<br>304 页面未修改</p><p>400 客户端请求参数有误<br>401 未授权<br>403 拒绝访问<br>404 网页不存在</p><p>500 服务器内部未知错误<br>502 错误的网关<br>503 服务临时不可用<br>504 网关超时</p><h3 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://gaoshangs.github.io/2018-02-09-http.html">http协议详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;归并排序算法原理&quot;&gt;&lt;a href=&quot;#归并排序算法原理&quot; class=&quot;headerlink&quot; title=&quot;归并排序算法原理&quot;&gt;&lt;/a&gt;归并排序算法原理&lt;/h2&gt;&lt;h3 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="面试" scheme="https://gaoshangs.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="一致性哈希" scheme="https://gaoshangs.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>php面试题汇总(二)</title>
    <link href="https://gaoshangs.github.io/2018-02-09-php-interview-question-2.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-php-interview-question-2.html</id>
    <published>2018-02-09T02:38:00.000Z</published>
    <updated>2018-02-23T10:12:43.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP面试题汇总-二"><a href="#PHP面试题汇总-二" class="headerlink" title="PHP面试题汇总 (二)"></a>PHP面试题汇总 (二)</h1><p>文章内容主要参考：<a href="https://github.com/ycrao/mynotes" target="_blank" rel="noopener">https://github.com/ycrao/mynotes</a></p><p>问题来源：<br><a href="http://tieba.baidu.com/p/3612369052" target="_blank" rel="noopener">http://tieba.baidu.com/p/3612369052</a><br><a href="http://blog.csdn.net/hyr352114576/article/details/49638345" target="_blank" rel="noopener">http://blog.csdn.net/hyr352114576/article/details/49638345</a><br><a href="https://my.oschina.net/u/574366/blog/64814" target="_blank" rel="noopener">https://my.oschina.net/u/574366/blog/64814</a></p><h2 id="for与foreach哪个更快"><a href="#for与foreach哪个更快" class="headerlink" title="for与foreach哪个更快?"></a>for与foreach哪个更快?</h2><p>参考答案：<a href="http://www.cnblogs.com/niniwzw/archive/2008/06/03/1212535.html" target="_blank" rel="noopener">http://www.cnblogs.com/niniwzw/archive/2008/06/03/1212535.html</a> </p><p><code>foreach</code> 的效率要比 <code>for</code> 高很多，也许有很大的一个原因是 <code>for</code> 要进行很多次条件判断。所以以后能用 <code>foreach</code> 的地方就用 <code>foreach</code> ，可以提高1倍的效率。</p><p>如果循环内要调用函数，用 <code>array_walk</code> 最好，它的效率要比 <code>for</code> 高出1倍，要比 <code>foreach</code> 高出43%的效率。</p><h2 id="PECL-和-PEAR-有什么区别？"><a href="#PECL-和-PEAR-有什么区别？" class="headerlink" title="PECL 和 PEAR 有什么区别？"></a>PECL 和 PEAR 有什么区别？</h2><p>参考答案：<a href="http://jingyan.baidu.com/article/e9fb46e1a3eb277521f76619.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/e9fb46e1a3eb277521f76619.html</a> </p><p><code>PECL (PHP Extension Community Library)</code> 可以看作 <code>PEAR (PHP Extension and Application Repository)</code> 的一个组成部分，提供了与 <code>PEAR</code> 类似的功能。不同的是 <code>PEAR</code> 的所有扩展都是用纯粹的 <code>PHP</code> 代码编写的，用户在下载到 <code>PEAR</code> 扩展以后可以直接使用将扩展的代码包含到自己的 <code>PHP</code> 文件中使用。而 <code>PECL</code> 是使用 <code>C</code> 语言开发的，通常用于补充一些用 <code>PHP</code> 难以完成的底层功能，往往需要重新编译或者在配置文件中设置后才能在用户自己的代码中使用。</p><p>最直接的表述：<code>PEAR</code> 是 <code>PHP</code> 的上层扩展，<code>PECL</code> 是 <code>PHP</code> 的底层扩展。它们都是为特定的应用提供现成的函数或者类。</p><h2 id="如何处理多服务器共享-Session"><a href="#如何处理多服务器共享-Session" class="headerlink" title="如何处理多服务器共享 Session ?"></a>如何处理多服务器共享 Session ?</h2><p>参考答案：<a href="http://www.toutiao.com/a6294758409293086977/" target="_blank" rel="noopener">http://www.toutiao.com/a6294758409293086977/</a></p><p>思路：引入统一session接入点</p><p>大致上有三种方式可以处理：</p><ul><li>数据库/文件同步 <code>session</code> </li><li><code>cookie</code> 同步 <code>session</code> </li><li>缓存 (如 <code>memcache</code> ）同步 <code>session</code> </li><li>延伸：单独提供session服务，所有机器从这个服务获取session数据</li></ul><p>推荐使用cache和数据库结合的实现方式，保证高效和稳定</p><h2 id="什么是跨站脚本？SQL注入？"><a href="#什么是跨站脚本？SQL注入？" class="headerlink" title="什么是跨站脚本？SQL注入？"></a>什么是跨站脚本？SQL注入？</h2><h3 id="1-跨站脚本攻击的原理和防范"><a href="#1-跨站脚本攻击的原理和防范" class="headerlink" title="1. 跨站脚本攻击的原理和防范"></a>1. <strong>跨站脚本攻击的原理和防范</strong></h3><ul><li>原理</li></ul><p>XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意脚本代码，而程序对于用户输入内容未过滤，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而达到恶意攻击用户的特殊目的。</p><p>跨站脚本攻击的危害：窃取cookie、放蠕虫、网站钓鱼 …</p><p>跨站脚本攻击的分类主要有：存储型XSS、反射型XSS、DOM型XSS</p><ul><li>防范：过滤非法字符(html,js,css)（strip_tags、htmlspecialchars）</li></ul><h3 id="2-SQL注入"><a href="#2-SQL注入" class="headerlink" title="2. SQL注入"></a>2. <strong>SQL注入</strong></h3><ul><li><p>原理<br><code>SQL</code> 注入是发生于应用程序数据库层的安全漏洞。用户输入的参数拼凑SQL查询语句，使用户可以控制SQL查询语句</p></li><li><p>防范：不要使用拼接的sql，使用占位符</p><ul><li>使用预编译语句</li><li>检查数据类型</li></ul></li></ul><p>参考：<br><a href="http://blog.csdn.net/jbb0403/article/details/36626515" target="_blank" rel="noopener">http://blog.csdn.net/jbb0403/article/details/36626515</a><br><a href="http://www.cnblogs.com/ITtangtang/p/3982297.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3982297.html</a></p><h3 id="3-跨站请求伪造（CSRF）攻击"><a href="#3-跨站请求伪造（CSRF）攻击" class="headerlink" title="3. 跨站请求伪造（CSRF）攻击"></a>3. 跨站请求伪造（CSRF）攻击</h3><p>CSRF是Cross Site Request Forgery的缩写，乍一看和XSS差不多的样子，但是其原理正好相反，XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求</p><ul><li>原理<br><img src="https://upload-images.jianshu.io/upload_images/3636937-b8ba0dd4bc821bdd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></li></ul><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成以下两个步骤：1. 登录受信任网站A，并在本地生成Cookie。2. 在不登出A的情况下，访问危险网站B。</p><ul><li>CSRF如何防御<ul><li>验证HTTP Referer字段</li><li>添加token验证</li><li>验证码</li><li>尽量使用POST，限制GET</li><li>在HTTP头部添加自定义属性</li></ul></li></ul><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">WEB安全之-CSRF（跨站请求伪造）</a></li></ul><h2 id="描述一下大流量高并发量网站的解决方案"><a href="#描述一下大流量高并发量网站的解决方案" class="headerlink" title="描述一下大流量高并发量网站的解决方案"></a>描述一下大流量高并发量网站的解决方案</h2><ul><li>确认服务器硬件是否足够支持当前的流量。 </li><li>使用 <code>memcache</code>或<code>redis</code> 缓存技术，将动态数据缓存到文件中，动态网页直接调用这些文件，而不必在访问数据库。</li><li>禁止外部的盗链。外部网站的图片或者文件盗链往往会带来大量的负载压力，因此应该严格限制外部对自身图片或者文件盗链，可以通过apache的URL重定向来防止盗链。 </li><li>控制大文件的下载。大文件的下载会占用很大的流量，对于非SCSI硬盘来说会消耗，使得网站响应能力下降。</li><li>使用不同的主机分流主要流量。</li><li>使用流量统计软件。在网站上安装一个流量统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化。</li></ul><h2 id="如何防盗链"><a href="#如何防盗链" class="headerlink" title="如何防盗链"></a>如何防盗链</h2><p>参考引用: <a href="https://yq.aliyun.com/articles/57931" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57931</a></p><ul><li>设置Referer（原理：判断来源地址是否与白名单地址匹配）</li><li>签名URL(原理：签名URL，增加url的有效时间)</li></ul><h2 id="PHP内存管理机制与垃圾回收机制"><a href="#PHP内存管理机制与垃圾回收机制" class="headerlink" title="PHP内存管理机制与垃圾回收机制"></a>PHP内存管理机制与垃圾回收机制</h2><p>参考答案：<a href="http://www.cnblogs.com/zk0533/p/5667122.html" target="_blank" rel="noopener">http://www.cnblogs.com/zk0533/p/5667122.html</a> </p><p><code>php</code> 的内存管理机制是：预先给出一块空间，用来存储变量，当空间不够时，再申请一块新的空间。</p><ol><li>存储变量名，存在符号表。</li><li>变量值存储在内存空间。</li><li>在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小。</li></ol><p><code>php</code> 垃圾回收机制是：</p><ol><li><p>在5.2版本或之前版本，PHP会根据 引用计数 （ <code>refcount</code> ）值来判断是不是垃圾，如果refcount值为0，PHP会当做垃圾释放掉，这种回收机制有缺陷，对于环状引用的变量无法回收。</p></li><li><p>在5.3之后版本改进了垃圾回收机制。具体如下：</p></li></ol><p>如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在增加，说明不是垃圾；<br>如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在减少，如果减到了0，直接当做垃圾回收；<br>如果发现一个 <code>zval</code> 容器中的 <code>refcount</code> 在减少，并没有减到0，<code>PHP</code> 会把该值放到缓冲区，当做有可能是垃圾的怀疑对象；<br>当缓冲区达到了临界值，<code>PHP</code> 会自动调用一个方法去遍历每一个值，如果发现是垃圾就清理。</p><h2 id="理解php内核中SAPI的作用"><a href="#理解php内核中SAPI的作用" class="headerlink" title="理解php内核中SAPI的作用"></a>理解php内核中SAPI的作用</h2><p>SAPI: Server Application Programming Interface 服务器端应用编程端口。先看一张php模块图<br><img src="https://foio.github.io/images/sapi.jpg" alt=""><br>各种应用都是通过对应的SAPI与php进行交互的，SAPI相当于一个接口，使得php的核心实现不用关心各个应用交互的细节。虽然通过Web服务器和命令行程序执行脚本看起来很不一样，实际上它们的工作流程是一样的<br>通过cgi和cli模式下read_cookies的不同实现，可以看出sapi确实对下层php屏蔽了交互细节，当下层php核心要读取用户cookies时，只需要通过sapi_module_struct-&gt;read_cookies，而不需要关注上层应用的交互细节</p><p>参考：</p><ul><li><a href="https://foio.github.io/php-sapi/" target="_blank" rel="noopener">理解php内核中SAPI的作用</a></li></ul><h2 id="为什么要对数据库进行主从分离"><a href="#为什么要对数据库进行主从分离" class="headerlink" title="为什么要对数据库进行主从分离?"></a>为什么要对数据库进行主从分离?</h2><p>参考答案：<a href="https://my.oschina.net/candiesyangyang/blog/203425" target="_blank" rel="noopener">https://my.oschina.net/candiesyangyang/blog/203425</a></p><ul><li>读写服务器可单独优化，提高可用性</li><li>降低写服务器压力</li><li>主从只负责各自的写和读，极大程度的缓解X锁和S锁争用，提高并发性</li></ul><p>延伸：什么是X锁和S锁？</p><ul><li>共享锁(S锁Share Locks)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li>排它锁：排它锁又称为写锁（(eXclusive lock,简记为X锁)），若事物T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。</li></ul><h2 id="多线程和多进程的区别为？"><a href="#多线程和多进程的区别为？" class="headerlink" title="多线程和多进程的区别为？"></a>多线程和多进程的区别为？</h2><p>参考答案：</p><p><a href="http://www.cnblogs.com/kaituorensheng/p/3603057.html" target="_blank" rel="noopener">http://www.cnblogs.com/kaituorensheng/p/3603057.html</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319292979766bd3285c9d6b4942a8ea9b4e9cfb48d8000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319292979766bd3285c9d6b4942a8ea9b4e9cfb48d8000</a></p><ul><li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li><li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</li><li>相同点：进程线程间切换都会消耗系统资源</li></ul><p>ps：</p><p>进程可靠性高原因：比如fork多个子进程，单独某个进程出现问题，不影响其他进程，而多个子线程如果某个子线程挂了可能导致整个进程挂掉</p><h2 id="TCP-IP-网络协议，OSI-7-层指是什么？"><a href="#TCP-IP-网络协议，OSI-7-层指是什么？" class="headerlink" title="TCP/IP 网络协议，OSI 7 层指是什么？"></a>TCP/IP 网络协议，OSI 7 层指是什么？</h2><p>参考答案：<a href="http://blog.csdn.net/jenminzhang/article/details/47017741" target="_blank" rel="noopener">http://blog.csdn.net/jenminzhang/article/details/47017741</a></p><p><code>TCP/IP</code> 5层 指的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">HTTP、FTP、SMTP、DNS、DSP、Telnet、Gopher、WAIS……</span><br><span class="line">传输层</span><br><span class="line">TCP、UDP、DVP……</span><br><span class="line">网络层</span><br><span class="line">IP、ICMP、AKP、RARP、UUCP……</span><br><span class="line">接口层</span><br><span class="line">Ethernet、Arpanet、PDN……</span><br><span class="line">物理层</span><br><span class="line">只要能传输IP数据报（Datagram），允许任何协议……</span><br></pre></td></tr></table></figure><p><code>OSI</code> 7层指的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</span><br><span class="line">表示层 数据格式化，代码转换，数据加密 没有协议</span><br><span class="line">会话层 解除或建立与别的接点的联系 没有协议</span><br><span class="line">传输层 提供端对端的接口 TCP，UDP</span><br><span class="line">网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP</span><br><span class="line">数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU</span><br><span class="line">物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</span><br></pre></td></tr></table></figure><h2 id="TCP-IP知识点"><a href="#TCP-IP知识点" class="headerlink" title="TCP/IP知识点"></a>TCP/IP知识点</h2><p>参考：<a href="https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html">https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html</a></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 </p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 </p><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#1-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h4><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p><ul><li>TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。</li><li>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误，造成资源浪费。</li></ul><h4 id="2-为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？"><a href="#2-为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？"></a>2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？</h4><p>建立连接时候ACK和SYN可以放到一个报文发送，而关闭连接时被动方可能未全部完成数据的发送，所以ACK和SYN回分两次发送。</p><h4 id="3-为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？"><a href="#3-为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？" class="headerlink" title="3. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？"></a>3. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</h4><p>必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p><h2 id="CGI-FastCGI-php-fpm和nginx通信原理"><a href="#CGI-FastCGI-php-fpm和nginx通信原理" class="headerlink" title="CGI/FastCGI/php-fpm和nginx通信原理"></a>CGI/FastCGI/php-fpm和nginx通信原理</h2><h3 id="cgi、fast-cgi协议"><a href="#cgi、fast-cgi协议" class="headerlink" title="cgi、fast-cgi协议"></a>cgi、fast-cgi协议</h3><ol><li>cgi的历史</li></ol><p>早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像PHP等动态语言。<br>webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！<br>交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？</p><p>为了解决不同的语言解释器(如php、Python解释器)与webserver的通信，于是出现了cgi协议。只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。</p><p>fast-cgi的改进</p><p>有了cgi协议，解决了php解释器与webserver通信的问题，webserver终于可以处理动态语言了。但是，webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程。这样有10000个请求，就需要fork、kill php-cgi进程10000次。</p><p>有没有发现很浪费资源？</p><p>于是，出现了cgi的改良版本，fast-cgi。fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。</p><ol><li>php-fpm是什么</li></ol><p>php-fpm即php-Fastcgi Process Manager.<br>php-fpm是 FastCGI 的实现，并提供了进程管理的功能。<br>进程包含 master 进程和 worker 进程两种进程。<br>master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p><ol><li>nginx和php-fpm运行原理和流程<br>Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpm<br>www.example.com<pre><code>||</code></pre>   Nginx<pre><code>||</code></pre>路由到www.example.com/index.php<pre><code>||</code></pre>加载nginx的fast-cgi模块<pre><code>||</code></pre>fast-cgi监听127.0.0.1:9000地址<pre><code>||</code></pre>www.example.com/index.php请求到达127.0.0.1:9000<pre><code>||</code></pre>php-fpm 监听127.0.0.1:9000<pre><code>||</code></pre>php-fpm 接收到请求，启用worker进程处理请求<pre><code>||</code></pre>php-fpm 处理完请求，返回给nginx<pre><code>||</code></pre>nginx将结果通过http返回给浏览器</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cnblogs.com/datang6777/p/6893363.html" target="_blank" rel="noopener">Nginx+PHP-fpm运行原理详解</a></li></ul><h2 id="PHP路由技术的原理与实践"><a href="#PHP路由技术的原理与实践" class="headerlink" title="PHP路由技术的原理与实践"></a>PHP路由技术的原理与实践</h2><h3 id="路由实现原理"><a href="#路由实现原理" class="headerlink" title="路由实现原理"></a>路由实现原理</h3><p>用户通过指定的URL范式对后台进行访问，URL路由处理类进行处理后，转发给逻辑处理类，逻辑处理类将请求结果返回给用户。</p><h3 id="URL范式和规则"><a href="#URL范式和规则" class="headerlink" title="URL范式和规则"></a>URL范式和规则</h3><blockquote><p>一般为对搜索引擎友好，对用户友好的URL规则，比较流行的有两种：普通模式和<code>pathinfo</code>模式</p><ol><li>普通模式<br>在 ThinkPHP 框架中，默认的URL格式即为普通模式，普通模式URL如下:<br><code>index.php?m=home&amp;c=user&amp;a=login&amp;v=value</code><br>其中 m 参数的值为模块名称， c 参数的值为控制器名称， a 参数的值为方法名称，之后的参数则为该方法中所要接收的其他 GET 请求参数</li><li>pathinfo模式<br>在 CodeIgniter 框架中，默认的URL格式为 pathinfo 模式，如下：<br><code>index.php/controller/method/prarme1/value1</code><br>在 method 以后，就是方法接收的 GET 参数了，格式就是 名称/值</li></ol></blockquote><h3 id="URL路由处理类"><a href="#URL路由处理类" class="headerlink" title="URL路由处理类"></a>URL路由处理类</h3><p>以<code>index.php?c=user&amp;a=login&amp;v=value</code>普通模式为例，URL路由处理类主要完成对控制器类和方法的加载和判断是否存在，有则执行，没有则报错。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'index.class.php'</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'user.class.php'</span>;</span><br><span class="line"><span class="comment">// 对用户请求URL进行处理</span></span><br><span class="line">$query = $_GET;</span><br><span class="line">$controller = <span class="keyword">isset</span>($query[<span class="string">'c'</span>]) ? $query[<span class="string">'c'</span>] : <span class="string">'indexController'</span>;</span><br><span class="line">$action = <span class="keyword">isset</span>($query[<span class="string">'a'</span>]) ? $query[<span class="string">'a'</span>] : <span class="string">'index'</span>;</span><br><span class="line"><span class="keyword">if</span> (class_exists($controller)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method_exists($controller, $action)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unset</span>($_GET[<span class="string">'c'</span>]);</span><br><span class="line">        <span class="keyword">unset</span>($_GET[<span class="string">'a'</span>]);</span><br><span class="line">        <span class="comment">// 实例化用户请求类并调用方法</span></span><br><span class="line">        (<span class="keyword">new</span> $controller())-&gt;$action();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'控制器'</span> . $controller . <span class="string">'中不存在方法'</span> . $action;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'不存在控制器'</span> . $controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 unset() 掉两个get参数，只是为了对真正调用的方法造成其他影响。</p><h3 id="逻辑处理类"><a href="#逻辑处理类" class="headerlink" title="逻辑处理类"></a>逻辑处理类</h3><p>逻辑处理类就是最终的业务逻辑，也就是真正的回应用户请求的代码片段。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.class.php 文件源码 */</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">indexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        var_dump($_GET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* user.class.php 文件源码 */</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'这里是User控制器'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump($_GET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="nginx配置location总结"><a href="#nginx配置location总结" class="headerlink" title="nginx配置location总结"></a>nginx配置location总结</h3><ol><li>语法规则</li></ol><ul><li>已=开头表示精确匹配<br>如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。</li><li>^~ 开头表示uri以某个常规字符串开头，不是正则匹配</li><li>~ 开头表示区分大小写的正则匹配;</li><li>~* 开头表示不区分大小写的正则匹配</li><li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到</li></ul><ol><li>匹配顺序</li></ol><ul><li>首先匹配 =</li><li>其次匹配 ^~</li><li>其次是按文件中顺序的正则匹配  ~</li><li>最后是交给 / 通用匹配</li><li>当有匹配成功时候，停止匹配，按当前匹配规则处理请求</li></ul><h3 id="nginx支持PHP的PATHINFO模式配置"><a href="#nginx支持PHP的PATHINFO模式配置" class="headerlink" title="nginx支持PHP的PATHINFO模式配置"></a>nginx支持PHP的PATHINFO模式配置</h3><ol><li><p>要求<br>解析<code>http://www.test.com/admin/index.php/myModule/myController/myAction?key1=val1&amp;key2=val2</code>,使通过$_SERVER可以获取如下键值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$_GET = <span class="keyword">array</span> (</span><br><span class="line">          <span class="string">'key1'</span> =&gt; <span class="string">'val1'</span>,</span><br><span class="line">          <span class="string">'key2'</span> =&gt; <span class="string">'val2'</span>,</span><br><span class="line">        )</span><br><span class="line">$_SERVER = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'PATH_INFO'</span> =&gt; <span class="string">'/myModule/myController/myAction'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_FILENAME'</span> =&gt; <span class="string">'/Data/code/workt/admin/index.php'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_NAME'</span> =&gt; <span class="string">'/admin/index.php'</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>实现：使用nginx的fastcgi_split_path_info指令，具体配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##匹配nginx需要交给php-fpm执行的URI，先要允许pathinfo格式的URL能够被匹配到</span></span><br><span class="line"><span class="comment">##所以要去掉$</span></span><br><span class="line"><span class="comment">##nginx文档中的匹配规则为：^(.+\.php)(.*)$</span></span><br><span class="line"><span class="comment">##还有~ \.php这种写法 和 ~ \.php($|/)这种写法</span></span><br><span class="line"><span class="comment">##都是差不多意思没啥严格区别</span></span><br><span class="line"><span class="comment">##唯一区别就是有多个匹配php的location的话需要留意权重差异</span></span><br><span class="line">location ~ ^(.+\.php)(.*)$ &#123;</span><br><span class="line">     root              /var/www/www.jjonline.cn/wwwRoot;</span><br><span class="line">     fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">     fastcgi_index  index.php;</span><br><span class="line">     <span class="comment">##增加 fastcgi_split_path_info指令，将URI匹配成PHP脚本的URI和pathinfo两个变量</span></span><br><span class="line">     <span class="comment">##即$fastcgi_script_name 和$fastcgi_path_info</span></span><br><span class="line">     fastcgi_split_path_info  ^(.+\.php)(.*)$;</span><br><span class="line">     <span class="comment">##PHP中要能读取到pathinfo这个变量</span></span><br><span class="line">     <span class="comment">##就要通过fastcgi_param指令将fastcgi_split_path_info指令匹配到的pathinfo部分赋值给PATH_INFO</span></span><br><span class="line">     <span class="comment">##这样PHP中$_SERVER['PATH_INFO']才会存在值</span></span><br><span class="line">     fastcgi_param PATH_INFO <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">     <span class="comment">##在将这个请求的URI匹配完毕后，检查这个绝对地址的PHP脚本文件是否存在</span></span><br><span class="line">     <span class="comment">##如果这个PHP脚本文件不存在就不用交给php-fpm来执行了</span></span><br><span class="line">     <span class="comment">##否者页面将出现由php-fpm返回的:`File not found.`的提示</span></span><br><span class="line">     <span class="keyword">if</span> (!-e <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>) &#123;</span><br><span class="line">         <span class="comment">##此处直接返回404错误</span></span><br><span class="line">         <span class="comment">##你也可以rewrite 到新地址去，然后break;</span></span><br><span class="line">         <span class="built_in">return</span> 404;</span><br><span class="line">     &#125;</span><br><span class="line">     fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">     include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><ul><li><a href="https://segmentfault.com/a/1190000003409909" target="_blank" rel="noopener">PHP路由技术的原理与实践</a></li><li><a href="http://blog.jjonline.cn/linux/218.html" target="_blank" rel="noopener">Nginx支持PHP的PATHINFO模式配置分析</a></li><li><a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/" target="_blank" rel="noopener">nginx配置location总结及rewrite规则写法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP面试题汇总-二&quot;&gt;&lt;a href=&quot;#PHP面试题汇总-二&quot; class=&quot;headerlink&quot; title=&quot;PHP面试题汇总 (二)&quot;&gt;&lt;/a&gt;PHP面试题汇总 (二)&lt;/h1&gt;&lt;p&gt;文章内容主要参考：&lt;a href=&quot;https://github.c
      
    
    </summary>
    
      <category term="软技能" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
      <category term="面试" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试题" scheme="https://gaoshangs.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试题汇总(一)</title>
    <link href="https://gaoshangs.github.io/2018-02-09-php-Interview-question-1.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-php-Interview-question-1.html</id>
    <published>2018-02-09T02:36:00.000Z</published>
    <updated>2018-02-23T16:09:06.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP面试题汇总-基础"><a href="#PHP面试题汇总-基础" class="headerlink" title="PHP面试题汇总(基础)"></a>PHP面试题汇总(基础)</h1><p>文章内容主要参考：<a href="https://github.com/ycrao/mynotes" target="_blank" rel="noopener">https://github.com/ycrao/mynotes</a></p><h2 id="1-echo-print-print-r-的区别？"><a href="#1-echo-print-print-r-的区别？" class="headerlink" title="1. echo(),print(),print_r()的区别？"></a>1. echo(),print(),print_r()的区别？</h2><p>三者均可以输出信息，但是各有自己的特点：</p><table><thead><tr><th></th><th>类型</th><th>输出变量个数</th><th>输出变量类型</th><th>返回值</th><th>速度</th></tr></thead><tbody><tr><td>echo</td><td>语言结构</td><td>一个或多个</td><td>简单类型变量，如int、string</td><td>无</td><td>最快</td></tr><tr><td>print</td><td>语言结构</td><td>一个</td><td>简单类型变量，如int、string</td><td>int</td><td>快</td></tr><tr><td>print_r</td><td>函数</td><td>一个</td><td>复杂类型，如数组、对象</td><td>bool</td><td>慢</td></tr></tbody></table><h2 id="2-语句include和require的区别是什么"><a href="#2-语句include和require的区别是什么" class="headerlink" title="2. 语句include和require的区别是什么?"></a>2. 语句include和require的区别是什么?</h2><p>在失败的时候：  </p><p><code>include</code> 产生一个 <code>warning</code> ，而 <code>require</code> 直接产生错误中断；  </p><p><code>require</code> 在运行前载入；  </p><p><code>include</code> 在运行时载入；  </p><p><code>require_once</code> 和 <code>include_once</code> 可以避免重复包含同一文件。  </p><h2 id="3-php中传值与传引用有啥区别"><a href="#3-php中传值与传引用有啥区别" class="headerlink" title="3. php中传值与传引用有啥区别?"></a>3. php中传值与传引用有啥区别?</h2><p>&amp;表示传引用；<br>函数中参数传引用会将参数进行改变；<br>一般在输出参数有多个的时候可以考虑使用引用。  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$num = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span><span class="params">(&amp;$num)</span></span>&#123;</span><br><span class="line">    $num = $num * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">multiply($num);</span><br><span class="line"><span class="keyword">echo</span> $num;</span><br></pre></td></tr></table></figure><h2 id="4-下面哪项没有将john添加到users数组中？"><a href="#4-下面哪项没有将john添加到users数组中？" class="headerlink" title="4. 下面哪项没有将john添加到users数组中？"></a>4. 下面哪项没有将john添加到users数组中？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a) $users[] = &apos;john&apos;;</span><br><span class="line">(b) array_add($users,&apos;john&apos;);</span><br><span class="line">(c) array_push($users,&apos;john&apos;);</span><br><span class="line">(d) $users ||= &apos;john&apos;;</span><br></pre></td></tr></table></figure><p>答案为bd，php 里面无 <code>array_add</code> 函数，d项为语法错误的表达。</p><h2 id="5-HTTP协议中几个状态码的含义。"><a href="#5-HTTP协议中几个状态码的含义。" class="headerlink" title="5. HTTP协议中几个状态码的含义。"></a>5. HTTP协议中几个状态码的含义。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">200 OK 客户端请求成功</span><br><span class="line">301 Moved Permanently 请求永久重定向</span><br><span class="line">302 Moved Temporarily 请求临时重定向</span><br><span class="line">304 Not Modified 文件未修改，可以直接使用缓存的文件。</span><br><span class="line">400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</span><br><span class="line">401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">403 Forbidden 服务器拒绝执行请求，即没有权限</span><br><span class="line">404 Not Found 请求的资源不存在，例如，输入了错误的URL</span><br><span class="line">500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</span><br><span class="line">502 Bad Gateway 错误的网关，上游服务器错误(如php-fpm挂掉了)</span><br><span class="line">503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</span><br><span class="line">504 Gateway Timeout 网关超时（上游服务器超时）</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">HTTP状态码详解</a><br><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/89" target="_blank" rel="noopener">502 VS 504</a></p><h2 id="6-写出一些php魔术方法。"><a href="#6-写出一些php魔术方法。" class="headerlink" title="6. 写出一些php魔术方法。"></a>6. 写出一些php魔术方法。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__construct() 实例化类时自动调用。</span><br><span class="line">__destruct() 类对象使用结束时自动调用。</span><br><span class="line">__set() 在给未定义的属性赋值的时候调用。</span><br><span class="line">__get() 调用未定义的属性时候调用。</span><br><span class="line">__isset() 使用isset()或empty()函数时候会调用。</span><br><span class="line">__unset() 使用unset()时候会调用。</span><br><span class="line">__sleep() 使用serialize序列化时候调用。</span><br><span class="line">__wakeup() 使用unserialize反序列化的时候调用。</span><br><span class="line">__call() 调用一个不存在的方法的时候调用。</span><br><span class="line">__callStatic()调用一个不存在的静态方法是调用。</span><br><span class="line">__toString() 把对象转换成字符串的时候会调用。比如 echo。</span><br><span class="line">__invoke() 当尝试把对象当方法调用时调用。</span><br><span class="line">__set_state() 当使用var_export()函数时候调用。接受一个数组参数。</span><br><span class="line">__clone() 当使用clone复制一个对象时候调用。</span><br></pre></td></tr></table></figure><h2 id="7-MySQL存储引擎-MyISAM-和-InnoDB-的区别"><a href="#7-MySQL存储引擎-MyISAM-和-InnoDB-的区别" class="headerlink" title="7. MySQL存储引擎 MyISAM 和 InnoDB 的区别"></a>7. MySQL存储引擎 MyISAM 和 InnoDB 的区别</h2><table><thead><tr><th><strong>  </strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td><strong>构成上的区别</strong></td><td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。  .frm文件存储表定义。  数据文件的扩展名为.MYD (MYData)。  索引文件的扩展名是.MYI (MYIndex)。</td><td>基于磁盘的资源是InnoDB表空间数据文件(.frm和它的日志文件(.ibd)，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td></tr><tr><td><strong>事务处理上方面</strong></td><td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持</td><td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td></tr><tr><td><strong>SELECT   UPDATE,INSERT</strong>，<strong>Delete</strong>操作</td><td>如果执行大量的SELECT，MyISAM是更好的选择</td><td><strong>1.</strong>如果你的数据执行大量的<strong>INSERT**</strong>或<strong>**UPDATE</strong>，出于性能方面的考虑，应该使用InnoDB表  <strong>2.DELETE   FROM table</strong>时，InnoDB不会重新建立表，而是一行一行的删除。  <strong>3.LOAD   TABLE FROM MASTER</strong>操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用</td></tr><tr><td><strong>AUTO_INCREMENT</strong>类型的字段</td><td>在MyISAM表中，可以和其他字段一起建立联合索引</td><td>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引</td></tr><tr><td><strong>表的具体行数</strong></td><td>select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含   where条件时，两种表的操作是一样的</td><td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td></tr><tr><td><strong>锁</strong></td><td>表锁</td><td>提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”</td></tr></tbody></table><h2 id="8-说出一些MySQL优化方法？"><a href="#8-说出一些MySQL优化方法？" class="headerlink" title="8. 说出一些MySQL优化方法？"></a>8. 说出一些MySQL优化方法？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</span><br><span class="line">b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。</span><br><span class="line">c. mysql库主从读写分离。</span><br><span class="line">d. 找规律分表，减少单表中的数据量提高查询速度。</span><br><span class="line">e. 添加缓存机制，比如memcached，apc等。</span><br><span class="line">f. 不经常改动的页面，生成静态页面。</span><br><span class="line">g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</span><br></pre></td></tr></table></figure><h2 id="9-下面-r的结果是："><a href="#9-下面-r的结果是：" class="headerlink" title="9. 下面$r的结果是："></a>9. 下面$r的结果是：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = in_array(<span class="string">'01'</span>, <span class="keyword">array</span>(<span class="string">'1'</span>)); <span class="comment">// true</span></span><br><span class="line">$a1 = in_array(<span class="string">'01'</span>, <span class="keyword">array</span>(<span class="string">'1'</span>), <span class="keyword">true</span>); <span class="comment">// false </span></span><br><span class="line">$b = <span class="string">'01'</span> == <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line">$b1 = <span class="string">'02'</span> == <span class="number">1</span>; <span class="comment">// false</span></span><br><span class="line">$r = $a == $b</span><br></pre></td></tr></table></figure><p>A true<br>B false  </p><p>答案为A</p><h2 id="10-说下php中empty-和isset-的区别。"><a href="#10-说下php中empty-和isset-的区别。" class="headerlink" title="10. 说下php中empty()和isset()的区别。"></a>10. 说下php中empty()和isset()的区别。</h2><table><thead><tr><th>Expression</th><th><a href="http://php.net/manual/en/function.gettype.php" target="_blank" rel="noopener">gettype()</a></th><th><a href="http://php.net/manual/en/function.empty.php" target="_blank" rel="noopener">empty()</a></th><th><a href="http://php.net/manual/en/function.is-null.php" target="_blank" rel="noopener">is_null()</a></th><th><a href="http://php.net/manual/en/function.isset.php" target="_blank" rel="noopener">isset()</a></th><th><a href="http://php.net/manual/en/language.types.boolean.php" target="_blank" rel="noopener">boolean</a> : <em>if($x)</em></th></tr></thead><tbody><tr><td><em>$x = “”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>$x = null;</em></td><td><a href="http://php.net/manual/en/language.types.null.php" target="_blank" rel="noopener">NULL</a></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>var $x;</em></td><td><a href="http://php.net/manual/en/language.types.null.php" target="_blank" rel="noopener">NULL</a></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td></tr><tr><td>$x is undefined</td><td><a href="http://php.net/manual/en/language.types.null.php" target="_blank" rel="noopener">NULL</a></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>$x = array();</em></td><td><a href="http://php.net/manual/en/language.types.array.php" target="_blank" rel="noopener">array</a></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>$x = array(‘a’, ‘b’);</em></td><td><a href="http://php.net/manual/en/language.types.array.php" target="_blank" rel="noopener">array</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = false;</em></td><td><a href="http://php.net/manual/en/language.types.boolean.php" target="_blank" rel="noopener">boolean</a></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>$x = true;</em></td><td><a href="http://php.net/manual/en/language.types.boolean.php" target="_blank" rel="noopener">boolean</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = 1;</em></td><td><a href="http://php.net/manual/en/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = 42;</em></td><td><a href="http://php.net/manual/en/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = 0;</em></td><td><a href="http://php.net/manual/en/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>$x = -1;</em></td><td><a href="http://php.net/manual/en/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = “1”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = “0”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>FALSE</strong></td></tr><tr><td><em>$x = “-1”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = “php”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = “true”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr><tr><td><em>$x = “false”;</em></td><td><a href="http://php.net/manual/en/language.types.string.php" target="_blank" rel="noopener">string</a></td><td><strong>FALSE</strong></td><td><strong>FALSE</strong></td><td><strong>TRUE</strong></td><td><strong>TRUE</strong></td></tr></tbody></table><p>引用：<a href="http://php.net/manual/en/types.comparisons.php" target="_blank" rel="noopener">PHP 类型比较表 </a></p><p><code>isset</code> 用于检测变量是否被设置，使用 <code>isset()</code> 测试一个被设置成 NULL 的变量，将返回 <code>FALSE</code> 。<br><code>empty</code> 如果 <code>var</code> 是非空或非零的值，则 <code>empty()</code> 返回 <code>FALSE</code>。换句话说，<code>&quot;&quot;、0、&quot;0&quot;、NULL、FALSE、array()、var $var;</code> 以及没有任何属性的对象都将被认为是空的，如果 <code>var</code> 为空，则返回 <code>TRUE</code> 。</p><p>如果变量为 <code>0</code> ，则<code>empty()</code>会返回<code>TRUE</code>，<code>isset()</code>会返回<code>TRUE</code>；<br>如果变量为空字符串，则<code>empty()</code>会返回TRUE，<code>isset()</code>会返回<code>TRUE</code>；<br>如果变量未定义，则<code>empty()</code>会返回<code>TRUE</code>，<code>isset()</code>会返回<code>FLASE</code>。</p><p>注意：<code>isset()</code> 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已设置，可使用 <code>defined()</code> 函数。<br>当要 判断一个变量是否已经声明的时候 可以使用 <code>isset</code> 函数；<br>当要 判断一个变量是否已经赋予数据且不为空 可以用 <code>empty</code>函数；<br>当要 判断 一个变量 存在且不为空 先 <code>isset</code> 函数 再用 <code>empty</code> 函数；  </p><h2 id="11-cookie和session的区别、cookie禁用后session还可以用吗？"><a href="#11-cookie和session的区别、cookie禁用后session还可以用吗？" class="headerlink" title="11. cookie和session的区别、cookie禁用后session还可以用吗？"></a>11. cookie和session的区别、cookie禁用后session还可以用吗？</h2><p>工作流程：</p><p>以下以PHP为例：</p><ol><li>你第一次访问网站时，</li><li>服务端脚本中开启了Session<code>session_start();</code>，</li><li>服务器会生成一个不重复的 SESSIONID 的文件<code>session_id();</code>，比如在<code>/var/lib/php/session</code>目录</li><li>并将返回(Response)如下的HTTP头 <code>Set-Cookie:PHPSESSIONID=xxxxxxx</code></li><li>客户端接收到<code>Set-Cookie</code>的头，将<code>PHPSESSIONID</code>写入cookie</li><li>当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端</li><li>服务器识别<code>PHPSESSIONID</code>这个cookie，然后去session目录查找对应session文件，</li><li>找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置</li></ol><p>区别：</p><p>1、cookie就是服务器发放给客户端的一些标识，保存在客户端，让客户端每次请求的时候带上，以区分不同的用户；</p><p>2、session是服务器存放在自己那里的用户相关的数据，用每次用户带来的cookie去提取出来，恢复一个之前访问的历史或者相关环境。</p><p>3、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。</p><p>4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p><p>参考：</p><ul><li><a href="https://segmentfault.com/q/1010000007715137" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007715137</a></li><li><a href="http://blog.csdn.net/baidu_31337243/article/details/48954445" target="_blank" rel="noopener">http://blog.csdn.net/baidu_31337243/article/details/48954445</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP面试题汇总-基础&quot;&gt;&lt;a href=&quot;#PHP面试题汇总-基础&quot; class=&quot;headerlink&quot; title=&quot;PHP面试题汇总(基础)&quot;&gt;&lt;/a&gt;PHP面试题汇总(基础)&lt;/h1&gt;&lt;p&gt;文章内容主要参考：&lt;a href=&quot;https://github
      
    
    </summary>
    
      <category term="软技能" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
      <category term="面试" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试题" scheme="https://gaoshangs.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>http协议详解</title>
    <link href="https://gaoshangs.github.io/2018-02-09-http.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-http.html</id>
    <published>2018-02-09T00:38:00.000Z</published>
    <updated>2018-02-23T03:26:14.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http-headers"><a href="#http-headers" class="headerlink" title="http headers"></a>http headers</h2><h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><p><strong>General</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request URL:http://www.cnblogs.com/sunny-sl/p/6529830.html</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:200 OK</span><br><span class="line">Remote Address:42.121.252.58:80</span><br><span class="line">Referrer Policy:origin</span><br></pre></td></tr></table></figure></p><p><strong>Response Headers</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:private, max-age=10</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Content-Encoding:gzip</span><br><span class="line">Content-Type:text/html; charset=utf-8</span><br><span class="line">Date:Fri, 09 Feb 2018 00:35:07 GMT</span><br><span class="line">Expires:Fri, 09 Feb 2018 00:35:17 GMT</span><br><span class="line">Last-Modified:Fri, 09 Feb 2018 00:35:07 GMT</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Vary:Accept-Encoding</span><br><span class="line">X-Frame-Options:SAMEORIGIN</span><br><span class="line">X-UA-Compatible:IE=10</span><br></pre></td></tr></table></figure></p><p><strong>Request  Headers</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding:gzip, deflate</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.9,de;q=0.8,en;q=0.7</span><br><span class="line">Cache-Control:max-age=0</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Cookie:Hm_lvt_cc17b07fc9529e3d80b4482c9ce09086=1503727633; __utma=226521935.1803516701.1504280386.1504280386.1504280386.1; __utmz=226521935.1504280386.1.1.utmccn=(referral)|utmcsr=google.com.au|utmcct=/|utmcmd=referral; pgv_pvi=3195154432; </span><br><span class="line">Host:www.cnblogs.com</span><br><span class="line">If-Modified-Since:Fri, 09 Feb 2018 00:23:55 GMT</span><br><span class="line">Referer:https://www.google.com/</span><br><span class="line">Upgrade-Insecure-Requests:1</span><br><span class="line">User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36</span><br></pre></td></tr></table></figure></p><h3 id="Accept的含义"><a href="#Accept的含义" class="headerlink" title="Accept的含义"></a>Accept的含义</h3><blockquote><p>如<code>Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5</code>表示的含义是什么？</p></blockquote><p>application / xml ， application / xhtml + xml和image / png是首选媒体类型，但如果它们不存在，则发送文本/ html实体（ text/html;q=0.9 ），如果不存在，则发送文本/普通实体（ text/plain;q=0.8 ），如果不存在，则发送具有任何其他媒体类型（ <em>/</em>;q=0.5 ）</p><h3 id="常见的Content-type-mime-类型"><a href="#常见的Content-type-mime-类型" class="headerlink" title="常见的Content-type(mime)类型"></a>常见的Content-type(mime)类型</h3><ul><li>text/html</li><li>application/xml</li><li>application/json</li><li>application/x-www-form-urlencoded 最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。 传递的key/val会经过URL转码，所以如果传递的参数存在中文或者特殊字符需要注意</li><li>multipart/form-data   使用表单上传文件时，必须让 form 的 enctyped 等于这个值</li><li>text/plain</li><li>image/png<h3 id="keep-alive模式"><a href="#keep-alive模式" class="headerlink" title="keep-alive模式"></a>keep-alive模式</h3><h4 id="HTTP的短连接-amp-长连接"><a href="#HTTP的短连接-amp-长连接" class="headerlink" title="HTTP的短连接&amp;长连接"></a>HTTP的短连接&amp;长连接</h4></li><li>短连接：每次请求一个资源就建立连接，请求完成后连接立马关闭。每次请求都经过“创建tcp连接-&gt;请求资源-&gt;响应资源-&gt;释放连接”这样的过程</li><li>长连接(persistent connection)：只建立一次连接，多次资源请求都复用该连接，完成后关闭。要请求一个页面上的十张图，只需要建立一次tcp连接，然后依次请求十张图，等待资源响应，释放连接</li><li>并行连接(multiple connections)，其实就是并发的短连接<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/450px-HTTP_persistent_connection.svg.png" alt=""></li></ul><h4 id="client和server-keep-alive模式访问流程"><a href="#client和server-keep-alive模式访问流程" class="headerlink" title="client和server keep-alive模式访问流程"></a>client和server keep-alive模式访问流程</h4><ol><li>client发出的HTTP请求头需要增加Connection:keep-alive字段</li><li>Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且”应允”client我暂时不会关闭socket连接<br>注意：</li></ol><ul><li>在HTTP/1.0里，为了实现client到web-server能支持长连接，必须在HTTP请求头里显示指定<code>Connection:keep-alive</code></li><li>在HTTP/1.1里，就默认是开启了keep-alive，要关闭keep-alive需要在HTTP请求头里显示指定<code>Connection:close</code></li></ul><p>####<br>Keep-Alive选项</p><ul><li><p>用法：Keep-Alive: name[=value][, name=[value]]…<br>完全可选，但只有在包含了Connection: Keep-Alive首部的情况下才可使用它。</p></li><li><p><strong>参数timeout</strong>：在Keep-Alive响应首部中发送，告诉客户端服务器估计会在打开状态保持到连接空闲多长时间后关闭连接。</p></li><li><strong>参数max</strong>：在Keep-Alive响应首部中发送，告诉客户端服务器还会为另外几个http事务将连接保持在打开状态。<br>注意，这两个参数值仅仅是估计，并非承诺。</li></ul><p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br><span class="line">Keep-Alive: max=5, timeout=120</span><br></pre></td></tr></table></figure></p><p>说明服务器最多还会为另外5个事务保持连接在打开状态，或者将打开状态保持到连接空闲了2两分钟后关闭。<br>参考：</p><ul><li><a href="http://www.firefoxbug.com/index.php/archives/2806/" target="_blank" rel="noopener">理解HTTP之keep-alive</a></li><li><a href="https://www.jianshu.com/p/0a47fc776314" target="_blank" rel="noopener">http持久连接-keep alive和persistent</a></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><img src="http://img.my.csdn.net/uploads/201212/16/1355655874_6620.jpg" alt=""></p><h3 id="http-code与缓存层"><a href="#http-code与缓存层" class="headerlink" title="http code与缓存层"></a>http code与缓存层</h3><ul><li>200状态：当浏览器本地没有缓存或下一层失效时或用户点击CTRL+F5，直接去服务器下载最新数据</li><li>304状态：这一层由last-modify/etag控制。当下一层失效或用户点击F5时，浏览器会发送请求给服务器，如果服务端没有变化，则返回304给浏览器</li><li>200(from cache)：这一层由expires/cache-control控制。<br>  <strong>1. expires(http1.0版有效)是绝对时间。</strong><br>  <strong>2. cache-control(http1.1版本有效)，相对时间，两者都存在时，cache-control覆盖expires</strong>只要没有失效，浏览器只访问自己的缓存<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br><code>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT</code></li></ul><p>客户端第二次请求此URL时，根据HTTP协议的规定，<strong>浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过</strong>：</p><p><code>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT</code></p><p>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p><p>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求</p><h3 id="Etag工作原理"><a href="#Etag工作原理" class="headerlink" title="Etag工作原理"></a>Etag工作原理</h3><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<code>Etag:“5d8c72a5edda8d6a:3239″</code></p><p>客户端的查询更新格式是这样的：<code>If-None-Match:“5d8c72a5edda8d6a:3239″</code><br>如果ETag没改变，则返回状态304。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p><p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p><h3 id="Last-Modified和Expires"><a href="#Last-Modified和Expires" class="headerlink" title="Last-Modified和Expires"></a>Last-Modified和Expires</h3><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。</p><h3 id="Etag和Expires"><a href="#Etag和Expires" class="headerlink" title="Etag和Expires"></a>Etag和Expires</h3><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.</p><h3 id="Last-Modified和Etag"><a href="#Last-Modified和Etag" class="headerlink" title="Last-Modified和Etag"></a>Last-Modified和Etag</h3><p><strong>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败</strong></p><p><strong>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)</strong></p><p>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存</p><p>过程如下:</p><p>1.客户端请求一个页面（A）。</p><p>2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。</p><p>3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</p><p>4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</p><p>5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</p><p>注：</p><p>1、Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。</p><p>2、WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；</p><p>3、客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；</p><p>4、通过上述值到服务器端检查，判断文件是否继续缓存；</p><h3 id="关于-Cache-Control-max-age-秒-和-Expires"><a href="#关于-Cache-Control-max-age-秒-和-Expires" class="headerlink" title="关于 Cache-Control: max-age=秒 和 Expires"></a>关于 Cache-Control: max-age=秒 和 Expires</h3><p>Expires = 时间，HTTP 1.0 版本，缓存的截止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br><strong>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</strong></p><p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p><p><strong>Expires =max-age +   “每次下载时的当前的request时间”</strong></p><p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p><h2 id="http-2-0与http-1-1区别"><a href="#http-2-0与http-1-1区别" class="headerlink" title="http/2.0与http/1.1区别"></a>http/2.0与http/1.1区别</h2><h3 id="1-什么是HTTP-2"><a href="#1-什么是HTTP-2" class="headerlink" title="1.什么是HTTP/2"></a>1.什么是HTTP/2</h3><p>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。</p><h3 id="2-与HTTP-1相比，主要区别包括"><a href="#2-与HTTP-1相比，主要区别包括" class="headerlink" title="2.与HTTP/1相比，主要区别包括"></a>2.与HTTP/1相比，主要区别包括</h3><ul><li>HTTP/2采用二进制格式而非文本格式</li><li>HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li><li>使用报头压缩，HTTP/2降低了开销</li><li>HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</li></ul><h3 id="HTTP-2为什么是二进制？"><a href="#HTTP-2为什么是二进制？" class="headerlink" title="HTTP/2为什么是二进制？"></a>HTTP/2为什么是二进制？</h3><p>比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。</p><h3 id="为什么-HTTP-2-需要多路传输"><a href="#为什么-HTTP-2-需要多路传输" class="headerlink" title="为什么 HTTP/2 需要多路传输?"></a>为什么 HTTP/2 需要多路传输?</h3><p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。<br>而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。<br>所以客户端只需要一个连接就能加载一个页面。</p><h3 id="消息头为什么需要压缩"><a href="#消息头为什么需要压缩" class="headerlink" title="消息头为什么需要压缩?"></a>消息头为什么需要压缩?</h3><p>假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。<br>这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。<br>相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。<br>这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。</p><h3 id="服务器推送的好处是什么？"><a href="#服务器推送的好处是什么？" class="headerlink" title="服务器推送的好处是什么？"></a>服务器推送的好处是什么？</h3><p>当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。<br>服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">HTTP缓存控制小结</a></li><li><a href="http://blog.csdn.net/jekxi/article/details/54342789" target="_blank" rel="noopener">HTTP常见Content-Type比较</a></li><li><a href="http://if-true.com/2015/04/27/tech-difference-between-http-1.1-2.0.html" target="_blank" rel="noopener">http/2.0与http/1.1区别</a></li><li><a href="http://blog.csdn.net/eroswang/article/details/8302191" target="_blank" rel="noopener">浏览器缓存详解:expires,cache-control,last-modified,etag详细说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;http-headers&quot;&gt;&lt;a href=&quot;#http-headers&quot; class=&quot;headerlink&quot; title=&quot;http headers&quot;&gt;&lt;/a&gt;http headers&lt;/h2&gt;&lt;h3 id=&quot;头部字段&quot;&gt;&lt;a href=&quot;#头部字段&quot; cla
      
    
    </summary>
    
    
      <category term="http" scheme="https://gaoshangs.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>跳跃表算法</title>
    <link href="https://gaoshangs.github.io/2018-02-09-algorithm-skip-list.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-algorithm-skip-list.html</id>
    <published>2018-02-08T17:25:00.000Z</published>
    <updated>2018-02-23T03:26:14.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳跃表-skip-list-算法"><a href="#跳跃表-skip-list-算法" class="headerlink" title="跳跃表(skip-list)算法"></a>跳跃表(skip-list)算法</h2><blockquote><p> 它允许快速查询一个有序连续元素的数据链表，它的效率可以做到和二分相同，都是O(logn)的平均时间复杂度，其空间复杂度为O(n)</p></blockquote><h3 id="跳跃表的性质"><a href="#跳跃表的性质" class="headerlink" title="跳跃表的性质"></a>跳跃表的性质</h3><ol><li>由很多层结构组成；</li><li>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</li><li>最底层的链表包含了所有的元素</li><li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）</li><li>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点</li></ol><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/32571293.jpg" alt=""></p><h3 id="层数如何确定"><a href="#层数如何确定" class="headerlink" title="层数如何确定"></a>层数如何确定</h3><p>跳跃表的层数跟结构中最高节点的高度相同。理想情况下，跳跃表结构中第一层中存在所有的节点，第二层只有一半的节点，而且是均匀间隔，第三层则存在1/4的节点，并且是均匀间隔的，以此类推，这样理想的层数就是logN。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>其基本原理就是从<strong>最高层的链表节点</strong>开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/6620991.jpg" alt=""></p><p>ps:遇到37后同一层的下一个节点为边界节点，所以只能往下一层比较继续查找了</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>首先需要<strong>确定插入的层数</strong>（使用掷硬币的方法，正面累加，反面停止）,当确定好要插入的层数以后，则需要将元素都插入到从最底层到第k层</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p><p>参考：<a href="https://www.cnblogs.com/George1994/p/7635731.html" target="_blank" rel="noopener">跳跃表原理和实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;跳跃表-skip-list-算法&quot;&gt;&lt;a href=&quot;#跳跃表-skip-list-算法&quot; class=&quot;headerlink&quot; title=&quot;跳跃表(skip-list)算法&quot;&gt;&lt;/a&gt;跳跃表(skip-list)算法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://gaoshangs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>redis和memcached的区别</title>
    <link href="https://gaoshangs.github.io/2018-02-09-redis-memecached-diff.html"/>
    <id>https://gaoshangs.github.io/2018-02-09-redis-memecached-diff.html</id>
    <published>2018-02-08T16:32:00.000Z</published>
    <updated>2018-02-23T16:16:03.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><blockquote><p>redis作者对这两种基于内存数据存储系统进行的比较：</p><ol><li><strong>Redis支持除key-value之外更多的数据类型</strong></li><li><strong>内存使用效率对比</strong>：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached</li><li><strong>性能对比</strong>:由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis。结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡）</li><li><strong>数据持久化和同步</strong>:memcache不支持，redis支持</li><li><strong>网络IO模型方面：</strong>Memcached是多线程，分为监听线程、worker线程，引入锁，带来了性能损耗。Redis使用单线程的IO复用模型，将速度优势发挥到最大，也提供了较简单的计算功能 </li></ol></blockquote><h3 id="1-数据类型支持不同"><a href="#1-数据类型支持不同" class="headerlink" title="1. 数据类型支持不同"></a>1. 数据类型支持不同</h3><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。<br>最为常用的数据类型主要由五种：<strong>String、Hash、List、Set和Sorted Set</strong>。<br>Redis内部使用一个redisObject对象来表示所有的key和value，主要信息如图：<br><img src="https://www.biaodianfu.com/wp-content/uploads/2014/01/redisObject.jpg" alt="redisObject"></p><h4 id="RedisObject属性"><a href="#RedisObject属性" class="headerlink" title="RedisObject属性"></a>RedisObject属性</h4><ul><li><strong>类型(type)</strong>：代表一个value对象具体是何种数据类型:string, hash, list, set, sorted set</li><li><strong>编码(encoding)</strong>：是不同数据类型在redis内部的存储方式,<br>  比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，<br>  如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，<br>  当然前提是这个字符串本身可以用数值表示，比如:”123″ “456”这样的字符串。</li><li>数据指针(ptr)：</li><li>虚拟内存(vm)：只有打开了Redis的虚拟内存功能，vm字段字段才会真正的分配内存，该功能默认是关闭状态的</li><li>其他(other)</li></ul><h4 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h4><h5 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h5><ul><li>常用命令：set/get/decr/incr/mget等；</li><li>应用场景：String是最常用的一种数据类型，普通的key/value存储都可以归为此类；</li><li>实现方式：<strong>String在redis内部存储默认就是一个字符串</strong>，被redisObject所引用<strong>，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int</strong>。</li></ul><h5 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h5><ul><li><p>常用命令：hget/hset/hgetall等</p></li><li><p>应用场景：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日；</p></li><li><p>实现方式：Redis的Hash实际是内部存储的Value为一个<strong>HashMap</strong>，<strong>并提供了直接存取这个Map成员的接口</strong>。如图所示，Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。</p></li><li><p>当前HashMap的实现有两种方式：<strong>当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构</strong>，<strong>这时对应的value的redisObject的encoding为zipmap</strong>，<strong>当成员数量增大时会自动转成真正的HashMap,此时encoding为ht</strong>。</p><p><img src="https://www.biaodianfu.com/wp-content/uploads/2014/01/hash.jpg" alt=""></p></li></ul><h5 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h5><ul><li>常用命令：lpush/rpush/lpop/rpop/lrange等；</li><li>应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现；</li><li>实现方式：<strong>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作</strong>，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</li></ul><h5 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h5><ul><li>常用命令：sadd/spop/smembers/sunion等；</li><li>应用场景：Redis set对外提供的功能与list类似是一个列表的功能，<strong>特殊之处在于set是可以自动排重的</strong>，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且<strong>set提供了判断某个成员是否在一个set集合内的重要接口</strong>，这个也是list所不能提供的；</li><li>实现方式：<strong>set 的内部实现是一个 value永远为null的HashMap</strong>，实际就是<strong>通过计算hash的方式来快速排重的</strong>，这也是<strong>set能提供判断一个成员是否在集合内的原因</strong>。</li></ul><h5 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5. Sorted Set"></a>5. Sorted Set</h5><ul><li>常用命令：zadd/zrange/zrem/zcard等；</li><li>应用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，<strong>而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序</strong>。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</li><li>实现方式：<strong>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序</strong>，<strong>HashMap里放的是成员到score的映射</strong>，而<strong>跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单</strong>。</li></ul><h5 id="扩展知识：跳跃表"><a href="#扩展知识：跳跃表" class="headerlink" title="扩展知识：跳跃表"></a>扩展知识：跳跃表</h5><p><strong>跳跃表的性质</strong></p><ol><li>由很多层结构组成；</li><li>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</li><li>最底层的链表包含了所有的元素</li></ol><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/32571293.jpg" alt=""></p><p><strong>搜索</strong></p><p>其基本原理就是从<strong>最高层的链表节点</strong>开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/6620991.jpg" alt=""></p><p>ps:遇到37后同一层的下一个节点为边界节点，所以只能往下一层比较继续查找了</p><p>参考：<a href="https://www.cnblogs.com/George1994/p/7635731.html" target="_blank" rel="noopener">跳跃表原理和实现</a></p><h3 id="2-内存管理机制不同"><a href="#2-内存管理机制不同" class="headerlink" title="2. 内存管理机制不同"></a>2. 内存管理机制不同</h3><h3 id="3-数据持久化支持"><a href="#3-数据持久化支持" class="headerlink" title="3. 数据持久化支持"></a>3. 数据持久化支持</h3><p>Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。而memcached是不支持数据持久化操作的</p><h3 id="4-集群管理的不同"><a href="#4-集群管理的不同" class="headerlink" title="4. 集群管理的不同"></a>4. 集群管理的不同</h3><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质</p><ul><li><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。</p><blockquote><p> 当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p></blockquote></li></ul><p><img src="https://www.biaodianfu.com/wp-content/uploads/2014/01/Memcached-node.jpg" alt=""></p><ul><li><p>Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。</p><blockquote><p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。<br>最新版本的Redis已经支持了分布式存储功能。</p></blockquote><p><img src="https://www.biaodianfu.com/wp-content/uploads/2014/01/Redis-Cluster.jpg" alt=""></p></li></ul><p>下图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER</p><ul><li><p>Redis Cluster引入了Master节点和Slave节点</p><blockquote><p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点</p></blockquote></li></ul><p><img src="https://www.biaodianfu.com/wp-content/uploads/2014/01/Redis-Cluster-2.jpg" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://blog.csdn.net/hguisu/article/details/8836819" target="_blank" rel="noopener">Redis原理和应用场景</a></li><li><a href="https://www.biaodianfu.com/redis-vs-memcached.html" target="_blank" rel="noopener">Redis和Memcached的区别</a></li></ul><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>redis集群的几种实现方式如下：</p><ul><li>客户端分片，如redis的Java客户端jedis也是支持的，使用一致性hash</li><li>基于代理的分片，如codis和Twemproxy</li><li>路由查询， redis-cluster</li></ul><p>参考：</p><ul><li><a href="http://blueskykong.com/2018/01/09/rediscluster2/" target="_blank" rel="noopener">Redis Cluster深入与实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis和Memcached的区别&quot;&gt;&lt;a href=&quot;#Redis和Memcached的区别&quot; class=&quot;headerlink&quot; title=&quot;Redis和Memcached的区别&quot;&gt;&lt;/a&gt;Redis和Memcached的区别&lt;/h2&gt;&lt;blockquo
      
    
    </summary>
    
    
      <category term="redis" scheme="https://gaoshangs.github.io/tags/redis/"/>
    
      <category term="memcached" scheme="https://gaoshangs.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash算法和应用</title>
    <link href="https://gaoshangs.github.io/2018-02-08-algorithm-consistent-hashing.html"/>
    <id>https://gaoshangs.github.io/2018-02-08-algorithm-consistent-hashing.html</id>
    <published>2018-02-08T14:39:00.000Z</published>
    <updated>2018-02-23T05:38:38.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一致性HASH原理和应用"><a href="#一致性HASH原理和应用" class="headerlink" title="一致性HASH原理和应用"></a>一致性HASH原理和应用</h2><blockquote><p>问题：单机redis20G如何承载500G的cache（考虑redis集群应用）</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>如何对<strong>请求与缓存服务器之间进行精准映射,以及优雅的扩展，剔除缓存服务器</strong>，提升缓存服务的容错性和扩展性</p><ul><li>容错性：指当系统中某一个或几个服务器变得不可用时，整个系统是否可以正确高效运行；</li><li>扩展性：指当加入新的服务器后，整个系统是否可以正确高效运行。</li></ul><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>一致性哈希将整个哈希空间组织成一个虚拟的圆环，假如整个哈希函数的值空间为0 - 2^32 -1(一个32位的无符号整形)，如下图:整个空间按顺时针方向组织,0和2^32-1在零点中方向重合</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-761c7ac38078a2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/425" alt="一致性HASH闭环"></p><p><strong>第一步：在哈希闭环中确定各台服务器位置</strong></p><p>将各台服务器的ip或主机名为关键字通过H函数得到一个哈希值，然后在哈希闭环中标注位置。如下图3台redis服务：</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-cdb684dc8afcafbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt=""></p><p><strong>第二步：定位数据访问的服务器</strong></p><p>将数据key使用相同的函数H计算出哈希值h，通根据h确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器</p><p>例如我们缓存服务器中有A、B、C、D四个key对应的数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-99c54dadceb7f18b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt="一致性hash函数值空间"></p><p><strong>容错性与可扩展性分析</strong></p><ol><li><p>假设redis-2宕机：ACD节点并不受影响，只有B节点被重定向至Redis-0</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-10c77e305faab998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt="删除节点"></p></li><li><p>如果我们在系统中增加一台服务器Redis-3 Server：对于C这个key，重新定位至Redis-3 服务器，其他非C的key均不受影响</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-620c26159a2f672d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt="添加节点"></p></li></ol><h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p><strong>1. 问题概述</strong></p><p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，必然造成大量数据集中到Redis-1上，而只有极少量会定位到Redis-0上。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-c1d68874c041557d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/539" alt=""></p><p><strong>2. 使用虚拟节点解决</strong></p><p>对每一个服务节点多计算N个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。<strong>在实际应用中，通常将虚拟节点数设置为32甚至更大</strong>，因此即使很少的服务节点也能做到相对均匀的数据分布</p><p><strong>第一步：为每个机器多增加N个虚拟节点</strong></p><p>为每个机器多计算三个虚拟节点，分别计算“Redis-1 #1”、“Redis-1 #2”、“Redis-1 #3”、“Redis-0 #1”、“Redis-0 #2”、“Redis-0 #3”的哈希值，于是形成六个虚拟节点:</p><p><img src="https://upload-images.jianshu.io/upload_images/2836699-03901e612ee8c8fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628" alt=""></p><p><strong>第二步：将虚拟节点映射到实际节点</strong></p><p>数据定位算法不变，只是<strong>多了一步虚拟节点到实际节点的映射</strong>，例如定位到“Redis-1#1”、“Redis-1#2”、“Redis-1#3”三个虚拟节点的数据均定位到Redis-1上</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/793c76ee84fc" target="_blank" rel="noopener">一致性哈希算法在分布式缓存中的应用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一致性HASH原理和应用&quot;&gt;&lt;a href=&quot;#一致性HASH原理和应用&quot; class=&quot;headerlink&quot; title=&quot;一致性HASH原理和应用&quot;&gt;&lt;/a&gt;一致性HASH原理和应用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;问题：单机redis20G如何承载
      
    
    </summary>
    
    
      <category term="算法" scheme="https://gaoshangs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="一致性HASH" scheme="https://gaoshangs.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7HASH/"/>
    
  </entry>
  
  <entry>
    <title>CURL用法</title>
    <link href="https://gaoshangs.github.io/2018-02-08-curl-usage.html"/>
    <id>https://gaoshangs.github.io/2018-02-08-curl-usage.html</id>
    <published>2018-02-08T05:50:00.000Z</published>
    <updated>2018-02-08T06:04:46.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><code>-w</code> 从文件中读取要打印信息的格式</li><li><code>-o</code> /dev/null：把响应的内容丢弃，因为我们这里并不关心它，只关心请求的耗时情况</li><li><code>-s</code> 不要打印进度条</li><li><code>-L</code> 页面使用了301重定向，这时我们可以添加-L参数来跟踪URL重定向</li><li><code>-i</code> <code>--include</code> 查看头信息, 页面响应头会和页面源码（响应体）一起返回</li><li><code>-I</code> <code>--head</code> 只返回头信息不返回页面源码</li><li><code>-X</code> 指定请求方法，配合<code>--data</code>添加提交数据</li><li><code>--data</code> 添加提交数据,格式:”a=a1&amp;b=b1”</li><li><code>-H</code> <code>--header</code> 来指定请求头:<code>curl -H &#39;Content-Type:application/json&#39; -H &#39;Authorization: bearer eyJhbGciOiJIUzI1NiJ9&#39; itbilu.com</code></li></ul><h2 id="请求耗时查看"><a href="#请求耗时查看" class="headerlink" title="请求耗时查看"></a>请求耗时查看</h2><h3 id="使用curl-w命令"><a href="#使用curl-w命令" class="headerlink" title="使用curl -w命令"></a>使用curl -w命令</h3><p><strong>配置文件</strong><br>新建<code>curl-format.txt</code>文件，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">time_namelookup:  %&#123;time_namelookup&#125;\n</span><br><span class="line">time_connect:  %&#123;time_connect&#125;\n</span><br><span class="line">time_appconnect:  %&#123;time_appconnect&#125;\n</span><br><span class="line">time_redirect:  %&#123;time_redirect&#125;\n</span><br><span class="line">time_pretransfer:  %&#123;time_pretransfer&#125;\n</span><br><span class="line">time_starttransfer:  %&#123;time_starttransfer&#125;\n</span><br><span class="line">            ----------\n</span><br><span class="line"> time_total:  %&#123;time_total&#125;\n</span><br></pre></td></tr></table></figure></p><p><strong>使用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -w <span class="string">"@curl-format.txt"</span> -o /dev/null -s -L <span class="string">"http://cizixs.com"</span></span><br><span class="line">time_namelookup:  0.012</span><br><span class="line">       time_connect:  0.227</span><br><span class="line">    time_appconnect:  0.000</span><br><span class="line">      time_redirect:  0.000</span><br><span class="line">   time_pretransfer:  0.227</span><br><span class="line"> time_starttransfer:  0.443</span><br><span class="line">                    ----------</span><br><span class="line">         time_total:  0.867</span><br></pre></td></tr></table></figure></p><h3 id="使用httpstat命令"><a href="#使用httpstat命令" class="headerlink" title="使用httpstat命令"></a>使用httpstat命令</h3><p><strong>安装</strong><br><code>pip install httpstat</code></p><p><strong>使用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认请求</span></span><br><span class="line">httpstat www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># form表单提交</span></span><br><span class="line">httpstat www.baidu.com -XPOST --data <span class="string">"a=a1&amp;b=b1"</span></span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">curl 命令行工具的使用及命令参数说明</a><br><a href="http://cizixs.com/2017/04/11/use-curl-to-analyze-request" target="_blank" rel="noopener">使用 curl 命令分析请求的耗时情况</a><br><a href="https://github.com/reorx/httpstat" target="_blank" rel="noopener">httpstat工具</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选项&quot;&gt;&lt;a href=&quot;#选项&quot; class=&quot;headerlink&quot; title=&quot;选项&quot;&gt;&lt;/a&gt;选项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt; 从文件中读取要打印信息的格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; /dev/nul
      
    
    </summary>
    
    
      <category term="curl" scheme="https://gaoshangs.github.io/tags/curl/"/>
    
      <category term="linux" scheme="https://gaoshangs.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB索引底层原理详解</title>
    <link href="https://gaoshangs.github.io/2018-02-07-mysql-innodb-index.html"/>
    <id>https://gaoshangs.github.io/2018-02-07-mysql-innodb-index.html</id>
    <published>2018-02-07T12:18:00.000Z</published>
    <updated>2018-02-23T03:26:14.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL的索引类型"><a href="#MySQL的索引类型" class="headerlink" title="MySQL的索引类型"></a>MySQL的索引类型</h2><h3 id="从数据结构角度"><a href="#从数据结构角度" class="headerlink" title="从数据结构角度"></a>从数据结构角度</h3><ol><li>B+树索引(O(nlogn))</li><li>hash索引：</li></ol><ul><li>仅仅能够满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询, 无法通过操作索引来排序</li><li>检索效率最高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引</li><li>不能避免全表扫描,当存在大量相同hash值得时候，hash索引的效率会变低</li></ul><ol><li>FULLTEXT索引:支持full-text的字段只有char、varchar、text数据类型, 主要是用来代替like “%<em>*</em>%”效率低下的问题</li></ol><h3 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h3><ol><li>聚簇索引（clustered index）</li><li>非聚簇索引（non-clustered index）</li></ol><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><ol><li>主键索引(PRIMARY)：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引(NORMAL)或单列索引</li><li>多列索引（复合索引)：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li></ol><p><strong>索引添加</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`tab1`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`idx_index_name`</span> <span class="keyword">USING</span> BTREE (<span class="string">`field1`</span>, <span class="string">`field2`</span>) <span class="keyword">comment</span> <span class="string">''</span>;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树（Balanced-Binary-Tree"><a href="#平衡二叉树（Balanced-Binary-Tree" class="headerlink" title="平衡二叉树（Balanced Binary Tree)"></a>平衡二叉树（Balanced Binary Tree)</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</li><li>并且左右两个子树都是一棵平衡二叉树。</li></ol><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><p>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等</p><h2 id="BTree-B-Tree"><a href="#BTree-B-Tree" class="headerlink" title="BTree,B+Tree"></a>BTree,B+Tree</h2><h3 id="B树-即二叉搜索树"><a href="#B树-即二叉搜索树" class="headerlink" title="B树(即二叉搜索树)"></a>B树(即二叉搜索树)</h3><ol><li>所有非叶子结点至多拥有两个儿子（Left和Right）</li><li>所有结点存储一个关键字；</li><li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字自小而大顺序链接</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</li><li>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</li><li>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li><li>B+树：在B-树基础上，为叶子结点增加<strong>链表指针</strong>，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li><li>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</li></ul><h2 id="B-Tree索引实现原理"><a href="#B-Tree索引实现原理" class="headerlink" title="B+Tree索引实现原理"></a>B+Tree索引实现原理</h2><h3 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h3><p><strong>B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。</strong></p><p>B+树示意图：</p><p><img src="http://img.blog.csdn.net/20160902212733344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="B+树示意图"></p><h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>组成部分：File Header(文件头)、Page Header(页头)、Infimun + Supremum Records、User Records(用户记录，即行记录)、Free Space(空闲空间)、Page Directory(页目录)、File Trailer(文件结尾信息)</p><ul><li><p><strong>页是InnoDB存储引擎管理数据库的最小磁盘单位</strong>,InnoDB中的页大小为16KB，且不可以更改。</p></li><li><p><strong>叶子节点(页与页之间)是双向链表串起来的</strong>，头连上一页的尾，尾连下一页的头</p><p><img src="http://img.blog.csdn.net/20160902212823436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="双向链表"></p></li><li><p><strong>每个数据页中有两个虚拟的行记录，用来限定记录的边界</strong>。(行记录是记录在页中的，同时是在页内行记录之间也是双向链表链接的)</p><p><img src="http://img.blog.csdn.net/20160902212836951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="虚拟行记录演示"></p></li><li><p><strong>页目录(Page Directory)通过顺序排放的记录指针(也叫槽)存放了记录的相对位置，通过这些槽找到具体的数据位置</strong></p><blockquote><p>页目录中存放了记录的相对位置，有些时候这些记录指针称为Slots（槽）或者目录槽，与其他数据库不同的是，<strong>InnoDB并不是每个记录拥有一个槽</strong>，InnoDB中的槽是一个稀疏目录，即一个槽中可能属于多个记录，最少属于4个目录，最多属于8个目录。槽中记录按照键顺序存放，这样可以利用二叉查找迅速找到记录的指针。<strong>但是由于InnoDB中的Slots是稀疏目录，二叉查找的结果只是一个粗略的结果</strong>，所以InnoDB必须通过recorder header中的next_record来继续查找相关记录。同时slots很好的解释了recorder header中的n_owned值的含义，即还有多少记录需要查找，因为这些记录并不包括在slots中</p></blockquote></li></ul><h3 id="查询B-树索引的流程"><a href="#查询B-树索引的流程" class="headerlink" title="查询B+树索引的流程"></a>查询B+树索引的流程</h3><p><strong>首先通过B+树索引找到叶节点，再找到对应的数据页，然后将数据页加载到内存中，通过二分查找Page Directory中的槽，查找出一个粗略的目录，然后根据槽的指针指向链表中的行记录，之后在链表中依次查找。</strong></p><p>注意：</p><p><strong>B+树索引不能找到具体的一条记录</strong>，而是只能找到对应的页。<strong>把页从磁盘装入到内存中</strong>，再通过<strong>Page Directory进行二分查找</strong>，同时此<strong>二分查找也可能找不到具体的行记录</strong>（有可能会找到），只是能找到一个接近的链表中的点，再从此点开始遍历链表进行查找。</p><h2 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="headerlink" title="聚簇索引/非聚簇索引"></a>聚簇索引/非聚簇索引</h2><p>区别：</p><ul><li>聚簇索引一般是为主键索引，一张表只能有一个聚簇索引，B+树的叶子节点存储了行数据和主键。</li><li>非聚簇索引可以有多个，叶节点除了包含关键字键值外还包含聚集索引的主键</li></ul><p><strong>聚集索引</strong></p><p><strong>聚集索引是按每张表的主键构造的一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的节点成为数据页</strong>，这个特性决定了索引组织表中数据也是索引的一部分。由于实际的数据页只能按照一颗B+树进行排序，所以<strong>每张表只能拥有一个聚集索引</strong>。查询优化器非常倾向于采用聚集索引，因为其直接存储行数据，所以主键的排序查询和范围查找速度非常快。</p><p>不是物理上的连续，而是逻辑上的，不过在刚开始时数据是顺序插入的所以是物理上的连续，随着数据增删，物理上不再连续。</p><p><strong>辅助索引</strong></p><p><strong>辅助索引页级别不包含行的全部数据</strong>。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签，该书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。其中存的就是聚集索引的键。</p><p>辅助索引的存在并不影响数据在聚集索引的结构组织。InnoDB会遍历辅助索引并通过叶级别的指针<strong>获得指向主键索引的主键，然后通过主键索引找到一个完整的行记录。当然如果只是需要辅助索引的值和主键索引的值，那么只需要查找辅助索引就可以查询出索要的数据，就不用再去查主键索引了</strong>。</p><h3 id="什么是一级索引、二级索引及生成场景"><a href="#什么是一级索引、二级索引及生成场景" class="headerlink" title="什么是一级索引、二级索引及生成场景"></a>什么是一级索引、二级索引及生成场景</h3><p>每个InnoDB表具有一个特殊的索引称为<strong>聚簇索引</strong>（也叫聚集索引，聚类索引，簇集索引）。</p><ul><li>如果表上定义有主键，该<strong>主键索引就是聚簇索引</strong>。</li><li>如果未定义主键，<strong>MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键</strong>，InnoDB使用它作为聚簇索引。</li><li>如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</li></ul><p>表中的聚簇索引（clustered index ）就是<strong>一级索引</strong>，除此之外，<strong>表上的其他非聚簇索引都是二级索引</strong>，又叫辅助索引（secondary indexes）</p><h3 id="MyISAM和InnoDB索引实现"><a href="#MyISAM和InnoDB索引实现" class="headerlink" title="MyISAM和InnoDB索引实现"></a>MyISAM和InnoDB索引实现</h3><p>原始数据如图：</p><p><img src="http://img2.tuicool.com/ZNn6B3f.jpg!web" alt="原始数据"></p><h4 id="MyISAM引擎索引实现方式"><a href="#MyISAM引擎索引实现方式" class="headerlink" title="MyISAM引擎索引实现方式"></a>MyISAM引擎索引实现方式</h4><p><strong>索引实现原理</strong></p><p>是按列值与行号来组织索引的。它的<strong>叶子节点</strong>中保存的实际上是指向存放数据的物理块的指针。从MYISAM存储的物理文件我们能看出，MYISAM引擎的索引文件（.MYI）和数据文件(.MYD)是相互独立的。</p><p><img src="http://img0.tuicool.com/N3MnUfi.jpg!web" alt="MyISAM引擎的数据存储方式"></p><p><strong>主键索引与二级索引</strong></p><p>MyISAM的主键索引和二级索引叶子节点存放的都是：<strong>列值与行号的组合，叶子节点中保存的是数据的物理地址</strong></p><p>MYISAM的主键索引和二级索引没有任何区别：<strong>主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键</strong>。</p><h4 id="InnoDB引擎索引实现方式"><a href="#InnoDB引擎索引实现方式" class="headerlink" title="InnoDB引擎索引实现方式"></a>InnoDB引擎索引实现方式</h4><p><strong>1. 聚簇索引</strong>(一级索引)</p><p>聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列(如col2)，如下图：</p><p><img src="http://img2.tuicool.com/EfIBbi2.jpg!web" alt="InnoDB存储的数据结构"></p><p><strong>2. 非聚簇索引</strong>(二级索引)</p><p>InnoDB的二级索引与主键索引有很大的不同，InnoDB的的二级索引的叶子节点存放的是：<strong>KEY字段加主键值</strong>，而不是行指针(row pointers)，如下图</p><p><img src="http://img1.tuicool.com/zAb22qm.jpg!web" alt="二级索引"></p><p>二级索引查询步骤：<strong>先查到主键值，然后InnoDB再根据查到的主键值通过主键索引找到对应的数据块</strong>。</p><h4 id="INNODB和MYISAM的主键索引与二级索引的对比"><a href="#INNODB和MYISAM的主键索引与二级索引的对比" class="headerlink" title="INNODB和MYISAM的主键索引与二级索引的对比"></a>INNODB和MYISAM的主键索引与二级索引的对比</h4><p>如图：</p><p><img src="http://img2.tuicool.com/nu2YNbz.jpg!web" alt="INNODB和MYISAM对比图"></p><p>参考资料：高性能MYSQL</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E6%A0%91/7641279" target="_blank" rel="noopener">平衡树</a><br><a href="http://blog.csdn.net/ithomer/article/details/5658306" target="_blank" rel="noopener">BTree,B-Tree,B+Tree,B*Tree都是什么</a><br><a href="https://segmentfault.com/q/1010000003832312" target="_blank" rel="noopener">MySQL有哪些索引类型 ?</a><br><a href="https://www.cnblogs.com/cq-home/p/3482101.html" target="_blank" rel="noopener">mysql索引类型 normal, unique, full text</a><br><a href="http://blog.csdn.net/u012978884/article/details/52416997" target="_blank" rel="noopener">MySQL_innoDB索引底层原理详解</a><br><a href="https://www.cnblogs.com/T8881/p/5940338.html" target="_blank" rel="noopener">MYSQL性能调优: 对聚簇索引和非聚簇索引的认识</a><br><a href="http://blog.csdn.net/roxliu/article/details/70160664" target="_blank" rel="noopener">面试知识点6：MySQL中InnoDB的一级索引、二级索引</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL的索引类型&quot;&gt;&lt;a href=&quot;#MySQL的索引类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL的索引类型&quot;&gt;&lt;/a&gt;MySQL的索引类型&lt;/h2&gt;&lt;h3 id=&quot;从数据结构角度&quot;&gt;&lt;a href=&quot;#从数据结构角度&quot; class
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://gaoshangs.github.io/tags/mysql/"/>
    
      <category term="索引原理" scheme="https://gaoshangs.github.io/tags/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>归并排序算法</title>
    <link href="https://gaoshangs.github.io/2018-02-07-algorithm-merging-sorting.html"/>
    <id>https://gaoshangs.github.io/2018-02-07-algorithm-merging-sorting.html</id>
    <published>2018-02-07T10:44:00.000Z</published>
    <updated>2018-02-08T12:59:46.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>把 n 个记录看成 n 个长度为 l 的有序子表</li><li>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</li><li>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，其中的分治法是常用的一种解决问题的方法，现在流行的云计算其实就是一种分治法的应用。</p><h3 id="归并算法详解"><a href="#归并算法详解" class="headerlink" title="归并算法详解"></a>归并算法详解</h3><blockquote><p>归并排序的中心思想：申请一个空序列，将两个已经排序好的序列，合并成一个排序的序列</p></blockquote><p>假设：<br>序列A：3 4 7 9<br>序列B：2  6  8<br>序列C：空<br>合并思路是：先申请一个序列，将指针分别指向3和2，这时候进行比较，3大于2，所以把2放到序列C，序列B指针后移到6，这时候序列A的3小于6，把3放到序列C，A序列指针后移<br>4小于序列B的6，把4放到序列C，依次类推。。。直到最后只剩下序列A中的9，把9合并到序列C，完成归并排序</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote><p> 字面解释就是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个思想在实际工作中的作用非常大，特别是处理大数据和做复杂运算的时候。</p></blockquote><p>假设：无序序列：4 3 7 9 2 8 6<br>将数组分成长度为2，并使每个子数组有序：<br><code>[3, 4] [7, 9] [2, 8] [6]</code><br>然后分别两个一对进行归并，然后就可以得到最终的有序序列：2 3 4 6 7 8</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>归并排序的一个缺点是它需要存储器有另一个大小等于数据项数目的数组。如果初始数组几乎占满整个存储器，那么归并排序将不能工作，但是如果有足够的空间，归并排序会是一个很好的选择。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://bubkoo.com/2014/01/15/sort-algorithm/merge-sort/" target="_blank" rel="noopener">常见排序算法 - 归并排序 (Merge Sort)_有图</a><br><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/merge_sort.html" target="_blank" rel="noopener">经典排序算法 - 归并排序Merge sort</a><br><a href="http://www.jb51.net/article/95016.htm" target="_blank" rel="noopener">详解PHP归并排序的实现</a><br><a href="http://blog.csdn.net/lemon_tree12138/article/details/48783535" target="_blank" rel="noopener">大数据算法：对5亿数据进行排序</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算法思路&quot;&gt;&lt;/a&gt;算法思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;把 n 个记录看成 n 个长度为 l 的有序子表&lt;/li&gt;
&lt;li&gt;进行两两归并使记录关键字有序，得到 n/2 
      
    
    </summary>
    
    
      <category term="归并排序" scheme="https://gaoshangs.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="https://gaoshangs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器网站故障分析常用的命令</title>
    <link href="https://gaoshangs.github.io/2018-02-07-linux-failure-analysis-command.html"/>
    <id>https://gaoshangs.github.io/2018-02-07-linux-failure-analysis-command.html</id>
    <published>2018-02-06T17:06:00.000Z</published>
    <updated>2018-02-07T06:05:01.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令简单说明"><a href="#常用命令简单说明" class="headerlink" title="常用命令简单说明"></a>常用命令简单说明</h2><h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><blockquote><p>grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来</p><ol><li>格式<br>grep [option] pattern file</li><li>选项<br>-v   –revert-match   #显示不包含匹配文本的所有行<br>-w   –word-regexp   #只显示全字符合的列<br>-h   –no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称</li></ol></blockquote><h3 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h3><blockquote><p>是一种处理文本文件的语言，是一个强大的文本分析工具</p><ol><li><strong>规则</strong>：awk [选项参数] ‘条件1{动作1} 条件2{动作2} …’ 文件名<br>（ 如果条件1，执行动作1；如果条件2，执行动作2 ）</li><li><strong>变量</strong> ：$1：提取第一列 ,$2提取第二列,</li><li>选项<br>-F :指定输入文件折分隔符</li><li>输出<br>print：会在每个输出之后自动加入一个换行符<br>printf：标准格式输出命令，需要换行需手动加入</li></ol></blockquote><ol><li>应用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;printf $2 "\t" $3"\n"&#125;'</span> user.txt</span><br><span class="line">awk -F, <span class="string">'&#123;print $1,$2&#125;'</span>   log.txt</span><br><span class="line">awk -F <span class="string">'[ ,]'</span>  <span class="string">'&#123;print $1,$2,$5&#125;'</span>   log.txt <span class="comment"># 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h3><blockquote><p>提取列: cut [选项] 文件</p><ol><li>选项:<br>-f 列号        （ –field 提取第几列 ）<br>-d 分隔符    （ –delimiter 按照指定分隔符分割列 ）</li><li>应用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d <span class="string">":"</span> -f 1,3 /etc/passwd <span class="comment"># :分隔，输出1，3行</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><blockquote><p>数据进行选取、替换、删除、新增的命令</p><ol><li>使用方法：sed [选项] ‘[动作]’ 文件名</li><li>选项<br>-n    :    一般sed命令会把所有数据都输出到屏幕；如果加入此选项，则只会把经过sed命令处理的行输出到屏幕。(如：sed -n ‘2p’ user.txt    # 输出第二行)</li><li>动作<br>d : 删除，删除指定的行。<br>p : 打印，输出指定的行。<br>s  : 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似）如：sed “s/r//g” user.txt 替换r为空</li><li>实例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'2p'</span> user.txt <span class="comment"># 输出第二行, p一般都要和-n使用，不加-n会显示出所有的行</span></span><br><span class="line">sed <span class="string">"s/r//g"</span> user.txt <span class="comment"># 替换r为空</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h3><blockquote><p>排序</p><ol><li>选项<br>-n：按数值排序，默认按ASCII码值排序<br>\u：在输出行中去除重复行<br>-r：降序(默认是降序)<br>-o：输出结果重定向到文件<br>\t：指定间隔符(配合-k指定列数排序)<br>-k: 指定列排序</li></ol></blockquote><h3 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h3><blockquote><p>用于显示各种网络相关信息，如网络连接，路由表，接口状态</p><ol><li>选项<br>-a (all)显示所有选项，默认不显示LISTEN相关(<strong>如果需要显示LISTEN相关需增加-l选项</strong>)<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-l 仅列出有在 Listen (监听) 的服務状态<br>-p 显示建立相关链接的程序名</li></ol></blockquote><h2 id="系统连接状态"><a href="#系统连接状态" class="headerlink" title="系统连接状态"></a>系统连接状态</h2><ol><li>查看TCP连接状态<br>常用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant |awk <span class="string">'&#123;print $6&#125;'</span>|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure></li></ol><p>可用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk <span class="string">'/^tcp/ &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;'</span> </span><br><span class="line">netstat -n | awk <span class="string">'/^tcp/ &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,"t",state[key]&#125;'</span></span><br><span class="line">netstat -n | awk <span class="string">'/^tcp/ &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,"t",arr[k]&#125;'</span></span><br><span class="line">netstat -n |awk <span class="string">'/^tcp/ &#123;print $NF&#125;'</span>|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure></p><ol><li>查找请求数20个IP<br><code>netstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20</code></li></ol><p><code>netstat -ant |awk &#39;/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}&#39; |sort -rn|head -n20</code></p><ol><li><p>用tcpdump嗅探80端口的访问看看谁最高<br><code>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#39; | sort | uniq -c | sort -nr |head -20</code></p></li><li><p>查找较多time_wait连接<br><code>netstat -n|grep TIME_WAIT|awk &#39;{print $5}&#39;| cut -d &#39;:&#39; -f 1 | sort|uniq -c|sort -rn|head -n2</code></p></li><li>找查较多的SYN连接<br><code>netstat -an | grep SYN | awk &#39;{print $5}&#39; | awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -nr | more</code></li><li>根据端口列进程<br><code>netstat -ntlp | grep 80 | awk &#39;{print $NF}&#39; | cut -d &#39;/&#39; -f1</code></li></ol><h2 id="nginx日志知识"><a href="#nginx日志知识" class="headerlink" title="nginx日志知识"></a>nginx日志知识</h2><blockquote><p>nginx有一个非常灵活的日志记录模式。每个级别的配置可以有各自独立的访问日志。日志格式通过log_format命令来定义。</p></blockquote><h3 id="access-log指令"><a href="#access-log指令" class="headerlink" title="access_log指令"></a>access_log指令</h3><p>语法: <code>access_log path [format [buffer=size [flush=time]]];</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access_log path format gzip [=level] [buffer=size] [flush=time];</span><br><span class="line">access_log syslog:server=address\[,parameter=value] [format];</span><br><span class="line">access_log off;</span><br></pre></td></tr></table></figure></p><p>默认值: <code>access_log logs/access.log combined;</code><br>配置段: <code>http, server, location, if in location, limit_except</code><br><code>gzip</code>：压缩等级。<br><code>buffer</code>：设置内存缓存区大小。<br><code>flush</code>：保存在缓存区中的最长时间。<br>不记录日志：<code>access_log off;</code><br>使用默认<code>combined</code>格式记录日志：<br><code>access_log logs/access.log 或 access_log logs/access.log combined;</code></p><h3 id="log-format指令"><a href="#log-format指令" class="headerlink" title="log_format指令"></a>log_format指令</h3><ol><li>语法: <code>log_format name string …;</code></li><li>默认值: <code>log_format combined “…”;</code></li><li><p>配置段: <code>http</code><br><strong>name表示格式名称，string表示等义的格式。</strong></p></li><li><p>默认配置：log_format有一个默认的无需设置的combined日志格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_format combined <span class="string">'$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>对应的日志记录:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [21/Sep/2016:10:57:04 +0800] <span class="string">"GET / HTTP/1.1"</span> 302 5 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36"</span> <span class="string">"-"</span> </span><br><span class="line">127.0.0.1 - - [21/Sep/2016:10:57:04 +0800] <span class="string">"GET /dashboard.php HTTP/1.1"</span> 200 26652 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36"</span> <span class="string">"-"</span></span><br></pre></td></tr></table></figure></p><ol><li><p>日志格式变量含义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$remote_addr</span>, <span class="variable">$http_x_forwarded_for</span> 记录客户端IP地址</span><br><span class="line"><span class="variable">$remote_user</span> 记录客户端用户名称</span><br><span class="line"><span class="variable">$request</span> 记录请求的URL和HTTP协议</span><br><span class="line"><span class="variable">$status</span> 记录请求状态</span><br><span class="line"><span class="variable">$body_bytes_sent</span> 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span><br><span class="line"><span class="variable">$bytes_sent</span> 发送给客户端的总字节数。</span><br><span class="line"><span class="variable">$connection</span> 连接的序列号。</span><br><span class="line"><span class="variable">$connection_requests</span> 当前通过一个连接获得的请求数量。</span><br><span class="line"><span class="variable">$msec</span> 日志写入时间。单位为秒，精度是毫秒。</span><br><span class="line"><span class="variable">$pipe</span> 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span><br><span class="line"><span class="variable">$http_referer</span> 记录从哪个页面链接访问过来的</span><br><span class="line"><span class="variable">$http_user_agent</span> 记录客户端浏览器相关信息</span><br><span class="line"><span class="variable">$request_length</span> 请求的长度（包括请求行，请求头和请求正文）。</span><br><span class="line"><span class="variable">$request_time</span> 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span><br><span class="line"><span class="variable">$time_iso8601</span> ISO8601标准格式下的本地时间。</span><br><span class="line"><span class="variable">$time_local</span> 通用日志格式下的本地时间。</span><br><span class="line">[warning]发送给客户端的响应头拥有“sent_http_”前缀。 比如<span class="variable">$sent_http_content_range</span>。[/warning]</span><br></pre></td></tr></table></figure></li><li><p>常见问题</p></li></ol><ul><li>获取真实客户IP：如果nginx位于负载均衡器，squid，nginx反向代理之后，web服务器无法直接获取到客户端真实的IP地址了。 $remote_addr获取反向代理的IP地址。反向代理服务器在转发请求的http头信息中，可以增加X-Forwarded-For信息，用来记录 客户端IP地址和客户端请求的服务器地址。PS: 获取用户真实IP 参见<a href="http://www.ttlsa.com/html/2235.html" target="_blank" rel="noopener">http://www.ttlsa.com/html/2235.html</a></li></ul><h2 id="网站日志分析篇-nginx"><a href="#网站日志分析篇-nginx" class="headerlink" title="网站日志分析篇(nginx)"></a>网站日志分析篇(nginx)</h2><ol><li><p>获得访问前10位的ip地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat nginx.log | awk <span class="string">'&#123;print $1&#125;'</span> | sort | uniq -c | sort -nr | head -n 10 </span><br><span class="line"></span><br><span class="line">cat nginx.log|awk <span class="string">'&#123;counts[$(1)]+=1&#125;; END &#123;for(url in counts) print counts[url], url&#125;'</span> | sort -nr</span><br></pre></td></tr></table></figure></li><li><p>访问次数最多的文件或页面,取前20<br><code>cat nginx.log | awk &#39;{print $7}&#39; | grep -E &quot;^/.*&quot; | sort | uniq -c | sort -nr | head -n 20</code></p></li><li><p>统计404的连接<br><code>cat nginx.log | awk &#39;/ 404 /{print $7}&#39; | sort | uniq -c | sort -nr | more</code></p></li></ol><h2 id="系统Debug分析篇"><a href="#系统Debug分析篇" class="headerlink" title="系统Debug分析篇"></a>系统Debug分析篇</h2><p>1.调试命令<br><code>strace -p pid</code><br>2.跟踪指定进程的PID<br><code>gdb -p pid</code></p><p>参考：<br><a href="http://blog.csdn.net/xiangliangyu/article/details/7056937" target="_blank" rel="noopener">Linux Web服务器网站故障分析常用的命令</a><br><a href="http://www.ttlsa.com/linux/the-nginx-log-configuration/" target="_blank" rel="noopener">nginx日志配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用命令简单说明&quot;&gt;&lt;a href=&quot;#常用命令简单说明&quot; class=&quot;headerlink&quot; title=&quot;常用命令简单说明&quot;&gt;&lt;/a&gt;常用命令简单说明&lt;/h2&gt;&lt;h3 id=&quot;grep-命令&quot;&gt;&lt;a href=&quot;#grep-命令&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式面试题</title>
    <link href="https://gaoshangs.github.io/2018-02-06-design-pattern-interview-question.html"/>
    <id>https://gaoshangs.github.io/2018-02-06-design-pattern-interview-question.html</id>
    <published>2018-02-06T03:20:00.000Z</published>
    <updated>2018-02-06T04:25:08.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制反转（IoC）与依赖注入（DI）"><a href="#控制反转（IoC）与依赖注入（DI）" class="headerlink" title="控制反转（IoC）与依赖注入（DI）"></a>控制反转（IoC）与依赖注入（DI）</h2><ol><li>控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。</li><li>依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。</li><li>通过IoC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。</li></ol><p>参考：<a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/" target="_blank" rel="noopener">控制反转（IoC）与依赖注入（DI）</a></p><h2 id="理解PHP依赖注入和Laravel的IOC容器"><a href="#理解PHP依赖注入和Laravel的IOC容器" class="headerlink" title="理解PHP依赖注入和Laravel的IOC容器"></a>理解PHP依赖注入和Laravel的IOC容器</h2><p>依赖注入：把一个类中可变换的部分提取出来抽象为单独的类，然后在将实例变量注入到原来的类中，供原始类进行使用<br>IOC容器：控制反转是工程中解耦合的思想，本来需要自己new的类现在完全交给了容器去实例化，比如类A依赖B类，容器创建B的实例，类A只管使用即可。Laravel中Phalcon\DI就是这个容器的实现<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeComponent</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $_di;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($di)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_di = $di;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">someDbTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the connection service</span></span><br><span class="line">        <span class="comment">// Always returns a new connection</span></span><br><span class="line">        $connection = <span class="keyword">$this</span>-&gt;_di-&gt;get(<span class="string">'db'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">someOtherDbTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get a shared connection service,</span></span><br><span class="line">        <span class="comment">// this will return the same connection everytime</span></span><br><span class="line">        $connection = <span class="keyword">$this</span>-&gt;_di-&gt;getShared(<span class="string">'db'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//This method also requires a input filtering service</span></span><br><span class="line">        $filter = <span class="keyword">$this</span>-&gt;_db-&gt;get(<span class="string">'filter'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$di = <span class="keyword">new</span> Phalcon\DI();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Register a "db" service in the container</span></span><br><span class="line">$di-&gt;set(<span class="string">'db'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">"host"</span> =&gt; <span class="string">"localhost"</span>,</span><br><span class="line">        <span class="string">"username"</span> =&gt; <span class="string">"root"</span>,</span><br><span class="line">        <span class="string">"password"</span> =&gt; <span class="string">"secret"</span>,</span><br><span class="line">        <span class="string">"dbname"</span> =&gt; <span class="string">"invo"</span></span><br><span class="line">    ));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Register a "filter" service in the container</span></span><br><span class="line">$di-&gt;set(<span class="string">'filter'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Filter();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Register a "session" service in the container</span></span><br><span class="line">$di-&gt;set(<span class="string">'session'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Session();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Pass the service container as unique parameter</span></span><br><span class="line">$some = <span class="keyword">new</span> SomeComponent($di);</span><br><span class="line"></span><br><span class="line">$some-&gt;someTask();</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://www.kancloud.cn/baidu/laravel5/30698" target="_blank" rel="noopener">理解PHP 依赖注入|Laravel IoC容器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;控制反转（IoC）与依赖注入（DI）&quot;&gt;&lt;a href=&quot;#控制反转（IoC）与依赖注入（DI）&quot; class=&quot;headerlink&quot; title=&quot;控制反转（IoC）与依赖注入（DI）&quot;&gt;&lt;/a&gt;控制反转（IoC）与依赖注入（DI）&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://gaoshangs.github.io/2018-02-05-design-pattern.html"/>
    <id>https://gaoshangs.github.io/2018-02-05-design-pattern.html</id>
    <published>2018-02-05T11:56:00.000Z</published>
    <updated>2018-02-06T07:17:14.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建性模式"><a href="#创建性模式" class="headerlink" title="创建性模式"></a>创建性模式</h2><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h3><ol><li>要求：只有一个实例，自行创建实例并对外提供这个实例</li><li>实现:<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $conn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::$conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:dbname=testdb;host=127.0.0.1"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="keyword">self</span>::$conn <span class="keyword">instanceof</span> <span class="keyword">self</span>))&#123;</span><br><span class="line">            <span class="keyword">self</span>::$conn = <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//防止对象被复制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        trigger_error(<span class="string">'Clone is not allowed !'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//防止反序列化后创建对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      trigger_error(<span class="string">'Unserialized is not allowed !'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$mysql = Mysql::getInstance();</span><br></pre></td></tr></table></figure></li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li>要求：获取一个实例不通过new关键字获取，都是通过一个工厂类的工厂方法得到这个类的实例</li><li>规则：<ul><li>工厂类必须有一个工厂方法</li><li>工厂类必须能够返回一个业务类实例</li><li>一次只能创建和返回一个实例</li></ul></li><li>实现：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> $name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">driveTo</span><span class="params">($dest)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">driveTo</span><span class="params">($dest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'骑自行车去:'</span>.$dest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">driveTo</span><span class="params">($dest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'开汽车去:'</span>.$dest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line">$factory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">$vehicle = $factory -&gt; create(<span class="string">'Bicycle'</span>);</span><br><span class="line"><span class="keyword">print</span>($vehicle -&gt; driveTo(<span class="string">'北京'</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>接口的应用</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBMysql</span> <span class="keyword">implements</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">__METHOD__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">__METHOD__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">__METHOD__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPdo</span> <span class="keyword">implements</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">__METHOD__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">__METHOD__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">__METHOD__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$database = <span class="keyword">new</span> DBMysql();<span class="comment">//切换数据库只要改这一行就行了，因为后面的都是标准接口方法，不管哪个数据库都一样</span></span><br><span class="line">$database-&gt;connect();</span><br><span class="line">$database-&gt;query();</span><br><span class="line">$database-&gt;close();</span><br></pre></td></tr></table></figure></p><p><strong>问题</strong><br>有的三方接口并没有按照标准接口实现，如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三方数据库类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oracle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">oracleConnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Oracle 的逻辑</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">oracleQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Oracle 的逻辑</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">oracleClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Oracle 的逻辑</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候适配器就派上用场了，用这个适配器将异类的方法转换为接口标准方法<br><strong>适配器模式</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Database</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> $adaptee;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($adaptee)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;adaptee = $adaptee;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//这里把异类的方法转换成了 接口标准方法，下同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;adaptee-&gt;oracleConnect();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;adaptee-&gt;oracleQuery();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;adaptee-&gt;oracleClose();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>应用：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$adaptee = <span class="keyword">new</span> Oracle();  </span><br><span class="line">$adapter = <span class="keyword">new</span> Adapter($adaptee);<span class="comment">//只要改这个类就行了，后面的都可以不用改；</span></span><br><span class="line">$database = $adapter;</span><br><span class="line">$database-&gt;connect();</span><br><span class="line">$database-&gt;query();</span><br><span class="line">$database-&gt;close();</span><br></pre></td></tr></table></figure></p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>解决问题：为某个方法装饰可以自由删除或增加的逻辑(如果遇到)</p><p>场景：比如有一个煮咖啡的程序，默认是纯咖啡，如何方便的选择是否加糖、加奶、加巧克力呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主咖啡程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">plainCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">makeCoffee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;addCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addCoffee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般逻辑：加糖</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sweetCoffee</span> <span class="keyword">extends</span> <span class="title">plainCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">makeCoffee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;addCoffee();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;addSugar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addSugar</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弊端：如果这时候加奶、加巧克力就需要继续继承重写makeCoffee</p><p>装饰器方式：在addCoffee前后增加逻辑处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整煮咖啡程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">plainCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $decorators;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addDecorator</span><span class="params">($decorator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;decorators[] = $decorator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;decorators <span class="keyword">as</span> $decorator)&#123;</span><br><span class="line">            $decorator-&gt;before()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;decorators <span class="keyword">as</span> $decorator)&#123;</span><br><span class="line">            $decorator-&gt;after()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">makeCoffee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;before();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;addCoffee();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addCoffee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写装饰器</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sweetCoffeeDecorator</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;addSugar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addSugar</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：加糖加奶只需要增加装饰器即可，不需要只需注释掉。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$coffee = <span class="keyword">new</span> plainCoffee();</span><br><span class="line">$coffee-&gt;addDecorator(<span class="keyword">new</span> sweetCoffeeDecorator());</span><br><span class="line">$coffee-&gt;addDecorator(<span class="keyword">new</span> milkCoffeeDecorator());</span><br><span class="line">$coffee-&gt;makeCoffee();</span><br></pre></td></tr></table></figure><p>总结：当你extends用过后又遇到需要再次extends的情况时，不妨考虑一下装饰器模式</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>原理</strong>：把一个类不可能更换的部分 和 可更换的部分分离开来，通过注入的方式来使用，从而达到解耦的目的。<br><strong>一个数据库连接类</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库连接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $host;</span><br><span class="line">    <span class="keyword">private</span> $port;</span><br><span class="line">    <span class="keyword">private</span> $username;</span><br><span class="line">    <span class="keyword">private</span> $password;</span><br><span class="line">    <span class="keyword">private</span> $db_name;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;host = <span class="string">'127.0.0.1'</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;port = <span class="number">22</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="string">'root'</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;db_name = <span class="string">'my_db'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mysqli_connect(<span class="keyword">$this</span>-&gt;host,<span class="keyword">$this</span>-&gt;username ,<span class="keyword">$this</span>-&gt;password,<span class="keyword">$this</span>-&gt;db_name,<span class="keyword">$this</span>-&gt;port); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">$db = <span class="keyword">new</span> Mysql();</span><br><span class="line">$con = $db-&gt;connect();</span><br></pre></td></tr></table></figure></p><p><strong>依赖注入</strong>：将可变部分(配置)提取出来抽象为一个类，然后在注入到原类中，这样就完成了配置文件和连接逻辑的分离。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $host;</span><br><span class="line">    <span class="keyword">private</span> $port;</span><br><span class="line">    <span class="keyword">private</span> $username;</span><br><span class="line">    <span class="keyword">private</span> $password;</span><br><span class="line">    <span class="keyword">private</span> $db_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($host, $port, $username, $password, $db_name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;host = $host;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;port = $port;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = $username;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = $password;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;db_name = $db_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsername</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDbName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;db_name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Mysql变更为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $configuration;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(MysqlConfiguration $config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;configuration = $config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mysqli_connect(<span class="keyword">$this</span>-&gt;configuration-&gt;getHost(), <span class="keyword">$this</span>-&gt;configuration-&gt;getUsername(), <span class="keyword">$this</span>-&gt;configuration-&gt;getPassword, <span class="keyword">$this</span>-&gt;configuration-&gt;getDbName(), <span class="keyword">$this</span>-&gt;configuration-&gt;getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用</strong>：$config是注入Mysql的，这就是所谓的依赖注入。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$config = <span class="keyword">new</span> MysqlConfiguration(<span class="string">'127.0.0.1'</span>,<span class="string">'root'</span>,<span class="string">''</span>,<span class="string">'my_db'</span>,<span class="number">22</span>);</span><br><span class="line">$db = <span class="keyword">new</span> Mysql($config);</span><br><span class="line">$con = $db-&gt;connect();</span><br></pre></td></tr></table></figure></p><h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name;</span><br><span class="line">    <span class="keyword">public</span> $surName; </span><br><span class="line">    <span class="keyword">public</span> $salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSurname</span><span class="params">($surname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;surName = $surname;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSalary</span><span class="params">($salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;salary = $salary;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $employeeInfo = <span class="string">'Name: '</span> . <span class="keyword">$this</span>-&gt;name . PHP_EOL;</span><br><span class="line">        $employeeInfo .= <span class="string">'Surname: '</span> . <span class="keyword">$this</span>-&gt;surName . PHP_EOL;</span><br><span class="line">        $employeeInfo .= <span class="string">'Salary: '</span> . <span class="keyword">$this</span>-&gt;salary . PHP_EOL;</span><br><span class="line">        <span class="keyword">return</span> $employeeInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链式操作的效果</span></span><br><span class="line">$employee = (<span class="keyword">new</span> Employee())</span><br><span class="line">                -&gt;setName(<span class="string">'Tom'</span>)</span><br><span class="line">                -&gt;setSurname(<span class="string">'Smith'</span>)</span><br><span class="line">                -&gt;setSalary(<span class="string">'100'</span>);</span><br><span class="line"><span class="keyword">echo</span> $employee;</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># Name: Tom</span></span><br><span class="line"><span class="comment"># Surname: Smith</span></span><br><span class="line"><span class="comment"># Salary: 100</span></span><br></pre></td></tr></table></figure><h2 id="行为性模式"><a href="#行为性模式" class="headerlink" title="行为性模式"></a>行为性模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>需求</strong>：有一个listener和handler，当listener监听到一个事件发生，多个handler自动处理对应的逻辑<br><strong>原理</strong>：</p><ul><li>声明抽象事件发生者类(EventGenerator)，负责添加观察者和逐一调用观察者的update方法进行通知。</li><li>声明观察者接口类(Observer)，提供抽象方法update，所有的观察者都实现这个接口</li><li>具体的事件继承EventGenerator类，然后调用addObserver添加观察者，调用trigger进行触发。</li></ul><p><strong>实现</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个抽象的事件发生者基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventGenerator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $observers = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">//添加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addobserver</span><span class="params">(Observer $observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;observers[] = $observer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个添加的观察者进行事件通知</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//对每个观察者逐个去更新</span></span><br><span class="line">       <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;observers <span class="keyword">as</span> $observer)</span><br><span class="line">       &#123;</span><br><span class="line">         $observer-&gt;update();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明一个观察者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">observer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($event_info = null)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明具体事件类，继承了主事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> <span class="keyword">extends</span> <span class="title">EventGenerator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">trigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">"Event&lt;br/&gt;"</span>;</span><br><span class="line">      <span class="keyword">$this</span>-&gt;notify();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明多个观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($event_info = null)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">"逻辑1&lt;br/&gt;"</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($event_info = null)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">"逻辑2&lt;br/&gt;"</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>应用</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Event基类里的foreach，可以实现一个事件对应多个观察者</span></span><br><span class="line">$event = <span class="keyword">new</span> Event;</span><br><span class="line">$event-&gt;addObserver(<span class="keyword">new</span> Observer1);</span><br><span class="line">$event-&gt;addObserver(<span class="keyword">new</span> Observer2);</span><br><span class="line">$event-&gt;trigger();</span><br></pre></td></tr></table></figure></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>需求</strong> ：针对大量ifelse判断上下文的环境所作出的策略。<br><strong>原理</strong>：提供一个策略接口(Strategy)，其中定义待实现方法，其他策略实现这个接口，业务逻辑中只调用接口中定义的方法。<br><strong>举例</strong>：商城的首页，男的进来看男性商品，女的进来看女性商品，不男不女…以此类推，各种条件下用不同策略展示不同商品<br><strong>实现</strong>:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//showStrategy.php 展示策略接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">showStrategy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showCategory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maleShowStrategy.php 男性用户展示策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maleShowStrategy</span> <span class="keyword">implements</span> <span class="title">showStrategy</span> </span>&#123; <span class="comment">// 具体策略A </span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showCategory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'展示男性商品目录'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//femaleShowStrategy.php 女性用户展示策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">femaleShowStrategy</span> <span class="keyword">implements</span> <span class="title">showStrategy</span> </span>&#123; <span class="comment">// 具体策略B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showCategory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'展示女性商品目录'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//page.php 展示页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> $_strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Strategy $strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_strategy = $strategy;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_strategy-&gt;showCategory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'male'</span>]))&#123;</span><br><span class="line">    $strategy = <span class="keyword">new</span> maleShowStrategy();</span><br><span class="line">&#125;<span class="keyword">elseif</span>(<span class="keyword">isset</span>($_GET[<span class="string">'female'</span>]))&#123;</span><br><span class="line">    $strategy = <span class="keyword">new</span> femaleShowStrategy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意看这里上下，Page类不再依赖一种具体的策略，而是只需要绑定一个抽象的接口，这就是传说中的控制反转（IOC）。</span></span><br><span class="line">$question = <span class="keyword">new</span> Page($strategy);</span><br><span class="line">$question-&gt;showPage();</span><br></pre></td></tr></table></figure></p><p><strong>总结</strong><br>仔细看上面的例子，不复杂，我们发现有2个好处：</p><p>它把if else 抽离出来了，不需要在每个类里都写if else；<br>它成功的实现了控制反转，Page类里没有具体的依赖策略，这样我们就可以随时添加和删除 不同的策略。</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>这是最常见的设计模式之一，其实质就是父类提供一系列模板方法，有的实现了逻辑，有的只是一个接口。而子类继承大部分共有方法，同时对接口方法进行不同的实现，从而完成对父类模板的个性化改造，起到一对多的解耦目的。</p><p>可以说PHP的抽象类就是为了实现这个设计模式而推出的功能，在PHP中，抽象类本身就是模板方法模式。<br><strong>应用</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Journey.php 模板类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Journey</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $thingsToDo = [];</span><br><span class="line">    <span class="comment">//final关键字的作用是不让这个方法被子类覆盖</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">takeATrip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;thingsToDo[] = <span class="keyword">$this</span>-&gt;buyAFlight();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;thingsToDo[] = <span class="keyword">$this</span>-&gt;takePlane();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;thingsToDo[] = <span class="keyword">$this</span>-&gt;enjoyVacation();</span><br><span class="line">        $buyGift = <span class="keyword">$this</span>-&gt;buyGift();</span><br><span class="line">        <span class="keyword">if</span> ($buyGift !== <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;thingsToDo[] = $buyGift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;thingsToDo[] = <span class="keyword">$this</span>-&gt;takePlane();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//子类必须实现的抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">enjoyVacation</span><span class="params">()</span>: <span class="title">string</span></span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buyGift</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">buyAFlight</span><span class="params">()</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Buy a flight ticket'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">takePlane</span><span class="params">()</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Taking the plane'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把所有旅行中干过的事情列出来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getThingsToDo</span><span class="params">()</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;thingsToDo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BeachJourney.php子类一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeachJourney</span> <span class="keyword">extends</span> <span class="title">Journey</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">enjoyVacation</span><span class="params">()</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Swimming and sun-bathing"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BeachJourney.php子类二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CityJourney</span> <span class="keyword">extends</span> <span class="title">Journey</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">enjoyVacation</span><span class="params">()</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Eat, drink, take photos and sleep"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//覆盖父类已有方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buyGift</span><span class="params">()</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Buy a gift"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://www.cnblogs.com/siqi/archive/2012/09/09/2667562.html" target="_blank" rel="noopener">四种常见设计模式</a></li><li><a href="http://larabase.com/collection/5/post/143" target="_blank" rel="noopener">PHP 经典设计模式 </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建性模式&quot;&gt;&lt;a href=&quot;#创建性模式&quot; class=&quot;headerlink&quot; title=&quot;创建性模式&quot;&gt;&lt;/a&gt;创建性模式&lt;/h2&gt;&lt;h3 id=&quot;单例模式-Singleton&quot;&gt;&lt;a href=&quot;#单例模式-Singleton&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://gaoshangs.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux网络编程</title>
    <link href="https://gaoshangs.github.io/2018-02-05-linux-network-program.html"/>
    <id>https://gaoshangs.github.io/2018-02-05-linux-network-program.html</id>
    <published>2018-02-05T11:53:00.000Z</published>
    <updated>2018-02-06T00:54:41.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select-poll和epoll的区别"><a href="#select-poll和epoll的区别" class="headerlink" title="select, poll和epoll的区别"></a>select, poll和epoll的区别</h2><ol><li>什么是多路I/O复用（Epoll）<br>（1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理<br>（2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件<br>（3） 为了提升服务器线程处理效率，有以下三种思路</li></ol><p>（1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转</p><p>（2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N）</p><p>（3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1)</p><ol><li>其它开源软件采用的模型</li></ol><p>Nginx：多进程单线程模型<br>Memcached：单进程多线程模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;select-poll和epoll的区别&quot;&gt;&lt;a href=&quot;#select-poll和epoll的区别&quot; class=&quot;headerlink&quot; title=&quot;select, poll和epoll的区别&quot;&gt;&lt;/a&gt;select, poll和epoll的区别&lt;/h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL知识点</title>
    <link href="https://gaoshangs.github.io/2018-02-05-mysql.html"/>
    <id>https://gaoshangs.github.io/2018-02-05-mysql.html</id>
    <published>2018-02-05T11:53:00.000Z</published>
    <updated>2018-02-08T10:39:02.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><h3 id="1-第一范式-确保每列保持原子性"><a href="#1-第一范式-确保每列保持原子性" class="headerlink" title="1. 第一范式(确保每列保持原子性)"></a>1. 第一范式(确保每列保持原子性)</h3><blockquote><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式</p></blockquote><p>第一范式需要按照系统的实际需求来定。比如一般”地址”这个属性都是一个字段就可以了，但是如果系统经常访问城市，那就可以对地址进行拆分，<br>这样在对地址进行查询的时候就比较的方便。<br><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114023352.png" alt="用户信息表"></p><blockquote><p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能</p></blockquote><h3 id="2-第二范式-确保表中的每列都和主键相关"><a href="#2-第二范式-确保表中的每列都和主键相关" class="headerlink" title="2. 第二范式(确保表中的每列都和主键相关)"></a>2. 第二范式(确保表中的每列都和主键相关)</h3><blockquote><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。<br><strong>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中</strong></p></blockquote><p>如图：订单信息表：一个订单中可能有多个商品，所以将订单号和商品编号作为联合主键。<br><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114063976.png" alt="订单信息表"><br>上图中商品名称、单位、价格只与商品有关于订单号无关，所以是不满足第二范式的。这时候应该把商品信息拆分为单独的表，如下：<br><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114082156.png" alt="订单商品拆分后的结果"></p><h3 id="3-第三范式-确保每列都和主键列直接相关-而不是间接相关"><a href="#3-第三范式-确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="3. 第三范式(确保每列都和主键列直接相关,而不是间接相关)"></a>3. 第三范式(确保每列都和主键列直接相关,而不是间接相关)</h3><blockquote><p>满足第三范式（3NF）必须先满足第二范式（2NF）。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p></blockquote><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息<br><img src="https://pic002.cnblogs.com/images/2012/270324/2012040114105477.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html" target="_blank" rel="noopener">数据库设计三大范式</a></p><h2 id="mysql创建索引原则"><a href="#mysql创建索引原则" class="headerlink" title="mysql创建索引原则"></a>mysql创建索引原则</h2><ul><li>较频繁的作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合创建索引</li><li>不会出现在WHERE子句中的字段不该创建索引</li></ul><h2 id="数据库优化的思路"><a href="#数据库优化的思路" class="headerlink" title="数据库优化的思路"></a>数据库优化的思路</h2><h3 id="1-SQL语句优化"><a href="#1-SQL语句优化" class="headerlink" title="1. SQL语句优化"></a>1. SQL语句优化</h3><ul><li>避免select *</li><li>字段尽可能的使用 NOT NULL</li><li>尽量避免在 !=或&lt;&gt;和not in操作符,避免全表扫描</li><li>where 及 order by 涉及的列上建立索引</li><li>尽量少使用join查询 </li></ul><h3 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h3><p>合理增加索引，查看 <a href="#mysql创建索引原则">mysql创建索引原则</a></p><h3 id="3-数据库结构优化"><a href="#3-数据库结构优化" class="headerlink" title="3. 数据库结构优化"></a>3. 数据库结构优化</h3><ul><li>范式优化：消除冗余（节省空间）</li><li>反范式优化:比如适当加冗余等（减少join)</li><li>表的垂直拆分和水平拆分</li></ul><h3 id="4-服务器硬件优化"><a href="#4-服务器硬件优化" class="headerlink" title="4. 服务器硬件优化"></a>4. 服务器硬件优化</h3><ul><li>提升服务器硬件配置</li></ul><h3 id="5-缓存机制"><a href="#5-缓存机制" class="headerlink" title="5. 缓存机制"></a>5. 缓存机制</h3><ul><li>添加缓存机制，使用(redis,memcache)</li><li>不经常改动的使用静态页面</li></ul><h2 id="表的垂直拆分和水平拆分"><a href="#表的垂直拆分和水平拆分" class="headerlink" title="表的垂直拆分和水平拆分"></a>表的垂直拆分和水平拆分</h2><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><blockquote><p>垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表</p></blockquote><p><img src="http://images0.cnblogs.com/blog2015/487276/201505/191926445106317.png" alt="垂直拆分"></p><p><strong>原则</strong></p><ul><li>把不常用的字段单独放在一张表;</li><li>把text，blob等大字段拆分出来放在附表中;</li><li>经常组合查询的列放在一张表中;<br>ps:<br>垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关键起来即可;</li></ul><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><blockquote><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放.<br><img src="http://images0.cnblogs.com/blog2015/487276/201505/191937431352964.png" alt="水平拆分"></p></blockquote><p><strong>拆分原则</strong><br>通常使用取模的方式来进行表的拆分</p><p><strong>应用</strong><br>比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4<br>通过用ID取模的方法把数据分散到四张表内<code>Id%4+1 = [1,2,3,4]</code><br>插入：在insert时还需要一张临时表uid_temp来提供自增的ID,该表的唯一用处就是提供自增的ID;得到自增的ID后,又通过取模法进行分表插入<br>然后查询,更新,删除也是通过取模的方法来查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_GET</span>[<span class="string">'id'</span>] = 17,</span><br><span class="line">17%4 + 1 = 2,  </span><br><span class="line"><span class="variable">$tableName</span> = <span class="string">'users'</span>.<span class="string">'2'</span></span><br><span class="line">Select * from users2 <span class="built_in">where</span> id = 17;</span><br></pre></td></tr></table></figure></p><p>注意:进行水平拆分后的表,字段的列和类型和原表应该是相同的,但是要记得去掉auto_increment自增长</p><h2 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h2><ul><li>delete和truncate只删除表的数据不删除表的结构, trucate删除表数据自增id从1开始，delete删除可加where语句</li><li>速度,一般来说: drop&gt; truncate &gt;delete </li><li>delete语句是dml,这个操作会放到rollback中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. </li><li>truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. </li></ul><h2 id="数据库事务的四个特性及含义"><a href="#数据库事务的四个特性及含义" class="headerlink" title="数据库事务的四个特性及含义"></a>数据库事务的四个特性及含义</h2><blockquote><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p></blockquote><ul><li>原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li><li>隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。</li><li>持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><h2 id="查找慢SQL查询"><a href="#查找慢SQL查询" class="headerlink" title="查找慢SQL查询"></a>查找慢SQL查询</h2><h3 id="开启慢查询配置"><a href="#开启慢查询配置" class="headerlink" title="开启慢查询配置"></a>开启慢查询配置</h3><ul><li><p>slow_query_log    </p><p>这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。</p></li><li><p>long_query_time</p><p>当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。</p></li><li><p>slow_query_log_file</p><p>记录日志的文件名</p></li><li><p>log_queries_not_using_indexes</p><p>这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。</p></li></ul><h3 id="检测执行效率"><a href="#检测执行效率" class="headerlink" title="检测执行效率"></a>检测执行效率</h3><h4 id="1-查看慢查询日志"><a href="#1-查看慢查询日志" class="headerlink" title="1. 查看慢查询日志"></a>1. 查看慢查询日志</h4><p>查看slow_query_log_file配置的文件</p><h4 id="2-show-processlist-命令"><a href="#2-show-processlist-命令" class="headerlink" title="2. show processlist 命令"></a>2. show processlist 命令</h4><blockquote><p>SHOW PROCESSLIST显示哪些线程正在运行</p></blockquote><p><strong>各列的含义和用途</strong></p><p><strong>ID列</strong>：一个标识，你要kill一个语句的时候很有用，用命令杀掉此查询 <code>mysqladmin kill</code> 进程号。</p><p>user列：显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句。</p><p>host列：显示这个语句是从哪个ip的哪个端口上发出的。用于追踪出问题语句的用户。</p><p><strong>db列</strong>：显示这个进程目前连接的是哪个数据库。</p><p><strong>command列</strong>：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）。</p><p><strong>time列</strong>：此这个状态持续的时间，单位是秒。</p><p><strong>state列</strong>：显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个 sql语句，以查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成</p><p>info列：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据</p><h4 id="3-explain来了解SQL执行的状态"><a href="#3-explain来了解SQL执行的状态" class="headerlink" title="3. explain来了解SQL执行的状态"></a><strong>3. explain来了解SQL执行的状态</strong></h4><blockquote><p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句</p></blockquote><p><strong>3.1 用法</strong></p><blockquote><p> 在select语句前加上explain就可以了</p></blockquote><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> info <span class="keyword">where</span> uid = <span class="number">1234</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>\G;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: info</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: uid</span><br><span class="line">          key: uid</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 18</span><br><span class="line">        Extra: Using index condition; Using where; Using filesort</span><br></pre></td></tr></table></figure><p><strong>3.2 列含义</strong></p><p>table: 显示这一行的数据是关于哪张表的</p><p><strong>select_type</strong>: 表示 SELECT 的 类型，常见的取值有 SIMPLE （简单表，即不使用表连接或者子查询）、 PRIMARY （主查询，即外层的查询）、 UNION （ UNION 中的第二个或者后面的查询语句）、 SUBQUERY （子查询中的第一个 SELECT ）等</p><p><strong>type</strong> : <strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL</strong></p><blockquote><p> 表示表的连接类型，性能由好到差的连接类型为 system （表中仅有一行，即常量表）、 const （单表中最多有一个匹配行，例如 primary key 或者 unique index ）、 eq_ref （对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index ）、 ref （与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index ，而是使用普通的索引）、 ref_or_null （ 与 ref 类似，区别在于条件中包含对 NULL 的查询 ） 、 index_merge ( 索引合并优化 ) 、 unique_subquery （ in 的后面是一个查询主键字段的子查询）、 index_subquery （ 与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、 range （单表中的范围查询）、 index （对于前面的每一行，都通过查询索引来得到数据）、 all （对于前面的每一行，都通过全表扫描来得到数据）</p></blockquote><p><strong>possible_keys</strong>: 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p><strong>key</strong>: <strong>实际使用的索引</strong>。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句 中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p><p><strong>key_len</strong>: 使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>ref: 显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows</strong>: MYSQL认为必须检查的用来返回请求数据的行数</p><p>extra: 执行情况的说明和描述</p><p>参考:<br><a href="https://www.cnblogs.com/frankielf0921/p/5930743.html" target="_blank" rel="noopener">MySQL常见面试题</a><br><a href="http://www.cnblogs.com/datang6777/p/6888659.html" target="_blank" rel="noopener">MySQL性能优化总结</a><br><a href="https://www.jianshu.com/p/52843a98acda" target="_blank" rel="noopener">MySQL分区表详解</a><br><a href="https://zhuanlan.zhihu.com/p/23713529" target="_blank" rel="noopener">常见面试题整理–数据库篇（每位开发者必备）</a><br><a href="https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39326" target="_blank" rel="noopener">表的垂直拆分和水平拆分</a><br><a href="http://www.cnblogs.com/T8881/p/5940000.html" target="_blank" rel="noopener">如何查找MySQL中查询慢的SQL语句</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库三大范式&quot;&gt;&lt;a href=&quot;#数据库三大范式&quot; class=&quot;headerlink&quot; title=&quot;数据库三大范式&quot;&gt;&lt;/a&gt;数据库三大范式&lt;/h2&gt;&lt;h3 id=&quot;1-第一范式-确保每列保持原子性&quot;&gt;&lt;a href=&quot;#1-第一范式-确保每列保持原子性&quot;
      
    
    </summary>
    
    
      <category term="面试" scheme="https://gaoshangs.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="mysql" scheme="https://gaoshangs.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>常见算法</title>
    <link href="https://gaoshangs.github.io/2018-02-05-algorithm-php.html"/>
    <id>https://gaoshangs.github.io/2018-02-05-algorithm-php.html</id>
    <published>2018-02-05T10:26:00.000Z</published>
    <updated>2018-02-23T07:06:45.015Z</updated>
    
    <content type="html"><![CDATA[<p>文章参考：<a href="https://github.com/todayqq/PHPerInterviewGuide/blob/master/algorithm.md" target="_blank" rel="noopener">todayqq/PHPerInterviewGuide</a></p><h2 id="常用的排序算法的时间复杂度和空间复杂度"><a href="#常用的排序算法的时间复杂度和空间复杂度" class="headerlink" title="常用的排序算法的时间复杂度和空间复杂度"></a>常用的排序算法的时间复杂度和空间复杂度</h2><table><thead><tr><th>排序法</th><th>最差时间分析</th><th>平均时间复杂度</th><th>稳定度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>稳定</td><td>O(1)</td></tr><tr><td>快速排序</td><td>O(n^2)</td><td>O(n*logn)</td><td>不稳定</td><td>O(logn)~O(n)</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>稳定</td><td>O(1)</td></tr><tr><td>二叉树排序</td><td>O(n^2)</td><td>O(n*logn)</td><td>不一顶</td><td>O(n)</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>稳定</td><td>O(1)</td></tr><tr><td>堆排序</td><td>O(n*logn)</td><td>O(n*logn)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>希尔排序</td><td>O</td><td>O</td><td>不稳定</td><td>O(1)</td></tr></tbody></table><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>插入排序和冒泡排序在平均和最坏情况下的时间复杂度都是O(n^2)，最好情况下都是O(n)，空间复杂度是O(1)</p><ul><li>原理:比较相邻两个元素,如果前一个元素大于后一个元素则向后移,然后跟后边元素依次比较直到最大值冒泡到最后一个元素</li><li>结论:假设数组长度为n,则共经过N=n-1轮排序,每轮进行N-i次比较,我们可以使用双层循环语句,外层循环控制轮次,内层循环控制比较次数</li></ul></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_sort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i &lt; $count<span class="number">-1</span>; $i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>($j=<span class="number">0</span>; $j &lt; $count<span class="number">-1</span>-$i; $j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>($arr[$j] &gt; $arr[$j+<span class="number">1</span>]) &#123;<span class="comment">//倒序排只需把大于号换成小于号即可</span></span><br><span class="line">                $temp = $arr[$j];</span><br><span class="line">                $arr[$j] = $arr[$j+<span class="number">1</span>];</span><br><span class="line">                $arr[$j+<span class="number">1</span>] = $temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line">print_r(bubble_sort([<span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>]));</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; 1</span><br><span class="line">    [1] =&gt; 2</span><br><span class="line">    [2] =&gt; 2</span><br><span class="line">    [3] =&gt; 3</span><br><span class="line">    [4] =&gt; 6</span><br><span class="line">    [5] =&gt; 8</span><br><span class="line">    [6] =&gt; 9</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参考:  <a href="https://www.cnblogs.com/wgq123/p/6529450.html" target="_blank" rel="noopener">PHP 冒泡排序</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是对冒泡排序的一种改进，不稳定，平均时间复杂度：O(nlogn)</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>原理: 选择一个基准数(一般为第一个元素),新建两个空数组,遍历整个数组元素,如果数组元素比基准数小,则放到left数组,如果大于基准数则放到right数组,然后在对新数组递归进行相同的操作</li><li>基准数: 第一个元素</li><li>递归点: 新构造的数组个数大于1则继续进行拆分排序</li><li>递归出口: 数组个数小于等于1或非数组</li></ul></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    <span class="keyword">if</span>($count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    &#125;</span><br><span class="line">    $base = $arr[<span class="number">0</span>];</span><br><span class="line">    $left = $right = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">1</span>; $i &lt; $count; $i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>($arr[$i] &lt; $base) &#123; <span class="comment">//倒序排只需把符号换成大于号即可</span></span><br><span class="line">            $left[] = $arr[$i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $right[] = $arr[$i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $left = quick_sort($left);</span><br><span class="line">    $right = quick_sort($right);</span><br><span class="line">    <span class="keyword">return</span> array_merge($left, <span class="keyword">array</span>($base), $right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = [<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">print_r(quick_sort($arr));</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; 1</span><br><span class="line">    [1] =&gt; 2</span><br><span class="line">    [2] =&gt; 3</span><br><span class="line">    [3] =&gt; 4</span><br><span class="line">    [4] =&gt; 4</span><br><span class="line">    [5] =&gt; 5</span><br><span class="line">    [6] =&gt; 6</span><br><span class="line">    [7] =&gt; 6</span><br><span class="line">    [8] =&gt; 8</span><br><span class="line">    [9] =&gt; 9</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参考： <a href="https://www.cnblogs.com/wangjingwangjing/p/5241486.html" target="_blank" rel="noopener">php实现快速排序</a></p><h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><h4 id="最优情况"><a href="#最优情况" class="headerlink" title="最优情况"></a>最优情况</h4><blockquote><p>在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，我们就有了下面的不等式推断<br>推导如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T（n）≤2T（n/2） +n，T（1）=0  </span><br><span class="line">T（n）≤2（2T（n/4）+n/2） +n=4T（n/4）+2n  </span><br><span class="line">T（n）≤4（2T（n/8）+n/4） +2n=8T（n/8）+3n  </span><br><span class="line">……  </span><br><span class="line">T（n）≤nT（1）+（log2n）×n= O(nlogn)</span><br></pre></td></tr></table></figure></p></blockquote><p>在最优的情况下，快速排序算法的时间复杂度为O(nlogn).</p><h4 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h4><p>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录<br>也就是枢轴的位置，因此比较次数为<img src="http://images.51cto.com/files/uploadimg/20110826/222653304.jpg" alt=""> ，最终其时间复杂度为O(n^2)。</p><h4 id="平均情况"><a href="#平均情况" class="headerlink" title="平均情况"></a>平均情况</h4><p>平均的情况，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：<br><img src="http://images.51cto.com/files/uploadimg/20110826/222801489.jpg" alt=""><br>由数学归纳法可证明，其数量级为O(nlogn)。</p><p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为log2n，其空间复杂度也就为<strong>O(logn)</strong>，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为<strong>O(logn)</strong>。<br>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p><p>参考：<a href="http://book.51cto.com/art/201108/287089.htm" target="_blank" rel="noopener">9.9.2 快速排序复杂度分析</a></p><h2 id="二分查找（折半查找）"><a href="#二分查找（折半查找）" class="headerlink" title="二分查找（折半查找）"></a>二分查找（折半查找）</h2><blockquote><p>时间复杂度：O(log2n)以2为底n的对数</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>需求: 提供一个有序数组和一个目标数字,找出该数字在有序数组中的位置</li><li>原理：</li></ul><ol><li>知道起始位置和结束位置(默认为数组起点和终点索引值), 取数组中间位置数字与目标数字比较. </li><li>如果目标值小于中间值,则目标值在中间位置之前,此时再次二分，起始位置不变,结束位置变更为中间位置-1.</li><li>如果中间值小于目标值,则目标值在中间位置之后,此时再次二分，起始位置为中间位置+1,结束位置不变.</li><li>如果中间值等于目标值则返回中间位置</li></ol></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary_search</span><span class="params">($target, $arr)</span> </span>&#123;</span><br><span class="line">    $low = <span class="number">0</span>;</span><br><span class="line">    $high = count($arr) <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>($low &lt;= $high) &#123; <span class="comment">//&lt;=兼容target = 1情况</span></span><br><span class="line">        $mid = floor(($low+$high) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//var_dump($low.'_'.$high.'_'.$mid);//打印比较过程</span></span><br><span class="line">        <span class="keyword">if</span>($target &lt; $arr[$mid]) &#123;</span><br><span class="line">            $high = $mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>($target &gt; $arr[$mid]) &#123;</span><br><span class="line">            $low = $mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>($target == $arr[$mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> $mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//var_dump($low.'_'.$high.'_'.$mid);//打印比较过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">$target = <span class="number">7</span>;<span class="comment">//分别测试target=1,2,7</span></span><br><span class="line">$arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>];<span class="comment">//共9个数字</span></span><br><span class="line">var_dump($target);</span><br><span class="line">print_r($arr);</span><br><span class="line">$ret = binary_search($target, $arr);</span><br><span class="line">var_dump($ret);</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int(7)</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; 1</span><br><span class="line">    [1] =&gt; 2</span><br><span class="line">    [2] =&gt; 3</span><br><span class="line">    [3] =&gt; 6</span><br><span class="line">    [4] =&gt; 8</span><br><span class="line">    [5] =&gt; 9</span><br><span class="line">    [6] =&gt; 10</span><br><span class="line">    [7] =&gt; 13</span><br><span class="line">    [8] =&gt; 14</span><br><span class="line">)</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://www.cnblogs.com/wangjingwangjing/p/5206711.html" target="_blank" rel="noopener">php实现二分查找法</a></p><h3 id="二分查找时间复杂度计算方法"><a href="#二分查找时间复杂度计算方法" class="headerlink" title="二分查找时间复杂度计算方法"></a>二分查找时间复杂度计算方法</h3><p>二分查找原理：有目标元素t和长度为n的有序数组a，查找t在a中的位置。首先取中间元素c = a[n/2]与t比较。<br>如果t和c相等则返回，如果t比c小，则从左侧部分继续取中间元素c，否则从右侧部分取中间元素进行比较，依次循环。<br>所以时间复杂度的计算就是循环次数的计算，如下推导：</p><table><thead><tr><th>次数</th><th>剩余操作元素数目</th></tr></thead><tbody><tr><td>1</td><td>n</td></tr><tr><td>2</td><td>n/2</td></tr><tr><td>3</td><td>n/4</td></tr><tr><td>4</td><td>n/8</td></tr><tr><td>..</td><td>….</td></tr><tr><td>k</td><td>n/(2^(k-1))</td></tr></tbody></table><p>最终剩余操作元素数目为n/(2^(k-1)) &gt;=1，去除常数计算即：2^k = n,复杂度为O(log2n)以2为底n的对数</p><h2 id="Twitter-Snowflake"><a href="#Twitter-Snowflake" class="headerlink" title="Twitter Snowflake"></a>Twitter Snowflake</h2><p><strong>核心思想</strong><br>snowflake是twitter开源的分布式ID生成算法，其核心思想是：<br>产生一个long型(64bit)的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。<br>这个算法单机每秒内理论上最多可以生成1000*(2^12)个，也就是大约400W的ID，完全能满足业务的需求。</p><p><strong>实现</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 41 bits: Timestamp | 3 bits: 区域 | 10 bits: 机器编号 | 10 bits: 序列号 |</span><br><span class="line"><span class="built_in">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (paddingnum &lt;&lt; regionIdShift) | (workerId &lt;&lt; workerIdShift) | sequence;</span><br></pre></td></tr></table></figure><ul><li>毫秒数计算：需要选择某一天的毫秒级时间戳为基准时间戳，然后用当前时间戳与基准时间戳相减</li><li>序列号计算：同一毫秒内序列号自增，超过最大值则溢出等待下一毫秒</li><li>最后分别对Timestamp、区域、机器编号、序列号分别向左做相对应的位运算，然后进行与操作得到最终的唯一id<br><strong>注意</strong></li><li>需要控制好所有服务器的时间，使用统一的ntp时间服务器，否则生成的id无法保持增长趋势</li><li>这个id可用的时间大概是：2^41/1000/3600/24/365 ≈ 79年</li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.cnblogs.com/hellohell/p/5718175.html" target="_blank" rel="noopener">PHP实现各种经典算法</a></li><li><a href="http://www.cnblogs.com/zswordsman/p/5824599.html" target="_blank" rel="noopener">PHP常见算法-面试篇</a></li><li><a href="https://segmentfault.com/a/1190000009067353" target="_blank" rel="noopener">常用算法PHP版</a></li><li><a href="https://www.jianshu.com/p/61817cf48cc3" target="_blank" rel="noopener">全局唯一ID设计</a></li><li><a href="http://blog.csdn.net/wuxinyicomeon/article/details/5996675/" target="_blank" rel="noopener">常用的排序算法的时间复杂度和空间复杂度</a></li><li><a href="http://blog.csdn.net/frances_han/article/details/6458067" target="_blank" rel="noopener">二分查找时间复杂度的计算</a></li><li><a href="http://book.51cto.com/art/201108/287089.htm" target="_blank" rel="noopener">9.9.2 快速排序复杂度分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章参考：&lt;a href=&quot;https://github.com/todayqq/PHPerInterviewGuide/blob/master/algorithm.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;todayqq/PHPerInterv
      
    
    </summary>
    
      <category term="软技能" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
      <category term="面试" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://gaoshangs.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP知识点</title>
    <link href="https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html"/>
    <id>https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html</id>
    <published>2018-01-31T02:42:00.000Z</published>
    <updated>2018-02-06T00:54:41.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 </p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 </p><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。</p><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul><li>CLOSED: 这个没什么好说的了，表示初始状态。</li><li>LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</li><li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li><li>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</li><li>ESTABLISHED：这个容易理解了，表示连接已经建立了。</li><li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</li><li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li><li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li><li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li><li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</li><li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#1-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h3><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p><ul><li>TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。</li><li>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。<br>失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。<br>考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 </li><li>采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</li></ul><h3 id="2-为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？"><a href="#2-为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？"></a>2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；<br>但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，<br>所以关闭连接时的ACK报文和FIN报文多数情况下都是分开发送的。 </p><h3 id="3-什么是2MSL？"><a href="#3-什么是2MSL？" class="headerlink" title="3. 什么是2MSL？"></a>3. 什么是2MSL？</h3><p>2MSL(maximum segment lifetime)</p><ul><li>等待一段时间，防止最后的FIN的ACK包丢失，对方未收到ACK会重发FIN</li><li>TCP连接在2MSL时间内 ip,port不能重新被bind</li></ul><h3 id="4-为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？"><a href="#4-为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？" class="headerlink" title="4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？"></a>4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</h3><p>虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）。<br>但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/hyqwmxsh/article/details/52437499" target="_blank" rel="noopener">面试笔试–TCP/IP知识点</a><br><a href="http://blog.csdn.net/i10630226/article/details/54880363" target="_blank" rel="noopener">HTTP/TCP常见面试问题总结</a></p>]]></content>
    
    <summary type="html">
    
      TCP/IP常见知识点汇总
    
    </summary>
    
      <category term="技术支撑" scheme="https://gaoshangs.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91/"/>
    
      <category term="网络工程" scheme="https://gaoshangs.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="TCP/IP" scheme="https://gaoshangs.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://gaoshangs.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>C语言指针</title>
    <link href="https://gaoshangs.github.io/2018-01-16-c-pointer-define.html"/>
    <id>https://gaoshangs.github.io/2018-01-16-c-pointer-define.html</id>
    <published>2018-01-16T13:24:00.000Z</published>
    <updated>2018-01-16T13:30:42.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-指针的定义方式："><a href="#1-指针的定义方式：" class="headerlink" title="1. 指针的定义方式："></a>1. 指针的定义方式：</h2><p>示例一：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure></p><p>说明：p为指针变量，int <em>p 中的</em>为类型说明符，声明p的类型为指针变量类型。指针变量必须是指向内存地址（内存指针），&amp;符为取地址运算符。<br>示例二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p>说明：先声明一个指针变量，然后对这个指针变量进行赋值。</p><h2 id="2-指针变量的使用"><a href="#2-指针变量的使用" class="headerlink" title="2. 指针变量的使用"></a>2. 指针变量的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d"</span>, *p);</span><br></pre></td></tr></table></figure><p>说明：这里的printf(“ <em>p = %d“, </em>p);中的<em>与上边声明指针变量的int </em>p的含义是不同的，这里的*为指针运算符，不是类型说明符。</p><pre><code class="C"><span class="built_in">printf</span>(<span class="string">"*&amp;a  = %d"</span>, *&amp;a); <span class="comment">//运行结果为a本身</span></code></pre><blockquote><p>由于*和&amp;的优先级相同，所以会先进行&amp;a进行取a的内存地址，然后在通过*指针运算符，指向a的内存地址并返回这块内存单元存放的数据。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>int *p 声明指针变量的* 为类型说明符，他的性质和int long的作用相似，都是说明变量的类型。</li><li>*p 获取指针变量的<em>为指针运算符，和&amp;的类型都是一样的就是参与运算的，只是&amp;获取的是内存的地址，</em>获取的是内存地址为该指针变量上存储的数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-指针的定义方式：&quot;&gt;&lt;a href=&quot;#1-指针的定义方式：&quot; class=&quot;headerlink&quot; title=&quot;1. 指针的定义方式：&quot;&gt;&lt;/a&gt;1. 指针的定义方式：&lt;/h2&gt;&lt;p&gt;示例一：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://gaoshangs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C" scheme="https://gaoshangs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
      <category term="指针" scheme="https://gaoshangs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%8C%87%E9%92%88/"/>
    
    
      <category term="C语言" scheme="https://gaoshangs.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="https://gaoshangs.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
