<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高尚的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gaoshangs.github.io/"/>
  <updated>2018-01-31T03:23:52.453Z</updated>
  <id>https://gaoshangs.github.io/</id>
  
  <author>
    <name>Gason Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP知识点</title>
    <link href="https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html"/>
    <id>https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html</id>
    <published>2018-01-31T02:42:00.000Z</published>
    <updated>2018-01-31T03:23:52.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 </p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 </p><p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p><p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。</p><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul><li>CLOSED: 这个没什么好说的了，表示初始状态。</li><li>LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</li><li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li><li>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</li><li>ESTABLISHED：这个容易理解了，表示连接已经建立了。</li><li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</li><li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li><li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li><li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li><li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</li><li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#1-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h3><p>答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p><ul><li>TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。</li><li>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。<br>失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。<br>考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 </li><li>采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</li></ul><h3 id="2-为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#2-为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="2. 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>2. 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h3><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；<br>但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，<br>所以关闭连接时的ACK报文和FIN报文多数情况下都是分开发送的。 </p><h3 id="3-什么是2MSL？"><a href="#3-什么是2MSL？" class="headerlink" title="3. 什么是2MSL？"></a>3. 什么是2MSL？</h3><p>2MSL(maximum segment lifetime)</p><ul><li>等待一段时间，防止最后的FIN的ACK包丢失，对方未收到ACK会重发FIN</li><li>TCP连接在2MSL时间内 ip,port不能重新被bind</li></ul><h3 id="4-为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？"><a href="#4-为什么TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？" class="headerlink" title="4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？"></a>4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</h3><p>虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）。<br>但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/hyqwmxsh/article/details/52437499" target="_blank" rel="noopener">面试笔试–TCP/IP知识点</a><br><a href="http://blog.csdn.net/i10630226/article/details/54880363" target="_blank" rel="noopener">HTTP/TCP常见面试问题总结</a></p>]]></content>
    
    <summary type="html">
    
      TCP/IP常见知识点汇总
    
    </summary>
    
      <category term="技术支撑" scheme="https://gaoshangs.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91/"/>
    
      <category term="网络工程" scheme="https://gaoshangs.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="TCP/IP" scheme="https://gaoshangs.github.io/categories/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%92%91/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/TCP-IP/"/>
    
    
      <category term="TCP/IP" scheme="https://gaoshangs.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>C语言指针</title>
    <link href="https://gaoshangs.github.io/2018-01-16-c-pointer-define.html"/>
    <id>https://gaoshangs.github.io/2018-01-16-c-pointer-define.html</id>
    <published>2018-01-16T13:24:00.000Z</published>
    <updated>2018-01-16T13:30:42.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-指针的定义方式："><a href="#1-指针的定义方式：" class="headerlink" title="1. 指针的定义方式："></a>1. 指针的定义方式：</h2><p>示例一：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure></p><p>说明：p为指针变量，int <em>p 中的</em>为类型说明符，声明p的类型为指针变量类型。指针变量必须是指向内存地址（内存指针），&amp;符为取地址运算符。<br>示例二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p>说明：先声明一个指针变量，然后对这个指针变量进行赋值。</p><h2 id="2-指针变量的使用"><a href="#2-指针变量的使用" class="headerlink" title="2. 指针变量的使用"></a>2. 指针变量的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d"</span>, *p);</span><br></pre></td></tr></table></figure><p>说明：这里的printf(“ <em>p = %d“, </em>p);中的<em>与上边声明指针变量的int </em>p的含义是不同的，这里的*为指针运算符，不是类型说明符。</p><pre><code class="C"><span class="built_in">printf</span>(<span class="string">"*&amp;a  = %d"</span>, *&amp;a); <span class="comment">//运行结果为a本身</span></code></pre><blockquote><p>由于*和&amp;的优先级相同，所以会先进行&amp;a进行取a的内存地址，然后在通过*指针运算符，指向a的内存地址并返回这块内存单元存放的数据。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>int *p 声明指针变量的* 为类型说明符，他的性质和int long的作用相似，都是说明变量的类型。</li><li>*p 获取指针变量的<em>为指针运算符，和&amp;的类型都是一样的就是参与运算的，只是&amp;获取的是内存的地址，</em>获取的是内存地址为该指针变量上存储的数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-指针的定义方式：&quot;&gt;&lt;a href=&quot;#1-指针的定义方式：&quot; class=&quot;headerlink&quot; title=&quot;1. 指针的定义方式：&quot;&gt;&lt;/a&gt;1. 指针的定义方式：&lt;/h2&gt;&lt;p&gt;示例一：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://gaoshangs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C" scheme="https://gaoshangs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
      <category term="指针" scheme="https://gaoshangs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%8C%87%E9%92%88/"/>
    
    
      <category term="C语言" scheme="https://gaoshangs.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="https://gaoshangs.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>面试知识点总结(持续更新~~)</title>
    <link href="https://gaoshangs.github.io/2018-01-15-knowledge-point.html"/>
    <id>https://gaoshangs.github.io/2018-01-15-knowledge-point.html</id>
    <published>2018-01-15T03:04:00.000Z</published>
    <updated>2018-01-31T02:39:56.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试知识点分类"><a href="#面试知识点分类" class="headerlink" title="面试知识点分类"></a>面试知识点分类</h2><ul><li>算法</li><li>数据结构</li><li>设计模式</li><li>Linux网络编程</li><li>语言基础</li><li>软件应用和优化</li><li></li></ul><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><ul><li><a href="https://zhidao.baidu.com/question/108496197.html" target="_blank" rel="noopener">什么是OO语言</a></li></ul><h2 id="Gearman"><a href="#Gearman" class="headerlink" title="Gearman"></a>Gearman</h2><ul><li><a href="http://wangying.sinaapp.com/archives/2157" target="_blank" rel="noopener">Gearman分布式任务处理系统（一）简介和工作原理</a></li><li><a href="http://wangying.sinaapp.com/archives/category/centos-3/gearman" target="_blank" rel="noopener">Gearman系列文章</a></li></ul><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul><li><a href="http://www.cnblogs.com/zyf-zhaoyafei/p/4828358.html" target="_blank" rel="noopener">PHP面试总结全</a></li><li><a href="https://github.com/ycrao/mynotes/issues/1" target="_blank" rel="noopener">面试题汇总1</a></li><li><a href="https://github.com/ycrao/mynotes/issues/4" target="_blank" rel="noopener">面试题汇总2</a></li></ul><h2 id="PHP框架"><a href="#PHP框架" class="headerlink" title="PHP框架"></a>PHP框架</h2><ul><li><a href="http://php.net/manual/zh/book.yaf.php" target="_blank" rel="noopener">yaf官方文档</a></li><li><a href="https://www.insp.top/learn-laravel-container" target="_blank" rel="noopener">laravel 学习笔记 —— 神奇的服务容器</a></li><li><a href="https://github.com/johnlui/Learn-Laravel-5" target="_blank" rel="noopener">laravel教程</a></li><li><a href="https://wiki.swoole.com/wiki/page/p-server.html" target="_blank" rel="noopener">swoole官方文档</a></li><li><a href="https://www.swoole.com/" target="_blank" rel="noopener">swoole官方首页</a> </li></ul><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><ul><li><a href="https://juejin.im/entry/5833f389570c35006c23992c" target="_blank" rel="noopener">京东三级列表页持续架构优化 — Golang + Lua (OpenResty) 最佳实践</a></li><li><a href="http://colobu.com/2017/04/07/go-webframework-benchmark-2017-Spring/" target="_blank" rel="noopener">Go Web 框架性能比拼 2017 春季版</a></li><li><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">GIN框架</a></li><li><a href="https://github.com/ningskyer/gin-doc-cn#router-group" target="_blank" rel="noopener">go 语言框架 gin 的中文文档</a></li><li><a href="https://www.jianshu.com/p/f690203ff168" target="_blank" rel="noopener">Golang精编100题</a></li><li><a href="https://mp.weixin.qq.com/s/rimq1Uar6O8MaxXeYYEhog" target="_blank" rel="noopener">2017年超有价值的Golang文章</a></li><li><a href="https://github.com/zoeminghong/go-library" target="_blank" rel="noopener">go入门知识汇总</a></li></ul><h2 id="lua和openresty和nginx"><a href="#lua和openresty和nginx" class="headerlink" title="lua和openresty和nginx"></a>lua和openresty和nginx</h2><ul><li><a href="https://openresty.org/cn/" target="_blank" rel="noopener">openresty官方文档</a></li><li><a href="https://segmentfault.com/a/1190000010677483" target="_blank" rel="noopener">Nginx面试中最常见的18道题 抱佛脚必备</a></li><li><a href="http://blog.csdn.net/watson2016/article/details/77938678" target="_blank" rel="noopener">nginx面试要点–持续更新中</a></li><li><a href="https://zhuanlan.zhihu.com/p/21362834" target="_blank" rel="noopener">浅谈nginx + lua在安全中的一些应用</a></li><li><a href="https://www.jianshu.com/p/87e1c7414c1e" target="_blank" rel="noopener">shell 分析nginx日志</a></li><li><a href="http://shellbaike.com/shell/200" target="_blank" rel="noopener">教你玩转 Nginx 日志</a></li><li><a href="https://www.centos.bz/2017/08/nginx-log-cut-shell-script/" target="_blank" rel="noopener">nginx日志切割shell脚本</a></li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li><a href="https://www.jianshu.com/p/ae2e43f7be19" target="_blank" rel="noopener">redis-热点</a></li><li><a href="http://www.voidcn.com/article/p-orxzpoiz-ct.html" target="_blank" rel="noopener">面试常见问题</a></li><li><a href="http://www.cnblogs.com/zzt-lovelinlin/p/7248447.html" target="_blank" rel="noopener">redis面试总结</a></li><li><a href="http://blog.csdn.net/luckykapok918/article/details/8502928" target="_blank" rel="noopener">memcached面试题集锦</a></li><li><a href="http://blog.jobbole.com/101496/" target="_blank" rel="noopener">也谈谈 Redis 和 Memcached 的区别</a></li><li><a href="https://www.lanhusoft.com/Article/87.html" target="_blank" rel="noopener">你应该知道的Memcached与Redis的区别与如何抉择</a></li><li><a href="https://github.com/gaoshangs/hit-interview/blob/master/redis.md" target="_blank" rel="noopener">redis面试总结</a></li><li></li></ul><h2 id="API和传输格式"><a href="#API和传输格式" class="headerlink" title="API和传输格式"></a>API和传输格式</h2><ul><li><a href="https://yami.io/protobuf/" target="_blank" rel="noopener">比起JSON 更方便、更快速、更简短的Protobuf 格式</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></li><li></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><a href="https://www.cnblogs.com/kubixuesheng/p/4353616.html" target="_blank" rel="noopener">冒泡和快速排序思想和实现</a></li><li><a href="https://www.jikexueyuan.com/course/2542.html" target="_blank" rel="noopener">极客学院基础算法一</a></li><li><a href="https://www.jikexueyuan.com/course/count/" target="_blank" rel="noopener">算法基础(极客学院)</a></li><li><a href="http://blog.csdn.net/booirror/article/details/7707551" target="_blank" rel="noopener">时间复杂度和空间复杂度详解</a></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><a href="https://www.jikexueyuan.com/course/2509.html" target="_blank" rel="noopener">数据结构之字符串、散列和布隆过滤器</a></li><li><a href="https://www.jikexueyuan.com/course/figure/?pageNum=1" target="_blank" rel="noopener">数据结构(极客学院)</a></li><li><a href="https://my.jikexueyuan.com/yutianzuijin/record/" target="_blank" rel="noopener">数据结构之数组、链表、字符串、散列、布隆过滤器</a></li><li><a href="https://my.jikexueyuan.com/subvoid/record/" target="_blank" rel="noopener">名企数据结构面试题(极客学院)</a></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-php-designptrns/index.html" target="_blank" rel="noopener">五种常见的 PHP 设计模式</a></li><li><a href="http://www.cnblogs.com/siqi/archive/2012/09/09/2667562.html" target="_blank" rel="noopener">PHP 设计模式</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=402566219&amp;idx=1&amp;sn=506c71aab4406782fdcc4484cd19070c&amp;scene=1&amp;srcid=0405cZTo6OqggUlX090C4MMR%23rd" target="_blank" rel="noopener">设计模式（一）——设计模式概述</a></li><li><a href="https://www.jikexueyuan.com/course/model/" target="_blank" rel="noopener">设计模式(极客学院)</a></li></ul><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><ul><li><a href="http://www.techug.com/post/mapreduce.html" target="_blank" rel="noopener">如何简单解释 MapReduce 算法</a></li><li></li></ul><h2 id="ElasticStack系列"><a href="#ElasticStack系列" class="headerlink" title="ElasticStack系列"></a>ElasticStack系列</h2><ul><li><a href="http://www.cnblogs.com/xing901022/p/5284902.html" target="_blank" rel="noopener">分页查询From&amp;Size VS scroll</a></li><li><a href="http://lxwei.github.io/posts/使用scroll实现Elasticsearch数据遍历和深度分页.html" target="_blank" rel="noopener">使用scroll实现Elasticsearch数据遍历和深度分页</a></li><li><a href="http://ginobefunny.com/post/elasticsearch_interview_questions/" target="_blank" rel="noopener">面试小结之Elasticsearch篇</a></li><li><a href="http://www.cnblogs.com/liang1101/tag/ElasticStack/" target="_blank" rel="noopener">ElasticStack</a></li><li></li></ul><h2 id="HTTP-TCP-IP"><a href="#HTTP-TCP-IP" class="headerlink" title="HTTP/TCP/IP"></a>HTTP/TCP/IP</h2><ul><li><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="noopener">TAT.tennylvHTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a></li><li><a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="noopener">HTTP/2资料总结</a></li><li><a href="http://blog.csdn.net/i10630226/article/details/54880363" target="_blank" rel="noopener">HTTP/TCP常见面试问题总结</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">hit-alibaba</a></li><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么？</a></li><li><a href="http://blog.csdn.net/hyqwmxsh/article/details/52437499" target="_blank" rel="noopener">面试笔试–TCP/IP知识点</a></li><li><a href="http://blog.csdn.net/JXH_123/article/details/40316081" target="_blank" rel="noopener">计算机网络常见面试题总结</a></li><li><a href="http://blog.csdn.net/xiaoninvhuang/article/details/70257189" target="_blank" rel="noopener">http协议详解及htt面试题目，常见的http状态码</a></li></ul><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/23713529" target="_blank" rel="noopener">常见面试题整理–数据库篇（每位开发者必备）</a></li><li><a href="http://blog.51cto.com/apprentice/1394494" target="_blank" rel="noopener">阿里巴巴MySQL DBA面试题答案(欢迎进来讨论)</a></li><li><a href="https://www.jianshu.com/p/3a1377883742" target="_blank" rel="noopener">MySQL索引原理及实现</a></li><li><a href="https://www.cnblogs.com/frankielf0921/p/5930743.html" target="_blank" rel="noopener">MySQL常见面试题</a></li></ul><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul><li><a href="https://github.com/taizilongxu/interview_python" target="_blank" rel="noopener">Python完整</a></li><li><a href="https://zhuanlan.zhihu.com/p/23582996" target="_blank" rel="noopener">常见面试题整理–Python代码篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/23526961" target="_blank" rel="noopener">常见面试题整理–Python概念篇</a></li><li><a href="http://codingpy.com/article/essential-python-interview-questions/" target="_blank" rel="noopener">Python面试必须要看的15个问题</a></li></ul><h2 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h2><ul><li><a href="https://www.jianshu.com/p/a8938811f0bc" target="_blank" rel="noopener">spring面试题总结</a></li><li><a href="https://www.jianshu.com/p/005f0252189a" target="_blank" rel="noopener">JAVA面试题 java web部分</a></li></ul><h2 id="linux系统和网络编程"><a href="#linux系统和网络编程" class="headerlink" title="linux系统和网络编程"></a>linux系统和网络编程</h2><ul><li><a href="http://my.jikexueyuan.com/0mjjUjVag/record/" target="_blank" rel="noopener">Linux网络编程(极客学院)</a></li><li><a href="https://zhuanlan.zhihu.com/p/24001696" target="_blank" rel="noopener">计算机网络篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/23755202" target="_blank" rel="noopener">操作系统篇</a></li><li><a href="http://blog.csdn.net/youngchang06hpu/article/details/8009947" target="_blank" rel="noopener">操作系统常见面试题总结</a></li><li><a href="http://www.yunweipai.com/archives/24703.html" target="_blank" rel="noopener">176条DevOps人员常用的linux命令速查表</a></li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="http://blog.csdn.net/yusiguyuan/article/details/17591613" target="_blank" rel="noopener">常见多线程并发服务器编程模型</a></li><li><a href="http://blog.csdn.net/wan_hust/article/details/38441455?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">IO复用、多进程和多线程三种并发编程模型</a></li><li><a href="http://www.cnblogs.com/LUO77/p/5816326.html" target="_blank" rel="noopener">进程间通信的方式——信号、管道、消息队列、共享内存</a></li><li><a href="http://blog.csdn.net/zhangjs712/article/details/52092989" target="_blank" rel="noopener">linux性能分析常用命令详解</a></li><li><a href="http://blog.csdn.net/xiangliangyu/article/details/7056937" target="_blank" rel="noopener">Linux Web服务器网站故障分析常用的命令</a></li><li><a href="http://blog.csdn.net/xiangliangyu/article/details/7056937" target="_blank" rel="noopener">LINUX常用的日志分析命令</a></li><li><a href="http://docs.linuxtone.org/ebooks/Webapp/webscan.txt" target="_blank" rel="noopener">网站排障分析常用的命令</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/Socket-Programming-Basic.html" target="_blank" rel="noopener">Socket 基本概念</a></li><li><a href="https://github.com/hellorocky/LearnByCoding/tree/master/python/network/socket" target="_blank" rel="noopener">socket编程(python)</a></li><li><a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">Linux Socket编程（不限Linux）</a></li><li><a href="http://goodcandle.cnblogs.com/archive/2005/12/10/294652.aspx" target="_blank" rel="noopener">揭开Socket编程的面纱</a></li><li><a href="https://my.oschina.net/u/2548201/blog/1607603" target="_blank" rel="noopener">Socket基础原理</a></li></ul><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><ul><li><a href="https://mp.weixin.qq.com/s/VmnwoES_BNW2BWFH7K4Wow" target="_blank" rel="noopener">搜狐Linux运维工程师面试</a></li><li><a href="http://www.yunweipai.com/archives/11331.html" target="_blank" rel="noopener">运维必须掌握的27道Linux面试题</a></li><li><a href="http://www.178linux.com/18051" target="_blank" rel="noopener">运维面试题和答案</a></li><li><a href="http://www.yunweipai.com/archives/18798.html" target="_blank" rel="noopener">2017年企业运维岗经典面试题</a></li><li><a href="http://www.yunweipai.com/archives/12037.html" target="_blank" rel="noopener">Linux系统运维常见面试简答题系列（二）</a></li><li><a href="http://www.yunweipai.com/archives/18798.html" target="_blank" rel="noopener">2017年企业运维岗经典面试题（28题）</a></li><li></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li><a href="https://segmentfault.com/a/1190000010913697" target="_blank" rel="noopener">前端需要知道的web安全知识</a></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a href="https://segmentfault.com/a/1190000010913697" target="_blank" rel="noopener">Web缓存详解</a></li><li><a href="http://www.yunweipai.com/archives/8240.html" target="_blank" rel="noopener">你有自己的Web缓存知识体系吗</a></li><li><a href="http://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">缓存更新的套路</a></li><li></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="https://www.zhihu.com/question/37808426" target="_blank" rel="noopener">SOA和微服务架构的区别</a><blockquote><p>SOA描述了一种架构模型，微服务是具体的实现?</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试知识点分类&quot;&gt;&lt;a href=&quot;#面试知识点分类&quot; class=&quot;headerlink&quot; title=&quot;面试知识点分类&quot;&gt;&lt;/a&gt;面试知识点分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;Linu
      
    
    </summary>
    
      <category term="软技能" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
      <category term="面试" scheme="https://gaoshangs.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://gaoshangs.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>知识体系分类</title>
    <link href="https://gaoshangs.github.io/2018-01-14-knowledge-system-catgory.html"/>
    <id>https://gaoshangs.github.io/2018-01-14-knowledge-system-catgory.html</id>
    <published>2018-01-13T16:28:00.000Z</published>
    <updated>2018-01-16T13:27:33.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人知识体系-持续完善"><a href="#个人知识体系-持续完善" class="headerlink" title="个人知识体系(持续完善~~)"></a>个人知识体系(持续完善~~)</h1><blockquote><p>包含未触及但想学习的领域</p></blockquote><ul><li><p>编程语言</p><ul><li>Java</li><li>Python</li><li>GoLang</li><li>PHP</li><li>C++</li><li>C<ul><li>指针</li></ul></li><li>Node.js</li><li>JavaScript</li><li>HTML5</li><li>CSS3</li></ul></li><li><p>技术支撑</p><ul><li>操作系统<ul><li>Linux</li><li>MacOS</li><li>Windows</li><li>iOS</li><li></li></ul></li><li>网络工程<ul><li>OSI</li><li>TCP/IP</li><li>HTTP/HTTPS</li><li>HTTP 1.X / HTTP 2</li></ul></li><li>软件工程<ul><li>算法</li><li>数据结构</li><li>设计模式</li><li>代码规范</li></ul></li><li>数学</li></ul></li><li><p>后端开发</p><ul><li>Linux网络编程</li><li></li></ul></li><li><p>Web前端</p><ul><li>前端框架<ul><li>jQuery</li><li>Vue.js</li></ul></li><li>数据格式<ul><li>JSON</li><li>XML</li><li>JSONP</li><li>Protobuf</li></ul></li></ul></li><li><p>测试</p><ul><li>单元测试<ul><li>JUnit</li><li></li></ul></li><li>集成测试</li><li>自动化测试</li></ul></li></ul><ul><li><p>研发工具</p><ul><li>思维导图&amp;建模<ul><li>UML</li></ul></li><li>版本控制系统<ul><li>Git</li><li>Svn</li><li></li></ul></li><li>调试工具<ul><li>Charles、Wireshark</li><li>Postman</li></ul></li><li><p>IDE</p><ul><li>Jetbrains</li><li>IntelliJ IDEA</li><li>PhpStorm</li><li>Sublime Text</li><li>Android Studio</li></ul></li><li><p>构建工具</p><ul><li>Gradle</li><li>Maven</li><li></li></ul></li><li>效率工具<ul><li>番茄钟</li><li>Markdown</li><li>滴答清单</li></ul></li></ul></li><li><p>运维管理</p><ul><li>监控</li><li>告警</li><li>日志</li></ul></li></ul><ul><li>架构师<ul><li>性能优化</li><li>应用技术<ul><li>消息队列(MQ)</li><li>缓存</li></ul></li><li></li></ul></li><li><p>软技能</p><ul><li>面试</li><li>知识管理<ul><li>开源项目</li><li>技术博客</li><li>技术分享</li><li></li></ul></li><li>时间管理<ul><li>番茄工作法</li></ul></li><li>目标管理<ul><li>甘特图</li><li>思维导图</li></ul></li><li>项目管理</li><li>团队管理</li></ul></li><li><p>安全</p></li><li><p>移动开发</p></li><li><p>云计算</p><ul><li>OpenStack</li><li>容器(Container)</li><li>微服务(MicroService)</li></ul></li><li><p>大数据</p><ul><li>MySQL</li><li>NoSQL<ul><li>Redis</li><li>MongoDB</li><li>Memcached</li></ul></li><li>Zookeeper</li><li>Kafka</li><li>ElasticStack</li><li>Hadoop</li><li>Spark</li></ul></li><li><p>人工智能(AI)</p><ul><li>机器学习</li></ul></li><li><p>财经</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/TeamStuQ/skill-map" target="_blank" rel="noopener">程序员技能图谱</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;个人知识体系-持续完善&quot;&gt;&lt;a href=&quot;#个人知识体系-持续完善&quot; class=&quot;headerlink&quot; title=&quot;个人知识体系(持续完善~~)&quot;&gt;&lt;/a&gt;个人知识体系(持续完善~~)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;包含未触及但想学习的领域&lt;/p
      
    
    </summary>
    
    
      <category term="知识系统" scheme="https://gaoshangs.github.io/tags/%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="技能图谱" scheme="https://gaoshangs.github.io/tags/%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>优秀博客</title>
    <link href="https://gaoshangs.github.io/2018-01-09-excellent-blog.html"/>
    <id>https://gaoshangs.github.io/2018-01-09-excellent-blog.html</id>
    <published>2018-01-09T07:13:12.000Z</published>
    <updated>2018-01-15T01:04:44.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul><li><a href="http://www.hollischuang.com/" target="_blank" rel="noopener">Hollis</a></li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul><li><a href="http://www.hankcs.com/" target="_blank" rel="noopener">码农场</a></li><li></li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><a href="http://notes.iissnan.com/" target="_blank" rel="noopener">IIssNan</a></li><li></li></ul><h2 id="hexo-next"><a href="#hexo-next" class="headerlink" title="hexo+next"></a>hexo+next</h2><ul><li><a href="https://notes.wanghao.work/" target="_blank" rel="noopener">Doublemine</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;java&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.hollischuang.com/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="blog" scheme="https://gaoshangs.github.io/tags/blog/"/>
    
  </entry>
  
</feed>
