<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP面试知识点汇总]]></title>
    <url>%2F2018-03-01-php-interview-knowledge-point.html</url>
    <content type="text"><![CDATA[知识点 面试知识点总结(持续更新~~) 全网最全php面试题目算法 常见算法 归并排序算法 一致性hash算法和应用 跳跃表算法 PHP PHP面试题汇总(一) php面试题汇总(二) PHP面试题汇总(三) PHP面试题汇总(四) 设计模式 设计模式面试题 2017最新PHP面试题 正则表达式知识点 PHP7 新特性 正则表达式知识点 Linux http协议详解 Linux服务器网站故障分析常用的命令 linux网络编程 TCP/IP知识点 CURL用法 MySQL MySQL InnoDB索引底层原理详解 MySQL知识点 MySQL性能优化总结 NoSQL redis和memcached的区别 架构 负载均衡知识点 浏览器输入url之后的技术栈]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式知识点]]></title>
    <url>%2F2018-02-28-regular-expression.html</url>
    <content type="text"><![CDATA[表达式合集12345678910111213141516171819202122232425262728293031323334353637383940414243字符 描述\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。$ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。* 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于&#123;0,&#125;。+ 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于&#123;1,&#125;。? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于&#123;0,1&#125;。&#123;n&#125; n是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。&#123;n,&#125; n是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。&#123;n,m&#125; m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。? 当该字符紧跟在任何一个其他限制符（*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。. 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。(pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。(?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始(?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。(?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。[xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。[a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。\B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\d 匹配一个数字字符。等价于[0-9]。\D 匹配一个非数字字符。等价于[^0-9]。\f 匹配一个换页符。等价于\x0c和\cL。\n 匹配一个换行符。等价于\x0a和\cJ。\r 匹配一个回车符。等价于\x0d和\cM。\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。\t 匹配一个制表符。等价于\x09和\cI。\v 匹配一个垂直制表符。等价于\x0b和\cK。\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。.\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。\n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。\nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 常用正则表达式12345678910111213141516171819202122网址（URL） [a-zA-z]+://[^\s]*IP地址(IP Address) ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)电子邮件(Email) \w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*QQ号码 [1-9]\d&#123;4,&#125;HTML标记(包含内容或自闭合) &lt;(.*)(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上) (?=^.&#123;8,&#125;$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$日期(年-月-日) (\d&#123;4&#125;|\d&#123;2&#125;)-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))日期(月/日/年) ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d&#123;4&#125;|\d&#123;2&#125;)时间(小时:分钟, 24小时制) ((1|0?)[0-9]|2[0-3]):([0-5][0-9])汉字(字符) [\u4e00-\u9fa5]中文及全角标点符号(字符) [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]中国大陆固定电话号码 (\d&#123;4&#125;-|\d&#123;3&#125;-)?(\d&#123;8&#125;|\d&#123;7&#125;)中国大陆手机号码 1\d&#123;10&#125;中国大陆邮政编码 [1-9]\d&#123;5&#125;中国大陆身份证号(15位或18位) \d&#123;15&#125;(\d\d[0-9xX])?非负整数(正整数或零) \d+正整数 [0-9]*[1-9][0-9]*负整数 -[0-9]*[1-9][0-9]*整数 -?\d+小数 (-?\d+)(\.\d+)?不包含abc的单词 \b((?!abc)\w)+\b匹配a标签的href地址 |&lt;a[^href]+href="(.*)".*&gt;|U 参考 表达式全集 正则表达式30分钟入门教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP面试题汇总(四)]]></title>
    <url>%2F2018-02-27-php-Interview-question-4.html</url>
    <content type="text"><![CDATA[Nginx+Keepalived主主模式-负载均衡高可用 nginx可以提供负载均衡服务，如果单台nginx提供服务存在单点隐患，请问有哪些方案可以解决？ 解决方案： 阿里云：SLB（付费） 硬件负载均衡器（F5，Radware） 软件方式实现高可用或负载均衡:Keepalived、LVS 参考 负载均衡知识点 日志系统架构思路有赞日志架构图 有赞统一日志系统，负责收集所有系统日志和业务日志，转化为流式数据 通过flume或logstash上传到日志中心(kafka集群)， 然后供Track、Storm、Spark及其它系统实时分析处理日志， 并将日志持久化存储到HDFS供离线数据分析处理，或写入ElasticSearch提供数据查询，或写入Hawk发起异常报警或提供指标监控查询。 参考 有赞统一日志平台初探 监控系统 深度剖析开源分布式监控CAT 从零开始搭建ELK+GPE监控预警系统]]></content>
      <tags>
        <tag>面试</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载均衡知识点]]></title>
    <url>%2F2018-02-27-load-balance-knowledge-point.html</url>
    <content type="text"><![CDATA[Nginx、LVS及HAProxy负载均衡软件的优缺点LVS1、抗负载能力强。抗负载能力强、性能高，能达到F5硬件的60%；对内存和cpu资源消耗比较低2、工作在网络4层，通过vrrp协议转发（仅作分发之用），具体的流量由linux内核处理，因此没有流量的产生。2、稳定性、可靠性好，自身有完美的热备方案；（如：LVS+Keepalived）3、应用范围比较广，可以对所有应用做负载均衡；4、不支持正则处理，不能做动静分离。5、支持负载均衡算法：rr（轮循）、wrr（带权轮循）、lc（最小连接）、wlc（权重最小连接）6、配置 复杂，对网络依赖比较大，稳定性很高。 Ngnix1、工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构；2、Nginx对网络的依赖比较小，理论上能ping通就就能进行负载功能；3、Nginx安装和配置比较简单，测试起来比较方便；4、也可以承担高的负载压力且稳定，一般能支撑超过1万次的并发；5、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。6、Nginx对请求的异步处理可以帮助节点服务器减轻负载；7、Nginx仅能支持http、https和Email协议，这样就在适用范围较小。8、不支持Session的直接保持，但能通过ip_hash来解决。对Big request header的支持不是很好，9、支持负载均衡算法：Round-robin（轮循）、Weight-round-robin（带权轮循）、Ip-hash（Ip哈希）10、Nginx还能做Web服务器即Cache功能。 HAProxy1、支持两种代理模式：TCP（四层）和HTTP（七层），支持虚拟主机；2、能够补充Nginx的一些缺点比如Session的保持，Cookie的引导等工作3、支持url检测后端的服务器出问题的检测会有很好的帮助。4、更多的负载均衡策略比如：动态加权轮循(Dynamic Round Robin)，加权源地址哈希(Weighted Source Hash)，加权URL哈希和加权参数哈希(Weighted Parameter Hash)已经实现5、单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度。6、HAProxy可以对Mysql进行负载均衡，对后端的DB节点进行检测和负载均衡。9、支持负载均衡算法：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求URL）、rdp-cookie（根据cookie）10、不能做Web服务器即Cache。11，自带强大的监控页面。 四层、七层负载均衡的区别四层负载均衡所谓四层就是基于IP+端口的负载均衡，四层交换机在OSI第4层工作，主要分析IP层及TCP/UDP层，实现四层流量负载均衡就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。 七层七层OSI的最高层(应用层)就是基于URL等应用层信息的负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。 keepalived 作用：Keepalived的作用是检测web服务器的状态，及时踢出故障机器和恢复正常机器。 原理：工作在IP/TCP协议栈的IP层，TCP层，及应用层（3&amp;4&amp;5层）。 2.1 Layer3工作方式：Keepalived会定期向服务器群中的服务器，发送一个ICMP的数据包（既我们平时用的Ping程序）,如果发现某台服务的IP地址没有激活，Keepalived便报告这台服务器失效，并将它从服务器群中剔除，这种情况的典型例子是某台服务器被非法关机。Layer3的方式是以服务器的IP地址是否有效作为服务器工作正常与否的标准 2.2 Layer4工作方式:Layer4主要以TCP端口的状态来决定服务器工作正常与否。如web server的服务端口一般是80，如果Keepalived检测到80端口没有启动，则Keepalived将把这台服务器从服务器群中剔除 2.3 Layer5工作方式:Layer5就是工作在具体的应用层了,Keepalived将根据用户的设定检查服务器程序的运行是否正常，如果与用户的设定不相符，则Keepalived将把服务器从服务器群中剔除 Nginx+Keepalived实现站点高可用 参考： Nginx+Keepalived实现站点高可用 Nginx+Keepalived主主模式-负载均衡高可用 Keepalived+Nginx实现高可用Web负载均衡 负载均衡（SLB）使用最佳实践参考 四层、七层负载均衡的区别 三大主流软件负载均衡器对比(LVS 、 Nginx 、Haproxy) Nginx+Keepalived主主模式-负载均衡高可用 阿里云负载均衡技术原理浅析 阿里云负载均衡（SLB）使用最佳实践 keepalived 学习]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器输入url之后的技术栈]]></title>
    <url>%2F2018-02-26-start-from-input-url.html</url>
    <content type="text"><![CDATA[1. 输入地址浏览器url自动补全，匹配 2. 浏览器查找域名的ip： 本地hosts文件查找 浏览器发出DNS请求到本地DNS(公司DNS服务器或网络接入服务商的DNS服务器) 本地DNS服务器从缓存记录中查找，递归查询，找到则返回，没找到向DNS根服务器(13台根服务器)进行查询 根DNS服务器不记录具体的域名和IP对应关系，而是告诉本地DNS服务器域服务器地址(13台顶级域名服务器)，找域服务器迭代查询 本地DNS服务器向域服务器发出请求，比如对象是.com域服务器，.com域服务器也不会直接返回域名和ip对应关系，而是告诉本地DNS域名解析服务器的地址 本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS把ip返回给用户电脑，同时本地DNS也会缓存方便供下次查询 知识扩展： 2.1 常用域名解析linux命令dig、nslookup，host 2.2 DNS查询的两种方式：递归查询和迭代查询 递归查询：一般是本地DNS服务器向根域名服务器查询，然后由跟域名服务器一级级向下查询，查找到结果后返回给本地DNS服务器，然后返回给客户端 迭代查询:局部DNS服务器不是自己向其他DNS服务器进行查询,而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止 2.3 什么是DNS域名和IP地址相互映射的一个分布式数据库 2.4 DNS域名称空间的组织方式 3. 浏览器向 web 服务器发送一个 HTTP 请求3.1 TCP三次握手建立连接 3.2 http请求信息请求信息包含三个部分:第一部分：请求方法URI 协议/版本第二部分：请求头(Request Header)第三部分：请求正文ps: 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文 1234567891011GET /s?wd=tinyint%20mysql%20%E8%8C%83%E5%9B%B4&amp;rsv_spt=1&amp;rsv_iqid=0xdc5b82ba0000f8f1&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=92821989_s_hao_pg&amp;rsv_enter=1&amp;rsv_sug3=1 HTTP/1.1Host: www.baidu.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,de;q=0.8,en;q=0.7Cookie: BAIDUID=112214E2FB5B1B92AE076721859B590F:FG=1; BIDUPSID=112214E2FB5B1B92AE076721859B590F; wd=tinyint%20mysql%20%E8%8C%83%E5%9B%B4&amp;rsv_spt=1&amp;rsv_iqid=0xdc5b82ba0000f8f1&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=92821989_s_hao_pg&amp;rsv_enter=1&amp;rsv_sug3=1 3.3 HTTP请求方法-get,put,post,delete含义与区别 一个URL地址，它用于描述一个网络上的资源，而HTTP中的POST，GET，PUT，DELETE，PATCH就对应着对这个资源的创建，查看，创建或更新，删除，部分更新等五种操作 方法 作用 幂等 安全 GET 用于信息获取 是 是 POST 一般用于创建数据 否 否 PUT 创建或完整更新数据 是 是 DELETE 一般用于删除数据 是 是 PATCH 一般用于更新部分数据( 对PUT请求的补充 否 否 3.4 http code与缓存层 200状态：当浏览器本地没有缓存或下一层失效时或用户点击CTRL+F5，直接去服务器下载最新数据 304状态：这一层由last-modify/etag控制。当下一层失效或用户点击F5时，浏览器会发送请求给服务器，如果服务端没有变化，则返回304给浏览器 ps:etag是对url进行标记，检测标记是否存在，但是由于分布式系统中各个机器生成的标记不同，所以一般会关闭掉 200(from cache)：这一层由expires/cache-control控制。 1. expires(http1.0版有效)是绝对时间。 2. cache-control(http1.1版本有效)，相对时间，两者都存在时，cache-control覆盖expires只要没有失效，浏览器只访问自己的缓存总结：expires和cache-control都是本地的缓存过期时间，缓存期不会请求服务端，last-modify会发生服务端的请求，检测服务端是否有更改。 4. 服务器的永久重定向响应4.1 为什么使用永久重定向(301) 提升搜索引擎排名(就像http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名，设定为301后，搜索引擎会认为是一个网站) 缓存友好性变差（同一个页面有好几个url时，会被重复缓存多次） 4.2 301和302的区别共同点：都是重定向，重定向地址可以在响应头location中获取，效果是：用户输入A瞬间变成B区别：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 4.3 重定向原因： 网站调整 网页被移到一个新的地址 多域名网站重定向到主站 4.4 什么时候进行301或者302跳转呢？ 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。 空间服务器不稳定，换空间的时候。 5. 服务器处理请求5.1 什么是反向代理，正反向代理区别5.1.1 正向代理原理：就是代理，原理就像一个跳板，访问不了某个网站，通过代理服务器就可以访问。比如通过vpn访问公司内网特点：客户端为了访问原始服务器，通过请求代理服务器，然后代理向原始服务器转交请求获取内容后，转给客户端。必须要进行一些特别的设置才能使用正向代理 5.1.2. 反向代理原理：对于客户端而言，它更像是原始服务器，客户端不需要特别的设置，直接向反向代理服务器发送请求，反向代理服务器自己判断向应用服务器转发请求，获取内容后返回给客户端。特点：客户端不需要特别的设置，从反向代理服务器获取内容就像从原始服务器获取一样。 5.1.3. 区别用途： 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。 反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。 反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下 安全性： 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理 参考： 正向代理与反向代理的区别 5.2 阿里云负载均衡(SLB)最佳实践负载均衡（Server Load Balancer，下文简称 SLB）的引入，可以降低单台云服务器 ECS（下文简称 ECS）出现异常时对业务的冲击，提升业务的可用性。同时，结合弹性伸缩服务，通过动态调整后端服务器，可以快速对业务进行弹性调整（扩容或缩容），以快速应对业务的发展。 参考： 负载均衡（SLB）使用最佳实践 5.3 Nginx+Keepalived实现站点高可用参考： Nginx+Keepalived实现站点高可用 5.4 服务器内部处理 redis缓存 mysql优化 代码优化 … 6. 服务器返回一个 HTTP 响应12345678910111213141516171819202122HTTP/1.1 301 Moved PermanentlyServer: nginxDate: Mon, 26 Feb 2018 09:36:40 GMTContent-Encoding:gzipContent-Type: text/htmlset-cookie:sf_remember=1e055cc0983b652de8e2d2fd02ff068d; expires=Tue, 06-Mar-2018 02:25:12 GMT; Max-Age=604800; path=/Location: http://www.sina.com.cn/Expires: Mon, 26 Feb 2018 10:36:40 GMTCache-Control: max-age=3600Age: 14Content-Length: 122X-Cache: HIT from cnc.xidan.sinacache.24.nb.sinaedge.com＜html＞＜head＞＜title＞http＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞ 6.1 状态行 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔 格式: HTTP-Version Status-Code Reason-Phrase CRLF例如: HTTP/1.1 200 OK \r\n 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理 200 OK 表示客户端请求成功204 No Content 成功，但不返回任何实体的主体部分 3xx：重定向状态码，表示服务器要求客户端重定向 301 永久重定向302 临时重定向304 页面未修改 4xx：客户端错误状态码，表示客户端的请求有非法内容 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 服务器内部未知错误502 错误的网关503 服务临时不可用504 网关超时 6.2 响应头响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔典型的响应头有：| 应答头 | 说明 || —————- | —————————————- || Allow | 服务器支持哪些请求方法（如GET、POST） || Content-Encoding | 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Servlet可以通过查看Accept-Encoding头检查浏览器是否支持gzip(即request.getHeader(‘Accept-Encoding’))，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 || Content-Length | 表示内容长度。 || Content-Type | 表示文档属于什么MIME类型。默认为text/plain，通常设置为text/html || Date | 当前的GMT时间(世界标准时间，加8小时为北京时间） || Expires | 文档过期时间，浏览器缓存失效 || Last-Modified | 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，只有改动时间晚于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。 || Location | 重定向后的地址，状态代码一般为301(永久重定向)或302（临时重定向） || Refresh | 表示浏览器多少时间后刷新文档，以秒计。注意Refresh的意义是”N秒后刷新页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。想要连续刷新要求每次都发送一个Refresh头。 || Server | 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 || Set-Cookie | 设置和页面关联的Cookie。 || WWW-Authenticate | 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。一般由Web服务器来控制受密码保护页面的访问(如.htaccess) | 源图片参考：典型的响应头 6.3 响应正文包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等.响应正文和响应头之间有一行空格，表示响应头的信息到空格为止 7. 浏览器显示 HTML和加载静态资源不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载 解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上 这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)7.1 reflow和repainDOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain 7.2 为什么把js文件一般放到文档末尾 加载js文件时，html会挂起渲染，等待文档js文件加载完毕，并且等待解析执行完毕后，才能恢复html文档的渲染线程。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我们平时的代码中，js是放在html文档末尾的 7.3 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）图片、CSS式样表、JavaScript 文件，这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等。不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中。 参考： 老生常谈-从输入url到页面展示到底发生了什么 REST模式：POST，GET，PUT，DELETE，PATCH的含义与区别]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7 新特性]]></title>
    <url>%2F2018-02-23-php7.html</url>
    <content type="text"><![CDATA[官方的文档显示，PHP7可以达到PHP5.x版本两倍的性能。同时还提供了很多其他语言流行的语法格式。另外其PHP7的兼容性也是非常好的。 函数参数支持标量类型声明在PHP5中，可以将函数参数指定为类名、接口名、数组和回调类型中的一种，但是无法将类型指定为标量。PHP7中新增了对函数参数声明为四种标量类型的支持，即可以指定参数类型为整型（int）、浮点型（float）、字符串（string）以及布尔型（bool）。 123456&lt;?php //指定函数参数必须为字符串 function checkOpenid(string $sOpenid) &#123; return preg_match('/^[a-zA-Z_-]&#123;28&#125;$/', $sOpenid); &#125; 新增函数返回类型声明PHP7新增了对函数返回类型声明的支持，支持的类型与参数类型相同（在PHP7.1中支持返回void类型） 123456&lt;?php //指定函数返回值必须为整型 function checkOpenid(string $sOpenid): int &#123; return preg_match('/^[a-zA-Z_-]&#123;28&#125;$/', $sOpenid); &#125; define定义常量数组PHP5.6及以后版本中可以通过const关键字来定义常量数组，PHP7中新增可以通过define定义常量数组功能。 1234567&lt;?php //php5.6中通过const定义常量数组 const FRUITS = ['peach', 'banana', 'pear', 'orange']; //php7 中通过define定义常量数组数组 define('FRUITS1', ['peach','banana','pear','orange']);?&gt; 生成器的返回值和引入其他生成器在PHP5.5引入生成器的概念。生成器函数每执行一次就得到一个yield标识的值。在PHP7中，当生成器迭代完成后，可以获取该生成器函数的返回值。通过Generator::getReturn()得到。 1234567891011121314151617&lt;?phpfunction generator() &#123; yield 1; yield 2; yield 3; return "a";&#125;$generatorClass = ("generator")();foreach ($generatorClass as $val) &#123; echo $val.” “;&#125;echo $generatorClass-&gt;getReturn();//运行结果：1 2 3 a 在生成器中可以引入另一个或几个生成器，只需要写yield from functionName11234567891011121314151617181920212223&lt;?phpfunction generator1()&#123; yield 1; yield 2; yield from generator2(); yield from generator3();&#125;function generator2()&#123; yield 3; yield 4;&#125;function generator3()&#123; yield 5; yield 6;&#125;foreach (generator1() as $val)&#123; echo $val, " ";&#125;//输出：1 2 3 4 5 6 NULL合并运算符后端CGI在接收用户传入的数据时通常会先判断变量是否存在，如果存在获取对应的值，如果不存在，在设置一个默认值或者报错处理。这里就会用到 三元运算符和isset。在PHP7中新增了一个语法糖??。如果第一个操作数存在且不为null则返回第一个操作数的值，否则返回第二个操作数的值。例如： 12345678&lt;?php //获取用户openid.先从$_GET中获取，如果没有从$_POST中获取，如果还是不存在，就默认空 //PHP7之前的写法 $sOpenid = isset($_GET['iuin']) ? $_GET['iuin'] : (isset($_POST['iuin']) ? $_POST['iuin'] : ''); //php7中新增的??语法糖 $sOpenid = $_GET['iuin'] ?? $_POST['iuin'] ?? '';?&gt; 组合比较符该操作符也称为太空船操作符，用于对2个表达式进行比较并返回比较结果。使用语法：$exp1 &lt;=&gt; $exp2。如果$exp1小于$exp2返回-1，$exp1等于$exp2返回0，$exp1大于$exp2返回1。比较的原则是沿用 PHP 的常规比较规则进行的。 123456789&lt;?php echo 10 &lt;=&gt; 9; echo 10 &lt;=&gt; 20; echo 10 &lt;=&gt; '10';?&gt;#输出结果# 1# -1# 0 Closure::call()Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它 123456789101112&lt;?phpclass Test&#123;public $name = "lixuan";&#125;//PHP7和PHP5.6都可以$getNameFunc = function()&#123;return $this-&gt;name;&#125;;$name = $getNameFunc-&gt;bindTo(new Test, 'Test');echo $name();//PHP7可以,PHP5.6报错$getX = function() &#123;return $this-&gt;name;&#125;;echo $getX-&gt;call(new Test); foreach不再改变内部数组指针在PHP7之前，当数组通过 foreach 迭代时，数组指针会移动。现在开始，不再如此，见下面代码。 12345678910111213141516171819&lt;?php$array = [0, 1, 2];foreach ($array as &amp;$val) &#123; var_dump(current($array));&#125;/*PHP5输出：int(1)int(2)bool(false)PHP7输出：int(0)int(0)int(0)*/ 参考： PHP7新特性 PHP7 新特性简介 PHP7新功能及语法变化总结 PHP7革新与性能优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP面试题汇总(三)]]></title>
    <url>%2F2018-02-09-php-Interview-question-3.html</url>
    <content type="text"><![CDATA[归并排序算法原理算法思路 时间复杂度：O(nlogn) 把 n 个记录看成 n 个长度为 l 的有序子表 进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 实例两个正序数组，如[3 4 7 9], [2 6 8] 如何合并成一个正序数组假设：序列A：3 4 7 9序列B：2 6 8序列C：空合并思路是：先申请一个序列，将指针分别指向3和2，这时候进行比较，3大于2，所以把2放到序列C，序列B指针后移到6，这时候序列A的3小于6，把3放到序列C，A序列指针后移4小于序列B的6，把4放到序列C，依次类推。。。直到最后只剩下序列A中的9，把9合并到序列C，完成归并排序 参考 归并排序算法 一致性HASH原理和应用 问题：单机redis20G如何承载500G的cache（考虑redis集群应用） 应用场景如何对请求与缓存服务器之间进行精准映射,以及优雅的扩展，剔除缓存服务器，提升缓存服务的容错性和扩展性 算法概述一致性哈希将整个哈希空间组织成一个虚拟的圆环，假如整个哈希函数的值空间为0 - 2^32 -1(一个32位的无符号整形)，如下图:整个空间按顺时针方向组织,0和232-1在零点中方向重合 第一步：在哈希闭环中确定各台服务器位置 将各台服务器的ip或主机名为关键字通过H函数得到一个哈希值，然后在哈希闭环中标注位置。如下图3台redis服务： 第二步：定位数据访问的服务器 将数据key使用相同的函数H计算出哈希值h，通根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器 例如我们缓存服务器中有A、B、C、D四个key对应的数据对象，经过哈希计算后，在环空间上的位置如下： 参考 一致性hash算法和应用 Redis Cluster深入与实践 MySQL索引知识点索引类型1. 从数据结构角度 B+树索引(O(nlogn)) hash索引：检索效率最高，仅能使用”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询和排序2. 从物理存储角度 聚簇索引 非聚簇索引 3. 从逻辑角度 主键索引 普通索引 复合索引 唯一索引 InnoDB B+Tree索引原理1. B+Tree数据结构 所有非叶子结点至多拥有两个儿子, 非叶子结点的左指针指向小于其关键字，右指针指向大于其关键字 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的指针自小而大顺序连接 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 2. InnoDB数据页结构 页是InnoDB存储引擎管理数据库的最小磁盘单位(16K) 叶子节点(页与页之间)是双向链表串起来的,头连上一页的尾，尾连下一页的头 每个数据页中有两个虚拟的行记录，用来限定记录的边界 页目录(Page Directory)通过顺序排放的 记录指针(也叫槽) 存放了记录的相对位置，通过这些槽找到具体的数据位置 3. 查询B+树索引的流程首先通过B+树索引找到叶节点，再找到对应的数据页，然后将数据页加载到内存中，通过二分查找页目录中的指针，查找出一个链表,然后就可以遍历这个链表找到具体的数据。 聚簇索引和非聚簇索引实现原理和区别区别 聚簇索引一般是为主键索引，一张表只能有一个聚簇索引，B+树的叶子节点存储了行数据和主键。 非聚簇索引可以有多个，叶节点除了包含关键字键值外还包含聚集索引的主键 非聚簇索引的查询流程先查到主键值，然后InnoDB再根据查到的主键值通过主键索引找到对应的数据块。 参考 MySQL InnoDB索引底层原理详解 Redis和Memcached的区别 Redis支持除key-value之外更多的数据类型 内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached 性能对比:由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis。结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡） 数据持久化和同步:memcache不支持，redis支持 网络IO模型方面：Memcached是多线程，分为监听线程、worker线程，引入锁，带来了性能损耗。Redis使用单线程的IO复用模型，将速度优势发挥到最大，也提供了较简单的计算功能 集群管理的不同:memcached只能通过分布式算法来实现Memcached的分布式存储，redis 高级版本redis Cluster在服务端做了支持，并且引入了Master节点和Slave节点，保证单点故障下的数据可用性 参考 redis和memcached的区别 进程、线程、协程(轻量级线程)和go中的Goroutine进程、线程 和 协程 之间概念的区别 需要区分进程、线程(内核级线程)、协程(用户态的轻量级的线程)三个概念 对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行抢占式调度（有多种调度算法） 对于协程(用户态的轻量级的线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的CPU控制权切换到其他进程/线程。通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。ps：所以说协程是不需要进行内核态的切换的。 goroutine 和协程区别本质上，goroutine 就是协程。不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程 。Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。 线程和协程的区别?一旦创建完线程，你就无法决定他什么时候获得时间片，什么时候让出时间片了，你把它交给了内核。而协程编写者可以有： 一是可控的切换时机 ， 二是很小的切换代价从操作系统有没有调度权上看，协程就是因为不需要进行内核态的切换，所以会使用它，会有这么个东西。这个定义相对准确： 协程－用户态的轻量级的线程 进程、线程、协程的联系与区别 进程是系统进行资源分配和调度的独立单位，也就是说不同进程拥有自己独立的堆和栈，既不共享堆也不共享栈 线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位，它拥有独立的栈和共享的堆。 协程又称”微线程”，它和线程一样拥有独立的栈和共享的堆。是由程序员调度的执行单元，它自带CPU上下文，当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到),这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程 区别和优缺点 一个程序至少拥有一个进程，一个进程至少拥有一个线程（主线程） 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 协程、线程不能够独立执行，必须依存在进程中，应当使用互斥锁机制来加以控制 进程之间可以通过MQ来传递数据，而线程、协程之间的全局变量是共享的 进程和线程都是由操作系统调度的，而协程的调度是用户(程序员)控制的 在IO操作密集型的程序使用协程可以很好的避免CPU的浪费，将CPU的资源主动让出给其他协程使用。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住 内存分配中的堆与栈程序中用来存放数据的内存分为四块: 全局区(静态区)（static）:全局变量和静态变量会存放在这里,程序结束时系统会释放这块资源. 文字常量区：我们定义的常量字符串就放在这块地方,也叫常量池，程序结束时系统会释放这块资源. 栈区（stack）：存放函数的参数和局部变量的值 .在进入作用域时分配内存空间，离开时就会释放这部分内存 堆区（heap） ： 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收。由于这个原因，在C和C++中就有能产生大量程序员分配但忘记释放的堆区内存，造成可使用内存越来越少，这个被称之为内存泄露.我们使用new进行实例化后分配的内存就在这部分区域 并行和并发区别 并行是指程序的运行状态，要有两个线程正在执行才能算是Parallelism；要在多核或者多处理器情况下才能做到。 并发指程序的逻辑结构 ，Concurrency则只要有两个以上线程还在执行过程中即可，不一定是多核处理器 参考：进程、线程、协程的联系与区别进程、线程、轻量级进程、协程和go中的Goroutine 那些事儿Golang协程详解内存分配中的堆与栈 TCP/IP协议考察：三次握手、四次挥手、为什么需要三次握手？为什么需要2MSL？ 参考 TCP/IP知识点 HTTP协议请求信息：1234567891011GET /s?wd=tinyint%20mysql%20%E8%8C%83%E5%9B%B4&amp;rsv_spt=1&amp;rsv_iqid=0xdc5b82ba0000f8f1&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=92821989_s_hao_pg&amp;rsv_enter=1&amp;rsv_sug3=1 HTTP/1.1Host: www.baidu.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,de;q=0.8,en;q=0.7Cookie: BAIDUID=112214E2FB5B1B92AE076721859B590F:FG=1; BIDUPSID=112214E2FB5B1B92AE076721859B590F; wd=tinyint%20mysql%20%E8%8C%83%E5%9B%B4&amp;rsv_spt=1&amp;rsv_iqid=0xdc5b82ba0000f8f1&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=92821989_s_hao_pg&amp;rsv_enter=1&amp;rsv_sug3=1 响应信息：12345678910111213141516171819202122HTTP/1.1 301 Moved PermanentlyServer: nginxDate: Mon, 26 Feb 2018 09:36:40 GMTContent-Encoding:gzipContent-Type: text/htmlset-cookie:sf_remember=1e055cc0983b652de8e2d2fd02ff068d; expires=Tue, 06-Mar-2018 02:25:12 GMT; Max-Age=604800; path=/Location: http://www.sina.com.cn/Expires: Mon, 26 Feb 2018 10:36:40 GMTCache-Control: max-age=3600Age: 14Content-Length: 122X-Cache: HIT from cnc.xidan.sinacache.24.nb.sinaedge.com＜html＞＜head＞＜title＞http＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞ http code与缓存层 200状态：当浏览器本地没有缓存或下一层失效时或用户点击CTRL+F5，直接去服务器下载最新数据 304状态：这一层由last-modify/etag控制。当下一层失效或用户点击F5时，浏览器会发送请求给服务器，如果服务端没有变化，则返回304给浏览器 ps:etag是对url进行标记，检测标记是否存在，但是由于分布式系统中各个机器生成的标记不同，所以一般会关闭掉 200(from cache)：这一层由expires/cache-control控制。 1. expires(http1.0版有效)是绝对时间。 2. cache-control(http1.1版本有效)，相对时间，两者都存在时，cache-control覆盖expires只要没有失效，浏览器只访问自己的缓存总结：expires和cache-control都是本地的缓存过期时间，缓存期不会请求服务端，last-modify会发生服务端的请求，检测服务端是否有更改。 关于 Cache-Control: max-age=秒 和 Expires 区别：Expires = 绝对时间，HTTP 1.0 版本，缓存的截止时间，允许客户端在这个时间之前不去检查（发请求）max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。 优缺点Expires 的缺点：返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。 Last-Modified：会发生服务器的请求在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过： If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT 如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。 注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求 HTTP状态码200 OK301 永久重定向302 临时重定向304 页面未修改 400 客户端请求参数有误401 未授权403 拒绝访问404 网页不存在 500 服务器内部未知错误502 错误的网关503 服务临时不可用504 网关超时 参考 http协议详解]]></content>
      <tags>
        <tag>面试</tag>
        <tag>一致性哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php面试题汇总(二)]]></title>
    <url>%2F2018-02-09-php-interview-question-2.html</url>
    <content type="text"><![CDATA[PHP面试题汇总 (二)文章内容主要参考：https://github.com/ycrao/mynotes 问题来源：http://tieba.baidu.com/p/3612369052http://blog.csdn.net/hyr352114576/article/details/49638345https://my.oschina.net/u/574366/blog/64814 for与foreach哪个更快?参考答案：http://www.cnblogs.com/niniwzw/archive/2008/06/03/1212535.html foreach 的效率要比 for 高很多，也许有很大的一个原因是 for 要进行很多次条件判断。所以以后能用 foreach 的地方就用 foreach ，可以提高1倍的效率。 如果循环内要调用函数，用 array_walk 最好，它的效率要比 for 高出1倍，要比 foreach 高出43%的效率。 PECL 和 PEAR 有什么区别？参考答案：http://jingyan.baidu.com/article/e9fb46e1a3eb277521f76619.html PECL (PHP Extension Community Library) 可以看作 PEAR (PHP Extension and Application Repository) 的一个组成部分，提供了与 PEAR 类似的功能。不同的是 PEAR 的所有扩展都是用纯粹的 PHP 代码编写的，用户在下载到 PEAR 扩展以后可以直接使用将扩展的代码包含到自己的 PHP 文件中使用。而 PECL 是使用 C 语言开发的，通常用于补充一些用 PHP 难以完成的底层功能，往往需要重新编译或者在配置文件中设置后才能在用户自己的代码中使用。 最直接的表述：PEAR 是 PHP 的上层扩展，PECL 是 PHP 的底层扩展。它们都是为特定的应用提供现成的函数或者类。 如何处理多服务器共享 Session ?参考答案：http://www.toutiao.com/a6294758409293086977/ 思路：引入统一session接入点 大致上有三种方式可以处理： 数据库/文件同步 session cookie 同步 session 缓存 (如 memcache ）同步 session 延伸：单独提供session服务，所有机器从这个服务获取session数据 推荐使用cache和数据库结合的实现方式，保证高效和稳定 什么是跨站脚本？SQL注入？1. 跨站脚本攻击的原理和防范 原理 XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意脚本代码，而程序对于用户输入内容未过滤，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而达到恶意攻击用户的特殊目的。 跨站脚本攻击的危害：窃取cookie、放蠕虫、网站钓鱼 … 跨站脚本攻击的分类主要有：存储型XSS、反射型XSS、DOM型XSS 防范：过滤非法字符(html,js,css)（strip_tags、htmlspecialchars） 2. SQL注入 原理SQL 注入是发生于应用程序数据库层的安全漏洞。用户输入的参数拼凑SQL查询语句，使用户可以控制SQL查询语句 防范：不要使用拼接的sql，使用占位符 使用预编译语句 检查数据类型 参考：http://blog.csdn.net/jbb0403/article/details/36626515http://www.cnblogs.com/ITtangtang/p/3982297.html 3. 跨站请求伪造（CSRF）攻击CSRF是Cross Site Request Forgery的缩写，乍一看和XSS差不多的样子，但是其原理正好相反，XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求 原理 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成以下两个步骤：1. 登录受信任网站A，并在本地生成Cookie。2. 在不登出A的情况下，访问危险网站B。 CSRF如何防御 验证HTTP Referer字段 添加token验证 验证码 尽量使用POST，限制GET 在HTTP头部添加自定义属性 参考： WEB安全之-CSRF（跨站请求伪造） 描述一下大流量高并发量网站的解决方案 确认服务器硬件是否足够支持当前的流量。 使用 memcache或redis 缓存技术，将动态数据缓存到文件中，动态网页直接调用这些文件，而不必在访问数据库。 禁止外部的盗链。外部网站的图片或者文件盗链往往会带来大量的负载压力，因此应该严格限制外部对自身图片或者文件盗链，可以通过apache的URL重定向来防止盗链。 控制大文件的下载。大文件的下载会占用很大的流量，对于非SCSI硬盘来说会消耗，使得网站响应能力下降。 使用不同的主机分流主要流量。 使用流量统计软件。在网站上安装一个流量统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化。 如何防盗链参考引用: https://yq.aliyun.com/articles/57931 设置Referer（原理：判断来源地址是否与白名单地址匹配） 签名URL(原理：签名URL，增加url的有效时间) PHP内存管理机制与垃圾回收机制参考答案：http://www.cnblogs.com/zk0533/p/5667122.html php 的内存管理机制是：预先给出一块空间，用来存储变量，当空间不够时，再申请一块新的空间。 存储变量名，存在符号表。 变量值存储在内存空间。 在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小。 php 垃圾回收机制是： 在5.2版本或之前版本，PHP会根据 引用计数 （ refcount ）值来判断是不是垃圾，如果refcount值为0，PHP会当做垃圾释放掉，这种回收机制有缺陷，对于环状引用的变量无法回收。 在5.3之后版本改进了垃圾回收机制。具体如下： 如果发现一个 zval 容器中的 refcount 在增加，说明不是垃圾；如果发现一个 zval 容器中的 refcount 在减少，如果减到了0，直接当做垃圾回收；如果发现一个 zval 容器中的 refcount 在减少，并没有减到0，PHP 会把该值放到缓冲区，当做有可能是垃圾的怀疑对象；当缓冲区达到了临界值，PHP 会自动调用一个方法去遍历每一个值，如果发现是垃圾就清理。 理解php内核中SAPI的作用SAPI: Server Application Programming Interface 服务器端应用编程端口。先看一张php模块图各种应用都是通过对应的SAPI与php进行交互的，SAPI相当于一个接口，使得php的核心实现不用关心各个应用交互的细节。虽然通过Web服务器和命令行程序执行脚本看起来很不一样，实际上它们的工作流程是一样的通过cgi和cli模式下read_cookies的不同实现，可以看出sapi确实对下层php屏蔽了交互细节，当下层php核心要读取用户cookies时，只需要通过sapi_module_struct-&gt;read_cookies，而不需要关注上层应用的交互细节 参考： 理解php内核中SAPI的作用 为什么要对数据库进行主从分离?参考答案：https://my.oschina.net/candiesyangyang/blog/203425 读写服务器可单独优化，提高可用性 降低写服务器压力 主从只负责各自的写和读，极大程度的缓解X锁和S锁争用，提高并发性 延伸：什么是X锁和S锁？ 共享锁(S锁Share Locks)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排它锁：排它锁又称为写锁（(eXclusive lock,简记为X锁)），若事物T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。 多线程和多进程的区别为？参考答案： http://www.cnblogs.com/kaituorensheng/p/3603057.html https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319292979766bd3285c9d6b4942a8ea9b4e9cfb48d8000 进程是资源分配的最小单位，线程是CPU调度的最小单位 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 相同点：进程线程间切换都会消耗系统资源 ps： 进程可靠性高原因：比如fork多个子进程，单独某个进程出现问题，不影响其他进程，而多个子线程如果某个子线程挂了可能导致整个进程挂掉 TCP/IP 网络协议，OSI 7 层指是什么？参考答案：http://blog.csdn.net/jenminzhang/article/details/47017741 TCP/IP 5层 指的是： 12345678910应用层HTTP、FTP、SMTP、DNS、DSP、Telnet、Gopher、WAIS……传输层TCP、UDP、DVP……网络层IP、ICMP、AKP、RARP、UUCP……接口层Ethernet、Arpanet、PDN……物理层只要能传输IP数据报（Datagram），允许任何协议…… OSI 7层指的是： 1234567应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet表示层 数据格式化，代码转换，数据加密 没有协议会话层 解除或建立与别的接点的联系 没有协议传输层 提供端对端的接口 TCP，UDP网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 TCP/IP知识点参考：https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html 三次握手第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。 常见问题1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误，造成资源浪费。 2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？建立连接时候ACK和SYN可以放到一个报文发送，而关闭连接时被动方可能未全部完成数据的发送，所以ACK和SYN回分两次发送。 3. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 CGI/FastCGI/php-fpm和nginx通信原理cgi、fast-cgi协议 cgi的历史 早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像PHP等动态语言。webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？ 为了解决不同的语言解释器(如php、Python解释器)与webserver的通信，于是出现了cgi协议。只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。 fast-cgi的改进 有了cgi协议，解决了php解释器与webserver通信的问题，webserver终于可以处理动态语言了。但是，webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程。这样有10000个请求，就需要fork、kill php-cgi进程10000次。 有没有发现很浪费资源？ 于是，出现了cgi的改良版本，fast-cgi。fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。 php-fpm是什么 php-fpm即php-Fastcgi Process Manager.php-fpm是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种进程。master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。 nginx和php-fpm运行原理和流程Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpmwww.example.com| | Nginx| | 路由到www.example.com/index.php| | 加载nginx的fast-cgi模块| | fast-cgi监听127.0.0.1:9000地址| | www.example.com/index.php请求到达127.0.0.1:9000| | php-fpm 监听127.0.0.1:9000| | php-fpm 接收到请求，启用worker进程处理请求| | php-fpm 处理完请求，返回给nginx| | nginx将结果通过http返回给浏览器 参考 Nginx+PHP-fpm运行原理详解 PHP路由技术的原理与实践路由实现原理用户通过指定的URL范式对后台进行访问，URL路由处理类进行处理后，转发给逻辑处理类，逻辑处理类将请求结果返回给用户。 URL范式和规则 一般为对搜索引擎友好，对用户友好的URL规则，比较流行的有两种：普通模式和pathinfo模式 普通模式在 ThinkPHP 框架中，默认的URL格式即为普通模式，普通模式URL如下:index.php?m=home&amp;c=user&amp;a=login&amp;v=value其中 m 参数的值为模块名称， c 参数的值为控制器名称， a 参数的值为方法名称，之后的参数则为该方法中所要接收的其他 GET 请求参数 pathinfo模式在 CodeIgniter 框架中，默认的URL格式为 pathinfo 模式，如下：index.php/controller/method/prarme1/value1在 method 以后，就是方法接收的 GET 参数了，格式就是 名称/值 URL路由处理类以index.php?c=user&amp;a=login&amp;v=value普通模式为例，URL路由处理类主要完成对控制器类和方法的加载和判断是否存在，有则执行，没有则报错。123456789101112131415161718192021&lt;?phpinclude 'index.class.php';include 'user.class.php';// 对用户请求URL进行处理$query = $_GET;$controller = isset($query['c']) ? $query['c'] : 'indexController';$action = isset($query['a']) ? $query['a'] : 'index';if (class_exists($controller)) &#123; if (method_exists($controller, $action)) &#123; unset($_GET['c']); unset($_GET['a']); // 实例化用户请求类并调用方法 (new $controller())-&gt;$action(); &#125; else &#123; echo '控制器' . $controller . '中不存在方法' . $action; &#125;&#125; else &#123; echo '不存在控制器' . $controller;&#125; 其中 unset() 掉两个get参数，只是为了对真正调用的方法造成其他影响。 逻辑处理类逻辑处理类就是最终的业务逻辑，也就是真正的回应用户请求的代码片段。1234567891011121314151617181920/* index.class.php 文件源码 */&lt;?phpclass indexController &#123; public function index()&#123; var_dump($_GET); &#125;&#125;/* user.class.php 文件源码 */&lt;?phpclass user &#123; public function index() &#123; echo '这里是User控制器'; &#125; public function login() &#123; var_dump($_GET); &#125;&#125; nginx配置location总结 语法规则 已=开头表示精确匹配如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。 ^~ 开头表示uri以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配 / 通用匹配, 如果没有其它匹配,任何请求都会匹配到 匹配顺序 首先匹配 = 其次匹配 ^~ 其次是按文件中顺序的正则匹配 ~ 最后是交给 / 通用匹配 当有匹配成功时候，停止匹配，按当前匹配规则处理请求 nginx支持PHP的PATHINFO模式配置 要求解析http://www.test.com/admin/index.php/myModule/myController/myAction?key1=val1&amp;key2=val2,使通过$_SERVER可以获取如下键值： 12345678910$_GET = array ( 'key1' =&gt; 'val1', 'key2' =&gt; 'val2', )$_SERVER = array( 'PATH_INFO' =&gt; '/myModule/myController/myAction', 'SCRIPT_FILENAME' =&gt; '/Data/code/workt/admin/index.php', 'SCRIPT_NAME' =&gt; '/admin/index.php', ...) 实现：使用nginx的fastcgi_split_path_info指令，具体配置如下 12345678910111213141516171819202122232425262728##匹配nginx需要交给php-fpm执行的URI，先要允许pathinfo格式的URL能够被匹配到##所以要去掉$##nginx文档中的匹配规则为：^(.+\.php)(.*)$##还有~ \.php这种写法 和 ~ \.php($|/)这种写法##都是差不多意思没啥严格区别##唯一区别就是有多个匹配php的location的话需要留意权重差异location ~ ^(.+\.php)(.*)$ &#123; root /var/www/www.jjonline.cn/wwwRoot; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; ##增加 fastcgi_split_path_info指令，将URI匹配成PHP脚本的URI和pathinfo两个变量 ##即$fastcgi_script_name 和$fastcgi_path_info fastcgi_split_path_info ^(.+\.php)(.*)$; ##PHP中要能读取到pathinfo这个变量 ##就要通过fastcgi_param指令将fastcgi_split_path_info指令匹配到的pathinfo部分赋值给PATH_INFO ##这样PHP中$_SERVER['PATH_INFO']才会存在值 fastcgi_param PATH_INFO $fastcgi_path_info; ##在将这个请求的URI匹配完毕后，检查这个绝对地址的PHP脚本文件是否存在 ##如果这个PHP脚本文件不存在就不用交给php-fpm来执行了 ##否者页面将出现由php-fpm返回的:`File not found.`的提示 if (!-e $document_root$fastcgi_script_name) &#123; ##此处直接返回404错误 ##你也可以rewrite 到新地址去，然后break; return 404; &#125; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 参考： PHP路由技术的原理与实践 Nginx支持PHP的PATHINFO模式配置分析 nginx配置location总结及rewrite规则写法]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试题汇总(一)]]></title>
    <url>%2F2018-02-09-php-Interview-question-1.html</url>
    <content type="text"><![CDATA[PHP面试题汇总(基础)文章内容主要参考：https://github.com/ycrao/mynotes 1. echo(),print(),print_r()的区别？三者均可以输出信息，但是各有自己的特点： 类型 输出变量个数 输出变量类型 返回值 速度 echo 语言结构 一个或多个 简单类型变量，如int、string 无 最快 print 语言结构 一个 简单类型变量，如int、string int 快 print_r 函数 一个 复杂类型，如数组、对象 bool 慢 2. 语句include和require的区别是什么?在失败的时候： include 产生一个 warning ，而 require 直接产生错误中断； require 在运行前载入； include 在运行时载入； require_once 和 include_once 可以避免重复包含同一文件。 3. php中传值与传引用有啥区别?&amp;表示传引用；函数中参数传引用会将参数进行改变；一般在输出参数有多个的时候可以考虑使用引用。 123456$num = 10function multiply(&amp;$num)&#123; $num = $num * 10;&#125;multiply($num);echo $num; 4. 下面哪项没有将john添加到users数组中？1234(a) $users[] = &apos;john&apos;;(b) array_add($users,&apos;john&apos;);(c) array_push($users,&apos;john&apos;);(d) $users ||= &apos;john&apos;; 答案为bd，php 里面无 array_add 函数，d项为语法错误的表达。 5. HTTP协议中几个状态码的含义。123456789101112200 OK 客户端请求成功301 Moved Permanently 请求永久重定向302 Moved Temporarily 请求临时重定向304 Not Modified 文件未修改，可以直接使用缓存的文件。400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden 服务器拒绝执行请求，即没有权限404 Not Found 请求的资源不存在，例如，输入了错误的URL500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。502 Bad Gateway 错误的网关，上游服务器错误(如php-fpm挂掉了)503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。504 Gateway Timeout 网关超时（上游服务器超时） 参考：HTTP状态码详解502 VS 504 6. 写出一些php魔术方法。1234567891011121314__construct() 实例化类时自动调用。__destruct() 类对象使用结束时自动调用。__set() 在给未定义的属性赋值的时候调用。__get() 调用未定义的属性时候调用。__isset() 使用isset()或empty()函数时候会调用。__unset() 使用unset()时候会调用。__sleep() 使用serialize序列化时候调用。__wakeup() 使用unserialize反序列化的时候调用。__call() 调用一个不存在的方法的时候调用。__callStatic()调用一个不存在的静态方法是调用。__toString() 把对象转换成字符串的时候会调用。比如 echo。__invoke() 当尝试把对象当方法调用时调用。__set_state() 当使用var_export()函数时候调用。接受一个数组参数。__clone() 当使用clone复制一个对象时候调用。 7. MySQL存储引擎 MyISAM 和 InnoDB 的区别 MyISAM InnoDB 构成上的区别 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。 数据文件的扩展名为.MYD (MYData)。 索引文件的扩展名是.MYI (MYIndex)。 基于磁盘的资源是InnoDB表空间数据文件(.frm和它的日志文件(.ibd)，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB 事务处理上方面 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持 InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能 SELECT UPDATE,INSERT，Delete操作 如果执行大量的SELECT，MyISAM是更好的选择 1.如果你的数据执行大量的INSERT**或**UPDATE，出于性能方面的考虑，应该使用InnoDB表 2.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 3.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用 AUTO_INCREMENT类型的字段 在MyISAM表中，可以和其他字段一起建立联合索引 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引 表的具体行数 select count() from table,MyISAM只要简单的读出保存好的行数，注意的是，当count()语句包含 where条件时，两种表的操作是一样的 InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行 锁 表锁 提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%” 8. 说出一些MySQL优化方法？1234567a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e. 添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 9. 下面$r的结果是：123456&lt;?php$a = in_array('01', array('1')); // true$a1 = in_array('01', array('1'), true); // false $b = '01' == 1; // true$b1 = '02' == 1; // false$r = $a == $b A trueB false 答案为A 10. 说下php中empty()和isset()的区别。 Expression gettype() empty() is_null() isset() boolean : if($x) $x = “”; string TRUE FALSE TRUE FALSE $x = null; NULL TRUE TRUE FALSE FALSE var $x; NULL TRUE TRUE FALSE FALSE $x is undefined NULL TRUE TRUE FALSE FALSE $x = array(); array TRUE FALSE TRUE FALSE $x = array(‘a’, ‘b’); array FALSE FALSE TRUE TRUE $x = false; boolean TRUE FALSE TRUE FALSE $x = true; boolean FALSE FALSE TRUE TRUE $x = 1; integer FALSE FALSE TRUE TRUE $x = 42; integer FALSE FALSE TRUE TRUE $x = 0; integer TRUE FALSE TRUE FALSE $x = -1; integer FALSE FALSE TRUE TRUE $x = “1”; string FALSE FALSE TRUE TRUE $x = “0”; string TRUE FALSE TRUE FALSE $x = “-1”; string FALSE FALSE TRUE TRUE $x = “php”; string FALSE FALSE TRUE TRUE $x = “true”; string FALSE FALSE TRUE TRUE $x = “false”; string FALSE FALSE TRUE TRUE 引用：PHP 类型比较表 isset 用于检测变量是否被设置，使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE 。empty 如果 var 是非空或非零的值，则 empty() 返回 FALSE。换句话说，&quot;&quot;、0、&quot;0&quot;、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE 。 如果变量为 0 ，则empty()会返回TRUE，isset()会返回TRUE；如果变量为空字符串，则empty()会返回TRUE，isset()会返回TRUE；如果变量未定义，则empty()会返回TRUE，isset()会返回FLASE。 注意：isset() 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已设置，可使用 defined() 函数。当要 判断一个变量是否已经声明的时候 可以使用 isset 函数；当要 判断一个变量是否已经赋予数据且不为空 可以用 empty函数；当要 判断 一个变量 存在且不为空 先 isset 函数 再用 empty 函数； 11. cookie和session的区别、cookie禁用后session还可以用吗？工作流程： 以下以PHP为例： 你第一次访问网站时， 服务端脚本中开启了Sessionsession_start();， 服务器会生成一个不重复的 SESSIONID 的文件session_id();，比如在/var/lib/php/session目录 并将返回(Response)如下的HTTP头 Set-Cookie:PHPSESSIONID=xxxxxxx 客户端接收到Set-Cookie的头，将PHPSESSIONID写入cookie 当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端 服务器识别PHPSESSIONID这个cookie，然后去session目录查找对应session文件， 找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置 区别： 1、cookie就是服务器发放给客户端的一些标识，保存在客户端，让客户端每次请求的时候带上，以区分不同的用户； 2、session是服务器存放在自己那里的用户相关的数据，用每次用户带来的cookie去提取出来，恢复一个之前访问的历史或者相关环境。 3、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie 参考： https://segmentfault.com/q/1010000007715137 http://blog.csdn.net/baidu_31337243/article/details/48954445 12. 说出常用的10个数组方法in_array(判断数组中是否有某个元素)var_dump(in_array(0, array(false, 1))) //true implode(将数组按照一定规律分解) json_encode(将数组转化成json) sort(排序，有很多排序的函数这里就说一个) array_push(将一个活多个单元压入数组的末尾) array_merge（合并数组） array_key_exists(检查键名是否存在于数组中) array_unique(去除数组中重复的值，只能对一位数组起作用) array_shift（移除数组中第一个单元） 13. 说出平时常用的操作字符串的方法，并解决具体问题substr(截取字符串) strlen(获取字符串长度) strpos(查找字符串首次出现的位置) str_replace(字符串替换) explode(字符串拆分转数组)implode(数组拼接转字符串) strtoupper(将所有字母变成大写) strtolower ucfirst(将字符串的首字母变成大写) ucwords（将字符串中每个单词的首字母变成大写） strrev(反转字符串，其实不是很常用) substr_replace(替换字符串的子串，注意与str_replace的区别) strip_tags（去除html和php标记，可以选择保留想要的标签） trim(去除空格) 正则表达式贪婪模式与非贪婪模式默认情况下，正则表达式会采用贪婪模式，使用?或U修饰符可以实现非贪婪模式。比如a后面有多个b，”abbbbbbbb”。默认/a.+/则会匹配到最后一个b， 123456789&lt;?php$pattern1 = '/a.+/';$pattern2 = '/a.+?/';$subject = 'abbbbbbbbb';$matches = array();var_dump(preg_match($pattern1, $subject,$matches));var_dump($matches);var_dump(preg_match($pattern2, $subject,$matches));var_dump($matches); 运行结果：12345678910int(1)array(1) &#123; [0]=&gt; string(10) "abbbbbbbbb"&#125;int(1)array(1) &#123; [0]=&gt; string(2) "ab"&#125; preg_match和preg_match_all区别用法都是相同的：func($pattern, $subject, &amp;$matches, $flags, $offset)返回值：正确匹配返回1，否则返回0不同：preg_match会使用$pattern对subject进行一次匹配，subject有多个子串也满足$pattern，matches也只会返回第一个子组的所有匹配结果，preg_match_all则会执行全局正则表达式匹配。1234567&lt;?php $pattern = "|&lt;[^&gt;]+&gt;(.*)&lt;/[^&gt;]+&gt;|U"; $subject = "&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;this is a test&lt;/div&gt;"; preg_match($pattern, $subject, $matches); var_dump($matches); preg_match_all($pattern, $subject, $matches); var_dump($matches); 运行结果：1234567891011121314151617181920212223array(2) &#123;//第一组 [0]=&gt; string(16) "&lt;b&gt;example: &lt;/b&gt;" [1]=&gt; string(9) "example: "&#125;array(2) &#123; [0]=&gt; array(2) &#123;//全局完全匹配 [0]=&gt; string(16) "&lt;b&gt;example: &lt;/b&gt;" [1]=&gt; string(36) "&lt;div align=left&gt;this is a test&lt;/div&gt;" &#125; [1]=&gt; array(2) &#123; [0]=&gt; string(9) "example: "//匹配的子组 [1]=&gt; string(14) "this is a test"//匹配的子组 &#125;&#125; 常用正则表达式123456789101112131415161718192021网址（URL） [a-zA-z]+://[^\s]*IP地址(IP Address) ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)电子邮件(Email) \w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*QQ号码 [1-9]\d&#123;4,&#125;HTML标记(包含内容或自闭合) &lt;(.*)(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上) (?=^.&#123;8,&#125;$)(?=.*\d)(?=.*\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\n).*$日期(年-月-日) (\d&#123;4&#125;|\d&#123;2&#125;)-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))日期(月/日/年) ((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d&#123;4&#125;|\d&#123;2&#125;)时间(小时:分钟, 24小时制) ((1|0?)[0-9]|2[0-3]):([0-5][0-9])汉字(字符) [\u4e00-\u9fa5]中文及全角标点符号(字符) [\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]中国大陆固定电话号码 (\d&#123;4&#125;-|\d&#123;3&#125;-)?(\d&#123;8&#125;|\d&#123;7&#125;)中国大陆手机号码 1\d&#123;10&#125;中国大陆邮政编码 [1-9]\d&#123;5&#125;中国大陆身份证号(15位或18位) \d&#123;15&#125;(\d\d[0-9xX])?非负整数(正整数或零) \d+正整数 [0-9]*[1-9][0-9]*负整数 -[0-9]*[1-9][0-9]*整数 -?\d+小数 (-?\d+)(\.\d+)?不包含abc的单词 \b((?!abc)\w)+\b 参考 正则表达式知识点]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议详解]]></title>
    <url>%2F2018-02-09-http.html</url>
    <content type="text"><![CDATA[http headers头部字段General12345Request URL:http://www.cnblogs.com/sunny-sl/p/6529830.htmlRequest Method:GETStatus Code:200 OKRemote Address:42.121.252.58:80Referrer Policy:origin Response Headers1234567891011Cache-Control:private, max-age=10Connection:keep-aliveContent-Encoding:gzipContent-Type:text/html; charset=utf-8Date:Fri, 09 Feb 2018 00:35:07 GMTExpires:Fri, 09 Feb 2018 00:35:17 GMTLast-Modified:Fri, 09 Feb 2018 00:35:07 GMTTransfer-Encoding:chunkedVary:Accept-EncodingX-Frame-Options:SAMEORIGINX-UA-Compatible:IE=10 Request Headers1234567891011Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding:gzip, deflateAccept-Language:zh-CN,zh;q=0.9,de;q=0.8,en;q=0.7Cache-Control:max-age=0Connection:keep-aliveCookie:Hm_lvt_cc17b07fc9529e3d80b4482c9ce09086=1503727633; __utma=226521935.1803516701.1504280386.1504280386.1504280386.1; __utmz=226521935.1504280386.1.1.utmccn=(referral)|utmcsr=google.com.au|utmcct=/|utmcmd=referral; pgv_pvi=3195154432; Host:www.cnblogs.comIf-Modified-Since:Fri, 09 Feb 2018 00:23:55 GMTReferer:https://www.google.com/Upgrade-Insecure-Requests:1User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Accept的含义 如Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5表示的含义是什么？ application / xml ， application / xhtml + xml和image / png是首选媒体类型，但如果它们不存在，则发送文本/ html实体（ text/html;q=0.9 ），如果不存在，则发送文本/普通实体（ text/plain;q=0.8 ），如果不存在，则发送具有任何其他媒体类型（ /;q=0.5 ） 常见的Content-type(mime)类型 text/html application/xml application/json application/x-www-form-urlencoded 最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据。 传递的key/val会经过URL转码，所以如果传递的参数存在中文或者特殊字符需要注意 multipart/form-data 使用表单上传文件时，必须让 form 的 enctyped 等于这个值 text/plain image/pngkeep-alive模式HTTP的短连接&amp;长连接 短连接：每次请求一个资源就建立连接，请求完成后连接立马关闭。每次请求都经过“创建tcp连接-&gt;请求资源-&gt;响应资源-&gt;释放连接”这样的过程 长连接(persistent connection)：只建立一次连接，多次资源请求都复用该连接，完成后关闭。要请求一个页面上的十张图，只需要建立一次tcp连接，然后依次请求十张图，等待资源响应，释放连接 并行连接(multiple connections)，其实就是并发的短连接 client和server keep-alive模式访问流程 client发出的HTTP请求头需要增加Connection:keep-alive字段 Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且”应允”client我暂时不会关闭socket连接注意： 在HTTP/1.0里，为了实现client到web-server能支持长连接，必须在HTTP请求头里显示指定Connection:keep-alive 在HTTP/1.1里，就默认是开启了keep-alive，要关闭keep-alive需要在HTTP请求头里显示指定Connection:close ####Keep-Alive选项 用法：Keep-Alive: name[=value][, name=[value]]…完全可选，但只有在包含了Connection: Keep-Alive首部的情况下才可使用它。 参数timeout：在Keep-Alive响应首部中发送，告诉客户端服务器估计会在打开状态保持到连接空闲多长时间后关闭连接。 参数max：在Keep-Alive响应首部中发送，告诉客户端服务器还会为另外几个http事务将连接保持在打开状态。注意，这两个参数值仅仅是估计，并非承诺。 例如：12Connection: Keep-AliveKeep-Alive: max=5, timeout=120 说明服务器最多还会为另外5个事务保持连接在打开状态，或者将打开状态保持到连接空闲了2两分钟后关闭。参考： 理解HTTP之keep-alive http持久连接-keep alive和persistent 缓存 http code与缓存层 200状态：当浏览器本地没有缓存或下一层失效时或用户点击CTRL+F5，直接去服务器下载最新数据 304状态：这一层由last-modify/etag控制。当下一层失效或用户点击F5时，浏览器会发送请求给服务器，如果服务端没有变化，则返回304给浏览器 200(from cache)：这一层由expires/cache-control控制。 1. expires(http1.0版有效)是绝对时间。 2. cache-control(http1.1版本有效)，相对时间，两者都存在时，cache-control覆盖expires只要没有失效，浏览器只访问自己的缓存Last-Modified在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过： If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT 如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。 注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求 Etag工作原理HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：Etag:“5d8c72a5edda8d6a:3239″ 客户端的查询更新格式是这样的：If-None-Match:“5d8c72a5edda8d6a:3239″如果ETag没改变，则返回状态304。 Expires给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT 需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。 Last-Modified和ExpiresLast-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。 Etag和Expires如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304. Last-Modified和Etag分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败 分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样) Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存 过程如下: 1.客户端请求一个页面（A）。 2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。 3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 注： 1、Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。 2、WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头； 3、客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样； 4、通过上述值到服务器端检查，判断文件是否继续缓存； 关于 Cache-Control: max-age=秒 和 ExpiresExpires = 时间，HTTP 1.0 版本，缓存的截止时间，允许客户端在这个时间之前不去检查（发请求）max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。 Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。 Expires =max-age + “每次下载时的当前的request时间” 所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 http/2.0与http/1.1区别1.什么是HTTP/2HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。 2.与HTTP/1相比，主要区别包括 HTTP/2采用二进制格式而非文本格式 HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行 使用报头压缩，HTTP/2降低了开销 HTTP/2让服务器可以将响应主动“推送”到客户端缓存中 HTTP/2为什么是二进制？比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。 为什么 HTTP/2 需要多路传输?HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。 消息头为什么需要压缩?假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。 服务器推送的好处是什么？当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。 参考 HTTP缓存控制小结 HTTP常见Content-Type比较 http/2.0与http/1.1区别 浏览器缓存详解:expires,cache-control,last-modified,etag详细说明]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳跃表算法]]></title>
    <url>%2F2018-02-09-algorithm-skip-list.html</url>
    <content type="text"><![CDATA[跳跃表(skip-list)算法 它允许快速查询一个有序连续元素的数据链表，它的效率可以做到和二分相同，都是O(logn)的平均时间复杂度，其空间复杂度为O(n) 跳跃表的性质 由很多层结构组成； 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点； 最底层的链表包含了所有的元素 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集） 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点 层数如何确定跳跃表的层数跟结构中最高节点的高度相同。理想情况下，跳跃表结构中第一层中存在所有的节点，第二层只有一半的节点，而且是均匀间隔，第三层则存在1/4的节点，并且是均匀间隔的，以此类推，这样理想的层数就是logN。 搜索其基本原理就是从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。 ps:遇到37后同一层的下一个节点为边界节点，所以只能往下一层比较继续查找了 插入首先需要确定插入的层数（使用掷硬币的方法，正面累加，反面停止）,当确定好要插入的层数以后，则需要将元素都插入到从最底层到第k层 删除在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。 参考：跳跃表原理和实现]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis和memcached的区别]]></title>
    <url>%2F2018-02-09-redis-memecached-diff.html</url>
    <content type="text"><![CDATA[Redis和Memcached的区别 redis作者对这两种基于内存数据存储系统进行的比较： Redis支持除key-value之外更多的数据类型 内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached 性能对比:由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis。结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡） 数据持久化和同步:memcache不支持，redis支持 网络IO模型方面：Memcached是多线程，分为监听线程、worker线程，引入锁，带来了性能损耗。Redis使用单线程的IO复用模型，将速度优势发挥到最大，也提供了较简单的计算功能 1. 数据类型支持不同与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis内部使用一个redisObject对象来表示所有的key和value，主要信息如图： RedisObject属性 类型(type)：代表一个value对象具体是何种数据类型:string, hash, list, set, sorted set 编码(encoding)：是不同数据类型在redis内部的存储方式, 比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int， 如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的， 当然前提是这个字符串本身可以用数值表示，比如:”123″ “456”这样的字符串。 数据指针(ptr)： 虚拟内存(vm)：只有打开了Redis的虚拟内存功能，vm字段字段才会真正的分配内存，该功能默认是关闭状态的 其他(other) 常用数据类型1. String 常用命令：set/get/decr/incr/mget等； 应用场景：String是最常用的一种数据类型，普通的key/value存储都可以归为此类； 实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。 2. Hash 常用命令：hget/hset/hgetall等 应用场景：我们要存储一个用户信息对象数据，其中包括用户ID、用户姓名、年龄和生日，通过用户ID我们希望获取该用户的姓名或者年龄或者生日； 实现方式：Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。如图所示，Key是用户ID, value是一个Map。这个Map的key是成员的属性名，value是属性值。这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据。 当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。 3. List 常用命令：lpush/rpush/lpop/rpop/lrange等； 应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现； 实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。 4. Set 常用命令：sadd/spop/smembers/sunion等； 应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的； 实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 5. Sorted Set 常用命令：zadd/zrange/zrem/zcard等； 应用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 扩展知识：跳跃表跳跃表的性质 由很多层结构组成； 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点； 最底层的链表包含了所有的元素 搜索 其基本原理就是从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。 ps:遇到37后同一层的下一个节点为边界节点，所以只能往下一层比较继续查找了 参考：跳跃表原理和实现 2. 内存管理机制不同3. 数据持久化支持Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。而memcached是不支持数据持久化操作的 4. 集群管理的不同Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质 Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。 当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。 Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。 相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。 下图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER Redis Cluster引入了Master节点和Slave节点 为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点 参考 Redis原理和应用场景 Redis和Memcached的区别 Redis Clusterredis集群的几种实现方式如下： 客户端分片，如redis的Java客户端jedis也是支持的，使用一致性hash 基于代理的分片，如codis和Twemproxy 路由查询， redis-cluster 参考： Redis Cluster深入与实践]]></content>
      <tags>
        <tag>redis</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性hash算法和应用]]></title>
    <url>%2F2018-02-08-algorithm-consistent-hashing.html</url>
    <content type="text"><![CDATA[一致性HASH原理和应用 问题：单机redis20G如何承载500G的cache（考虑redis集群应用） 应用场景如何对请求与缓存服务器之间进行精准映射,以及优雅的扩展，剔除缓存服务器，提升缓存服务的容错性和扩展性 容错性：指当系统中某一个或几个服务器变得不可用时，整个系统是否可以正确高效运行； 扩展性：指当加入新的服务器后，整个系统是否可以正确高效运行。 算法概述一致性哈希将整个哈希空间组织成一个虚拟的圆环，假如整个哈希函数的值空间为0 - 2^32 -1(一个32位的无符号整形)，如下图:整个空间按顺时针方向组织,0和2^32-1在零点中方向重合 第一步：在哈希闭环中确定各台服务器位置 将各台服务器的ip或主机名为关键字通过H函数得到一个哈希值，然后在哈希闭环中标注位置。如下图3台redis服务： 第二步：定位数据访问的服务器 将数据key使用相同的函数H计算出哈希值h，通根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器 例如我们缓存服务器中有A、B、C、D四个key对应的数据对象，经过哈希计算后，在环空间上的位置如下： 容错性与可扩展性分析 假设redis-2宕机：ACD节点并不受影响，只有B节点被重定向至Redis-0 如果我们在系统中增加一台服务器Redis-3 Server：对于C这个key，重新定位至Redis-3 服务器，其他非C的key均不受影响 数据倾斜问题1. 问题概述 一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，必然造成大量数据集中到Redis-1上，而只有极少量会定位到Redis-0上。如下图 2. 使用虚拟节点解决 对每一个服务节点多计算N个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布 第一步：为每个机器多增加N个虚拟节点 为每个机器多计算三个虚拟节点，分别计算“Redis-1 #1”、“Redis-1 #2”、“Redis-1 #3”、“Redis-0 #1”、“Redis-0 #2”、“Redis-0 #3”的哈希值，于是形成六个虚拟节点: 第二步：将虚拟节点映射到实际节点 数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Redis-1#1”、“Redis-1#2”、“Redis-1#3”三个虚拟节点的数据均定位到Redis-1上 参考一致性哈希算法在分布式缓存中的应用]]></content>
      <tags>
        <tag>一致性HASH</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CURL用法]]></title>
    <url>%2F2018-02-08-curl-usage.html</url>
    <content type="text"><![CDATA[选项 -w 从文件中读取要打印信息的格式 -o /dev/null：把响应的内容丢弃，因为我们这里并不关心它，只关心请求的耗时情况 -s 不要打印进度条 -L 页面使用了301重定向，这时我们可以添加-L参数来跟踪URL重定向 -i --include 查看头信息, 页面响应头会和页面源码（响应体）一起返回 -I --head 只返回头信息不返回页面源码 -X 指定请求方法，配合--data添加提交数据 --data 添加提交数据,格式:”a=a1&amp;b=b1” -H --header 来指定请求头:curl -H &#39;Content-Type:application/json&#39; -H &#39;Authorization: bearer eyJhbGciOiJIUzI1NiJ9&#39; itbilu.com 请求耗时查看使用curl -w命令配置文件新建curl-format.txt文件，内容为：12345678time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\n ----------\n time_total: %&#123;time_total&#125;\n 使用123456789curl -w "@curl-format.txt" -o /dev/null -s -L "http://cizixs.com"time_namelookup: 0.012 time_connect: 0.227 time_appconnect: 0.000 time_redirect: 0.000 time_pretransfer: 0.227 time_starttransfer: 0.443 ---------- time_total: 0.867 使用httpstat命令安装pip install httpstat 使用12345# 默认请求httpstat www.baidu.com# form表单提交httpstat www.baidu.com -XPOST --data "a=a1&amp;b=b1" 参考curl 命令行工具的使用及命令参数说明使用 curl 命令分析请求的耗时情况httpstat工具]]></content>
      <tags>
        <tag>curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL InnoDB索引底层原理详解]]></title>
    <url>%2F2018-02-07-mysql-innodb-index.html</url>
    <content type="text"><![CDATA[MySQL的索引类型从数据结构角度 B+树索引(O(nlogn)) hash索引： 仅仅能够满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询, 无法通过操作索引来排序 检索效率最高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引 不能避免全表扫描,当存在大量相同hash值得时候，hash索引的效率会变低 FULLTEXT索引:支持full-text的字段只有char、varchar、text数据类型, 主要是用来代替like “%*%”效率低下的问题 从物理存储角度 聚簇索引（clustered index） 非聚簇索引（non-clustered index） 从逻辑角度 主键索引(PRIMARY)：主键索引是一种特殊的唯一索引，不允许有空值 普通索引(NORMAL)或单列索引 多列索引（复合索引)：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合 唯一索引或者非唯一索引 索引添加 1ALTER TABLE `tab1` ADD INDEX `idx_index_name` USING BTREE (`field1`, `field2`) comment ''; 平衡二叉树（Balanced Binary Tree)性质 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1 并且左右两个子树都是一棵平衡二叉树。 常用算法平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等 BTree,B+TreeB树(即二叉搜索树) 所有非叶子结点至多拥有两个儿子（Left和Right） 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树； B+树 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字自小而大顺序链接 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； 总结 B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3； B+Tree索引实现原理B+树概念B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。 B+树示意图： InnoDB数据页结构组成部分：File Header(文件头)、Page Header(页头)、Infimun + Supremum Records、User Records(用户记录，即行记录)、Free Space(空闲空间)、Page Directory(页目录)、File Trailer(文件结尾信息) 页是InnoDB存储引擎管理数据库的最小磁盘单位,InnoDB中的页大小为16KB，且不可以更改。 叶子节点(页与页之间)是双向链表串起来的，头连上一页的尾，尾连下一页的头 每个数据页中有两个虚拟的行记录，用来限定记录的边界。(行记录是记录在页中的，同时是在页内行记录之间也是双向链表链接的) 页目录(Page Directory)通过顺序排放的记录指针(也叫槽)存放了记录的相对位置，通过这些槽找到具体的数据位置 页目录中存放了记录的相对位置，有些时候这些记录指针称为Slots（槽）或者目录槽，与其他数据库不同的是，InnoDB并不是每个记录拥有一个槽，InnoDB中的槽是一个稀疏目录，即一个槽中可能属于多个记录，最少属于4个目录，最多属于8个目录。槽中记录按照键顺序存放，这样可以利用二叉查找迅速找到记录的指针。但是由于InnoDB中的Slots是稀疏目录，二叉查找的结果只是一个粗略的结果，所以InnoDB必须通过recorder header中的next_record来继续查找相关记录。同时slots很好的解释了recorder header中的n_owned值的含义，即还有多少记录需要查找，因为这些记录并不包括在slots中 查询B+树索引的流程首先通过B+树索引找到叶节点，再找到对应的数据页，然后将数据页加载到内存中，通过二分查找Page Directory中的槽，查找出一个粗略的目录，然后根据槽的指针指向链表中的行记录，之后在链表中依次查找。 注意： B+树索引不能找到具体的一条记录，而是只能找到对应的页。把页从磁盘装入到内存中，再通过Page Directory进行二分查找，同时此二分查找也可能找不到具体的行记录（有可能会找到），只是能找到一个接近的链表中的点，再从此点开始遍历链表进行查找。 聚簇索引/非聚簇索引区别： 聚簇索引一般是为主键索引，一张表只能有一个聚簇索引，B+树的叶子节点存储了行数据和主键。 非聚簇索引可以有多个，叶节点除了包含关键字键值外还包含聚集索引的主键 聚集索引 聚集索引是按每张表的主键构造的一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的节点成为数据页，这个特性决定了索引组织表中数据也是索引的一部分。由于实际的数据页只能按照一颗B+树进行排序，所以每张表只能拥有一个聚集索引。查询优化器非常倾向于采用聚集索引，因为其直接存储行数据，所以主键的排序查询和范围查找速度非常快。 不是物理上的连续，而是逻辑上的，不过在刚开始时数据是顺序插入的所以是物理上的连续，随着数据增删，物理上不再连续。 辅助索引 辅助索引页级别不包含行的全部数据。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签，该书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。其中存的就是聚集索引的键。 辅助索引的存在并不影响数据在聚集索引的结构组织。InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引找到一个完整的行记录。当然如果只是需要辅助索引的值和主键索引的值，那么只需要查找辅助索引就可以查询出索要的数据，就不用再去查主键索引了。 什么是一级索引、二级索引及生成场景每个InnoDB表具有一个特殊的索引称为聚簇索引（也叫聚集索引，聚类索引，簇集索引）。 如果表上定义有主键，该主键索引就是聚簇索引。 如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。 表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes） MyISAM和InnoDB索引实现原始数据如图： MyISAM引擎索引实现方式索引实现原理 是按列值与行号来组织索引的。它的叶子节点中保存的实际上是指向存放数据的物理块的指针。从MYISAM存储的物理文件我们能看出，MYISAM引擎的索引文件（.MYI）和数据文件(.MYD)是相互独立的。 主键索引与二级索引 MyISAM的主键索引和二级索引叶子节点存放的都是：列值与行号的组合，叶子节点中保存的是数据的物理地址 MYISAM的主键索引和二级索引没有任何区别：主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。 InnoDB引擎索引实现方式1. 聚簇索引(一级索引) 聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列(如col2)，如下图： 2. 非聚簇索引(二级索引) InnoDB的二级索引与主键索引有很大的不同，InnoDB的的二级索引的叶子节点存放的是：KEY字段加主键值，而不是行指针(row pointers)，如下图 二级索引查询步骤：先查到主键值，然后InnoDB再根据查到的主键值通过主键索引找到对应的数据块。 INNODB和MYISAM的主键索引与二级索引的对比如图： 参考资料：高性能MYSQL 参考平衡树BTree,B-Tree,B+Tree,B*Tree都是什么MySQL有哪些索引类型 ?mysql索引类型 normal, unique, full textMySQL_innoDB索引底层原理详解MYSQL性能调优: 对聚簇索引和非聚簇索引的认识面试知识点6：MySQL中InnoDB的一级索引、二级索引]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>索引原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序算法]]></title>
    <url>%2F2018-02-07-algorithm-merging-sorting.html</url>
    <content type="text"><![CDATA[算法思路 把 n 个记录看成 n 个长度为 l 的有序子表 进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 原理归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，其中的分治法是常用的一种解决问题的方法，现在流行的云计算其实就是一种分治法的应用。 归并算法详解 归并排序的中心思想：申请一个空序列，将两个已经排序好的序列，合并成一个排序的序列 假设：序列A：3 4 7 9序列B：2 6 8序列C：空合并思路是：先申请一个序列，将指针分别指向3和2，这时候进行比较，3大于2，所以把2放到序列C，序列B指针后移到6，这时候序列A的3小于6，把3放到序列C，A序列指针后移4小于序列B的6，把4放到序列C，依次类推。。。直到最后只剩下序列A中的9，把9合并到序列C，完成归并排序 分治法 字面解释就是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个思想在实际工作中的作用非常大，特别是处理大数据和做复杂运算的时候。 假设：无序序列：4 3 7 9 2 8 6将数组分成长度为2，并使每个子数组有序：[3, 4] [7, 9] [2, 8] [6]然后分别两个一对进行归并，然后就可以得到最终的有序序列：2 3 4 6 7 8 缺点归并排序的一个缺点是它需要存储器有另一个大小等于数据项数目的数组。如果初始数组几乎占满整个存储器，那么归并排序将不能工作，但是如果有足够的空间，归并排序会是一个很好的选择。 参考常见排序算法 - 归并排序 (Merge Sort)_有图经典排序算法 - 归并排序Merge sort详解PHP归并排序的实现大数据算法：对5亿数据进行排序]]></content>
      <tags>
        <tag>算法</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器命令]]></title>
    <url>%2F2018-02-07-linux-command.html</url>
    <content type="text"><![CDATA[常用命令简单说明grep 命令 grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来 格式grep [option] pattern file 选项-v –revert-match #显示不包含匹配文本的所有行-w –word-regexp #只显示全字符合的列-h –no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称 awk命令 是一种处理文本文件的语言，是一个强大的文本分析工具 规则：awk [选项参数] ‘条件1{动作1} 条件2{动作2} …’ 文件名（ 如果条件1，执行动作1；如果条件2，执行动作2 ） 变量 ：$1：提取第一列 ,$2提取第二列, 选项-F :指定输入文件折分隔符 输出print：会在每个输出之后自动加入一个换行符printf：标准格式输出命令，需要换行需手动加入 应用123awk '&#123;printf $2 "\t" $3"\n"&#125;' user.txtawk -F, '&#123;print $1,$2&#125;' log.txtawk -F '[ ,]' '&#123;print $1,$2,$5&#125;' log.txt # 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割 cut命令 提取列: cut [选项] 文件 选项:-f 列号 （ –field 提取第几列 ）-d 分隔符 （ –delimiter 按照指定分隔符分割列 ） 应用：1cut -d ":" -f 1,3 /etc/passwd # :分隔，输出1，3行 sed命令 数据进行选取、替换、删除、新增的命令 使用方法：sed [选项] ‘[动作]’ 文件名 选项-n : 一般sed命令会把所有数据都输出到屏幕；如果加入此选项，则只会把经过sed命令处理的行输出到屏幕。(如：sed -n ‘2p’ user.txt # 输出第二行) 动作d : 删除，删除指定的行。p : 打印，输出指定的行。s : 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似）如：sed “s/r//g” user.txt 替换r为空 实例：12sed -n '2p' user.txt # 输出第二行, p一般都要和-n使用，不加-n会显示出所有的行sed "s/r//g" user.txt # 替换r为空 sort命令 排序 选项-n：按数值排序，默认按ASCII码值排序\u：在输出行中去除重复行-r：降序(默认是降序)-o：输出结果重定向到文件\t：指定间隔符(配合-k指定列数排序)-k: 指定列排序 netstat 命令 用于显示各种网络相关信息，如网络连接，路由表，接口状态 选项-a (all)显示所有选项，默认不显示LISTEN相关(如果需要显示LISTEN相关需增加-l选项)-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名ps 命令能够给出当前系统中进程的快照 三种语法格式（一般使用UNIX风格的ps命令）：UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符GNU 风格的长选项，选项前有两个“-”连字符常用参数-A 列出所有的进程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程(主要包含CPU和memory占比)-ef 不加参数执行ps命令4列信息分别是：PID（进程编号）、TTY（终端）、TIME（命令占用的CPU处理时间）、CMD（进程运行的命令） 显示所有进程使用 -a 参数。-a 代表 all。同时加上x参数会显示没有控制终端的进程。ps -ax | less 1234PID TTY STAT TIME COMMAND 1 ? Ss 1:10 /sbin/init 2 ? S 0:00 [kthreadd] 3 ? S 7:08 [migration/0] 通过cpu使用来过滤进程 使用cpu排序ps aux --sort -pcpu | head ps 与grep 常用组合用法，查找特定进程ps -ef|grep ssh123UID PID PPID C STIME TTY TIME CMDroot 1334 1 0 2016 ? 07:12:57 /usr/sbin/sshdroot 1840 27822 0 17:57 pts/1 00:00:00 grep ssh 参考： 10个重要的Linux ps命令实战 ps命令详解系统连接状态 运行结果：123netstat -anlp | headProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1334/sshd 查看TCP连接状态常用：1netstat -ant |awk '&#123;print $6&#125;'|sort|uniq -c|sort -rn 可用：1234netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;' netstat -n | awk '/^tcp/ &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,"t",state[key]&#125;'netstat -n | awk '/^tcp/ &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,"t",arr[k]&#125;'netstat -n |awk '/^tcp/ &#123;print $NF&#125;'|sort|uniq -c|sort -rn 查找请求数20个IPnetstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20 netstat -ant |awk &#39;/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}&#39; |sort -rn|head -n20 用tcpdump嗅探80端口的访问看看谁最高tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#39; | sort | uniq -c | sort -nr |head -20 查找较多time_wait连接netstat -n|grep TIME_WAIT|awk &#39;{print $5}&#39;| cut -d &#39;:&#39; -f 1 | sort|uniq -c|sort -rn|head -n2 找查较多的SYN连接netstat -an | grep SYN | awk &#39;{print $5}&#39; | awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -nr | more 根据端口列进程netstat -ntlp | grep 80 | awk &#39;{print $NF}&#39; | cut -d &#39;/&#39; -f1 nginx日志知识 nginx有一个非常灵活的日志记录模式。每个级别的配置可以有各自独立的访问日志。日志格式通过log_format命令来定义。 access_log指令语法: access_log path [format [buffer=size [flush=time]]];123access_log path format gzip [=level] [buffer=size] [flush=time];access_log syslog:server=address\[,parameter=value] [format];access_log off; 默认值: access_log logs/access.log combined;配置段: http, server, location, if in location, limit_exceptgzip：压缩等级。buffer：设置内存缓存区大小。flush：保存在缓存区中的最长时间。不记录日志：access_log off;使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined; log_format指令 语法: log_format name string …; 默认值: log_format combined “…”; 配置段: httpname表示格式名称，string表示等义的格式。 默认配置：log_format有一个默认的无需设置的combined日志格式 1log_format combined '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"'; 对应的日志记录:12127.0.0.1 - - [21/Sep/2016:10:57:04 +0800] "GET / HTTP/1.1" 302 5 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36" "-" 127.0.0.1 - - [21/Sep/2016:10:57:04 +0800] "GET /dashboard.php HTTP/1.1" 200 26652 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36" "-" 日志格式变量含义 1234567891011121314151617$remote_addr, $http_x_forwarded_for 记录客户端IP地址$remote_user 记录客户端用户名称$request 记录请求的URL和HTTP协议$status 记录请求状态$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。$bytes_sent 发送给客户端的总字节数。$connection 连接的序列号。$connection_requests 当前通过一个连接获得的请求数量。$msec 日志写入时间。单位为秒，精度是毫秒。$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。$http_referer 记录从哪个页面链接访问过来的$http_user_agent 记录客户端浏览器相关信息$request_length 请求的长度（包括请求行，请求头和请求正文）。$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。$time_iso8601 ISO8601标准格式下的本地时间。$time_local 通用日志格式下的本地时间。[warning]发送给客户端的响应头拥有“sent_http_”前缀。 比如$sent_http_content_range。[/warning] 常见问题 获取真实客户IP：如果nginx位于负载均衡器，squid，nginx反向代理之后，web服务器无法直接获取到客户端真实的IP地址了。 $remote_addr获取反向代理的IP地址。反向代理服务器在转发请求的http头信息中，可以增加X-Forwarded-For信息，用来记录 客户端IP地址和客户端请求的服务器地址。PS: 获取用户真实IP 参见http://www.ttlsa.com/html/2235.html 网站日志分析篇(nginx) 获得访问前10位的ip地址 123cat nginx.log | awk '&#123;print $1&#125;' | sort | uniq -c | sort -nr | head -n 10 cat nginx.log|awk '&#123;counts[$(1)]+=1&#125;; END &#123;for(url in counts) print counts[url], url&#125;' | sort -nr 访问次数最多的文件或页面,取前20cat nginx.log | awk &#39;{print $7}&#39; | grep -E &quot;^/.*&quot; | sort | uniq -c | sort -nr | head -n 20 统计404的连接cat nginx.log | awk &#39;/ 404 /{print $7}&#39; | sort | uniq -c | sort -nr | more 系统Debug分析篇1.调试命令strace -p pid2.跟踪指定进程的PIDgdb -p pid 参考： Linux Web服务器网站故障分析常用的命令 nginx日志配置 crontab定时任务/etc/crontab中每行任务的描述格式minute hour day month dayofweek command minute 从0到59的整数 hour 从0到23的整数 day 从1到31的整数 (必须是指定月份的有效日期) month 从1到12的整数 (或如Jan或Feb简写的月份) dayofweek 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示) command 需要执行的命令(可用as ls /proc &gt;&gt; /tmp/proc或 执行自定义脚本的命令)root: 表示以root用户身份来运行run-parts: 表示后面跟着的是一个文件夹，要执行的是该文件夹下的所有脚本1234567# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 语法 * 表示所有可用的值, 比如每隔10分钟执行一次:*/10 整数间的连字号(-)表示整数列: 例如1-4意思是整数1,2,3,4 逗号：如：3,4,6,8表示这四个指定整数 符号“/”指定步进设置： “/”表示步进值。如0-59/2定义每两分钟执行一次。步进值也可用星号表示。如*/3用来运行每三个月份运行指定任务 井号”#”: 注释行,不会被执行 参考： Linux Crontab 定时任务 命令详解 定时任务设置问题：linux下请设置一个定时任务，要求/data/www/a.php在每天凌晨2点到晚上20点，每10分钟执行一次。答案：12vim /etc/crontab*/10 2-20 * * * /usr/local/bin/php /data/www/a.php 延伸：定时任务在自己系统中是如何使用的，定时任务与持续运行脚本的区别。 定时任务：每隔一段时间执行一次，缺点：存在任务执行耗费时间过长，上次执行没有结束，下次执行又来了。脚本运行：持续的脚本运行，可以使用supervisor进行管理，不过需要做兼容处理比如redis、mysql异常中断重连。]]></content>
      <tags>
        <tag>故障分析</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式面试题]]></title>
    <url>%2F2018-02-06-design-pattern-interview-question.html</url>
    <content type="text"><![CDATA[控制反转（IoC）与依赖注入（DI） 控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。 通过IoC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。 参考：控制反转（IoC）与依赖注入（DI） 理解PHP依赖注入和Laravel的IOC容器依赖注入：把一个类中可变换的部分提取出来抽象为单独的类，然后在将实例变量注入到原来的类中，供原始类进行使用IOC容器：控制反转是工程中解耦合的思想，本来需要自己new的类现在完全交给了容器去实例化，比如类A依赖B类，容器创建B的实例，类A只管使用即可。Laravel中Phalcon\DI就是这个容器的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass SomeComponent&#123; protected $_di; public function __construct($di) &#123; $this-&gt;_di = $di; &#125; public function someDbTask() &#123; // Get the connection service // Always returns a new connection $connection = $this-&gt;_di-&gt;get('db'); &#125; public function someOtherDbTask() &#123; // Get a shared connection service, // this will return the same connection everytime $connection = $this-&gt;_di-&gt;getShared('db'); //This method also requires a input filtering service $filter = $this-&gt;_db-&gt;get('filter'); &#125;&#125;$di = new Phalcon\DI();//Register a "db" service in the container$di-&gt;set('db', function()&#123; return new Connection(array( "host" =&gt; "localhost", "username" =&gt; "root", "password" =&gt; "secret", "dbname" =&gt; "invo" ));&#125;);//Register a "filter" service in the container$di-&gt;set('filter', function()&#123; return new Filter();&#125;);//Register a "session" service in the container$di-&gt;set('session', function()&#123; return new Session();&#125;);//Pass the service container as unique parameter$some = new SomeComponent($di);$some-&gt;someTask(); 参考：理解PHP 依赖注入|Laravel IoC容器]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018-02-05-design-pattern.html</url>
    <content type="text"><![CDATA[创建性模式单例模式(Singleton) 要求：只有一个实例，自行创建实例并对外提供这个实例 实现:1234567891011121314151617181920212223class Mysql &#123; private static $conn; private function __construct() &#123; self::$conn = new PDO("mysql:dbname=testdb;host=127.0.0.1", "root", "root"); &#125; public static function getInstance() &#123; if(!(self::$conn instanceof self))&#123; self::$conn = self; &#125; return self::$conn; &#125; //防止对象被复制 public function __clone()&#123; trigger_error('Clone is not allowed !'); &#125; //防止反序列化后创建对象 public function __wakeup() &#123; trigger_error('Unserialized is not allowed !'); &#125;&#125;$mysql = Mysql::getInstance(); 简单工厂模式 要求：获取一个实例不通过new关键字获取，都是通过一个工厂类的工厂方法得到这个类的实例 规则： 工厂类必须有一个工厂方法 工厂类必须能够返回一个业务类实例 一次只能创建和返回一个实例 实现：123456789101112131415161718192021222324252627&lt;?phpclass SimpleFactory &#123; public function create($name) &#123; return new $name(); &#125;&#125;abstract class Vehicle &#123; abstract public function driveTo($dest);&#125;class Bicycle extends Vehicle &#123; public function driveTo($dest) &#123; return '骑自行车去:'.$dest; &#125;&#125;class Car extends Vehicle &#123; public function driveTo($dest) &#123; return '开汽车去:'.$dest; &#125;&#125;//应用$factory = new SimpleFactory();$vehicle = $factory -&gt; create('Bicycle');print($vehicle -&gt; driveTo('北京')); 结构性模式适配器模式接口的应用12345678910111213141516171819202122232425262728293031323334interface Database &#123; public function connect(); public function query(); public function close();&#125;class DBMysql implements Database &#123; public function connect() &#123; var_dump(__METHOD__); &#125; public function query() &#123; var_dump(__METHOD__); &#125; public function close() &#123; var_dump(__METHOD__); &#125;&#125;class DBPdo implements Database &#123; public function connect() &#123; var_dump(__METHOD__); &#125; public function query() &#123; var_dump(__METHOD__); &#125; public function close() &#123; var_dump(__METHOD__); &#125;&#125;$database = new DBMysql();//切换数据库只要改这一行就行了，因为后面的都是标准接口方法，不管哪个数据库都一样$database-&gt;connect();$database-&gt;query();$database-&gt;close(); 问题有的三方接口并没有按照标准接口实现，如下：123456789101112//第三方数据库类class Oracle &#123; public function oracleConnect()&#123; //Oracle 的逻辑 &#125;; public function oracleQuery()&#123; //Oracle 的逻辑 &#125;; public function oracleClose()&#123; //Oracle 的逻辑 &#125;;&#125; 这时候适配器就派上用场了，用这个适配器将异类的方法转换为接口标准方法适配器模式12345678910111213141516class Adapter implements Database &#123; private $adaptee; function __construct($adaptee) &#123; $this-&gt;adaptee = $adaptee; &#125; //这里把异类的方法转换成了 接口标准方法，下同 public function connect()&#123; $this-&gt;adaptee-&gt;oracleConnect(); &#125;; public function query()&#123; $this-&gt;adaptee-&gt;oracleQuery(); &#125;; public function close()&#123; $this-&gt;adaptee-&gt;oracleClose(); &#125;;&#125; 应用：123456$adaptee = new Oracle(); $adapter = new Adapter($adaptee);//只要改这个类就行了，后面的都可以不用改；$database = $adapter;$database-&gt;connect();$database-&gt;query();$database-&gt;close(); 装饰器模式解决问题：为某个方法装饰可以自由删除或增加的逻辑(如果遇到) 场景：比如有一个煮咖啡的程序，默认是纯咖啡，如何方便的选择是否加糖、加奶、加巧克力呢？ 1234567//主咖啡程序class plainCoffee &#123; public function makeCoffee()&#123; $this-&gt;addCoffee(); &#125; public function addCoffee()&#123;&#125;&#125; 一般逻辑：加糖 1234567class sweetCoffee extends plainCoffee &#123; public function makeCoffee()&#123; $this-&gt;addCoffee(); $this-&gt;addSugar(); &#125; public function addSugar()&#123;&#125;&#125; 弊端：如果这时候加奶、加巧克力就需要继续继承重写makeCoffee 装饰器方式：在addCoffee前后增加逻辑处理 1234567891011121314151617181920212223//调整煮咖啡程序class plainCoffee &#123; private $decorators; public function addDecorator($decorator)&#123; $this-&gt;decorators[] = $decorator; &#125; private function before()&#123; foreach($this-&gt;decorators as $decorator)&#123; $decorator-&gt;before() &#125; &#125; private function after()&#123; foreach($this-&gt;decorators as $decorator)&#123; $decorator-&gt;after() &#125; &#125; public function makeCoffee()&#123; $this-&gt;before(); $this-&gt;addCoffee(); $this-&gt;after(); &#125; public function addCoffee()&#123;&#125;&#125; 编写装饰器： 12345678class sweetCoffeeDecorator&#123; public function before()&#123; &#125; public function after()&#123; $this-&gt;addSugar(); &#125; public function addSugar()&#123;&#125;&#125; 应用：加糖加奶只需要增加装饰器即可，不需要只需注释掉。 1234$coffee = new plainCoffee();$coffee-&gt;addDecorator(new sweetCoffeeDecorator());$coffee-&gt;addDecorator(new milkCoffeeDecorator());$coffee-&gt;makeCoffee(); 总结：当你extends用过后又遇到需要再次extends的情况时，不妨考虑一下装饰器模式 依赖注入原理：把一个类不可能更换的部分 和 可更换的部分分离开来，通过注入的方式来使用，从而达到解耦的目的。一个数据库连接类12345678910111213141516171819202122//数据库连接class Mysql&#123; private $host; private $port; private $username; private $password; private $db_name; public function __construct()&#123; $this-&gt;host = '127.0.0.1'; $this-&gt;port = 22; $this-&gt;username = 'root'; $this-&gt;password = ''; $this-&gt;db_name = 'my_db'; &#125; public function connect()&#123; return mysqli_connect($this-&gt;host,$this-&gt;username ,$this-&gt;password,$this-&gt;db_name,$this-&gt;port); &#125;&#125;//使用：$db = new Mysql();$con = $db-&gt;connect(); 依赖注入：将可变部分(配置)提取出来抽象为一个类，然后在注入到原类中，这样就完成了配置文件和连接逻辑的分离。123456789101112131415161718192021222324252627282930313233343536373839404142//配置类class MysqlConfiguration &#123; private $host; private $port; private $username; private $password; private $db_name; public function __construct($host, $port, $username, $password, $db_name) &#123; $this-&gt;host = $host; $this-&gt;port = $port; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;db_name = $db_name; &#125; public function getHost() &#123; return $this-&gt;host; &#125; public function getPort() &#123; return $this-&gt;port; &#125; public function getUsername()&#123; return $this-&gt;username; &#125; public function getPassword() &#123; return $this-&gt;password; &#125; public function getDbName() &#123; return $this-&gt;db_name; &#125;&#125;//Mysql变更为：class Mysql &#123; private $configuration; public function __construct(MysqlConfiguration $config) &#123; $this-&gt;configuration = $config; &#125; public function connect() &#123; return mysqli_connect($this-&gt;configuration-&gt;getHost(), $this-&gt;configuration-&gt;getUsername(), $this-&gt;configuration-&gt;getPassword, $this-&gt;configuration-&gt;getDbName(), $this-&gt;configuration-&gt;getPort()); &#125;&#125; 使用：$config是注入Mysql的，这就是所谓的依赖注入。123$config = new MysqlConfiguration('127.0.0.1','root','','my_db',22);$db = new Mysql($config);$con = $db-&gt;connect(); 链式操作123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Employee&#123; public $name; public $surName; public $salary; public function setName($name) &#123; $this-&gt;name = $name; return $this; &#125; public function setSurname($surname) &#123; $this-&gt;surName = $surname; return $this; &#125; public function setSalary($salary) &#123; $this-&gt;salary = $salary; return $this; &#125; public function __toString() &#123; $employeeInfo = 'Name: ' . $this-&gt;name . PHP_EOL; $employeeInfo .= 'Surname: ' . $this-&gt;surName . PHP_EOL; $employeeInfo .= 'Salary: ' . $this-&gt;salary . PHP_EOL; return $employeeInfo; &#125;&#125;//链式操作的效果$employee = (new Employee()) -&gt;setName('Tom') -&gt;setSurname('Smith') -&gt;setSalary('100');echo $employee;# 输出结果# Name: Tom# Surname: Smith# Salary: 100 行为性模式观察者模式需求：有一个listener和handler，当listener监听到一个事件发生，多个handler自动处理对应的逻辑原理： 声明抽象事件发生者类(EventGenerator)，负责添加观察者和逐一调用观察者的update方法进行通知。 声明观察者接口类(Observer)，提供抽象方法update，所有的观察者都实现这个接口 具体的事件继承EventGenerator类，然后调用addObserver添加观察者，调用trigger进行触发。 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//声明一个抽象的事件发生者基类abstract class EventGenerator&#123; private $observers = array(); //添加观察者方法 function addobserver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; //对每个添加的观察者进行事件通知 function notify() &#123; //对每个观察者逐个去更新 foreach($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125;//声明一个观察者接口interface observer &#123; function update($event_info = null);&#125;//声明具体事件类，继承了主事件class Event extends EventGenerator&#123; function trigger() &#123; echo "Event&lt;br/&gt;"; $this-&gt;notify(); &#125;&#125;//声明多个观察者class Observer1 implements observer&#123; function update($event_info = null) &#123; echo "逻辑1&lt;br/&gt;"; &#125;&#125;class Observer2 implements observer&#123; function update($event_info = null) &#123; echo "逻辑2&lt;br/&gt;"; &#125;&#125; 应用：12345//Event基类里的foreach，可以实现一个事件对应多个观察者$event = new Event;$event-&gt;addObserver(new Observer1);$event-&gt;addObserver(new Observer2);$event-&gt;trigger(); 策略模式需求 ：针对大量ifelse判断上下文的环境所作出的策略。原理：提供一个策略接口(Strategy)，其中定义待实现方法，其他策略实现这个接口，业务逻辑中只调用接口中定义的方法。举例：商城的首页，男的进来看男性商品，女的进来看女性商品，不男不女…以此类推，各种条件下用不同策略展示不同商品实现:123456789101112131415161718192021222324252627//showStrategy.php 展示策略接口interface showStrategy&#123; public function showCategory();&#125;//maleShowStrategy.php 男性用户展示策略class maleShowStrategy implements showStrategy &#123; // 具体策略A public function showCategory()&#123; echo '展示男性商品目录'; &#125;&#125;//femaleShowStrategy.php 女性用户展示策略class femaleShowStrategy implements showStrategy &#123; // 具体策略B public function showCategory()&#123; echo '展示女性商品目录'; &#125;&#125;//page.php 展示页面class Page&#123; private $_strategy; public function __construct(Strategy $strategy) &#123; $this-&gt;_strategy = $strategy; &#125; public function showPage() &#123; $this-&gt;_strategy-&gt;showCategory(); &#125;&#125; 使用12345678if(isset($_GET['male']))&#123; $strategy = new maleShowStrategy();&#125;elseif(isset($_GET['female']))&#123; $strategy = new femaleShowStrategy();&#125;//注意看这里上下，Page类不再依赖一种具体的策略，而是只需要绑定一个抽象的接口，这就是传说中的控制反转（IOC）。$question = new Page($strategy);$question-&gt;showPage(); 总结仔细看上面的例子，不复杂，我们发现有2个好处： 它把if else 抽离出来了，不需要在每个类里都写if else；它成功的实现了控制反转，Page类里没有具体的依赖策略，这样我们就可以随时添加和删除 不同的策略。 模板方法这是最常见的设计模式之一，其实质就是父类提供一系列模板方法，有的实现了逻辑，有的只是一个接口。而子类继承大部分共有方法，同时对接口方法进行不同的实现，从而完成对父类模板的个性化改造，起到一对多的解耦目的。 可以说PHP的抽象类就是为了实现这个设计模式而推出的功能，在PHP中，抽象类本身就是模板方法模式。应用: 123456789101112131415161718192021222324252627282930313233343536//Journey.php 模板类abstract class Journey&#123; private $thingsToDo = []; //final关键字的作用是不让这个方法被子类覆盖 final public function takeATrip() &#123; $this-&gt;thingsToDo[] = $this-&gt;buyAFlight(); $this-&gt;thingsToDo[] = $this-&gt;takePlane(); $this-&gt;thingsToDo[] = $this-&gt;enjoyVacation(); $buyGift = $this-&gt;buyGift(); if ($buyGift !== null) &#123; $this-&gt;thingsToDo[] = $buyGift; &#125; $this-&gt;thingsToDo[] = $this-&gt;takePlane(); &#125;//子类必须实现的抽象方法 abstract protected function enjoyVacation(): string; protected function buyGift() &#123; return null; &#125; private function buyAFlight(): string &#123; return 'Buy a flight ticket'; &#125; private function takePlane(): string &#123; return 'Taking the plane'; &#125; //把所有旅行中干过的事情列出来 public function getThingsToDo(): array &#123; return $this-&gt;thingsToDo; &#125;&#125; 123456789101112131415161718192021//BeachJourney.php子类一class BeachJourney extends Journey&#123; protected function enjoyVacation(): string &#123; return "Swimming and sun-bathing"; &#125;&#125;//BeachJourney.php子类二class CityJourney extends Journey&#123; protected function enjoyVacation(): string &#123; return "Eat, drink, take photos and sleep"; &#125;//覆盖父类已有方法 protected function buyGift(): string &#123; return "Buy a gift"; &#125;&#125; 参考： 四种常见设计模式 PHP 经典设计模式]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL知识点]]></title>
    <url>%2F2018-02-05-mysql.html</url>
    <content type="text"><![CDATA[数据库三大范式1. 第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式 第一范式需要按照系统的实际需求来定。比如一般”地址”这个属性都是一个字段就可以了，但是如果系统经常访问城市，那就可以对地址进行拆分，这样在对地址进行查询的时候就比较的方便。 上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能 2. 第二范式(确保表中的每列都和主键相关) 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中 如图：订单信息表：一个订单中可能有多个商品，所以将订单号和商品编号作为联合主键。上图中商品名称、单位、价格只与商品有关于订单号无关，所以是不满足第二范式的。这时候应该把商品信息拆分为单独的表，如下： 3. 第三范式(确保每列都和主键列直接相关,而不是间接相关) 满足第三范式（3NF）必须先满足第二范式（2NF）。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息 参考数据库设计三大范式 mysql创建索引原则 较频繁的作为查询条件的字段应该创建索引 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 更新非常频繁的字段不适合创建索引 不会出现在WHERE子句中的字段不该创建索引 数据库优化的思路1. SQL语句优化 避免select * 字段尽可能的使用 NOT NULL 尽量避免在 !=或&lt;&gt;和not in操作符,避免全表扫描 where 及 order by 涉及的列上建立索引 尽量少使用join查询 2. 索引优化合理增加索引，查看 mysql创建索引原则 3. 数据库结构优化 范式优化：消除冗余（节省空间） 反范式优化:比如适当加冗余等（减少join) 表的垂直拆分和水平拆分 4. 服务器硬件优化 提升服务器硬件配置 5. 缓存机制 添加缓存机制，使用(redis,memcache) 不经常改动的使用静态页面 表的垂直拆分和水平拆分垂直拆分 垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表 原则 把不常用的字段单独放在一张表; 把text，blob等大字段拆分出来放在附表中; 经常组合查询的列放在一张表中;ps:垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关键起来即可; 水平拆分 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放. 拆分原则通常使用取模的方式来进行表的拆分 应用比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4通过用ID取模的方法把数据分散到四张表内Id%4+1 = [1,2,3,4]插入：在insert时还需要一张临时表uid_temp来提供自增的ID,该表的唯一用处就是提供自增的ID;得到自增的ID后,又通过取模法进行分表插入然后查询,更新,删除也是通过取模的方法来查询1234$_GET['id'] = 17,17%4 + 1 = 2, $tableName = 'users'.'2'Select * from users2 where id = 17; 注意:进行水平拆分后的表,字段的列和类型和原表应该是相同的,但是要记得去掉auto_increment自增长 mysql CPU告警解决思路 top 之后，确实是mysqld进程占据了所有资源 查看error日志，无任何异常 show engine innodb status\G，没有死锁信息 show full processlist:没有耗时非常大的慢sql再跑。看并发，当前的线程总数量也才30个左右 查看iostat，读写正常 查看slow log:然后优化sql drop,delete与truncate的区别 delete和truncate只删除表的数据不删除表的结构, trucate删除表数据自增id从1开始，delete删除可加where语句 速度,一般来说: drop&gt; truncate &gt;delete delete语句是dml,这个操作会放到rollback中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 数据库事务的四个特性及含义 数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。 持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚 查找慢SQL查询开启慢查询配置 slow_query_log 这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。 long_query_time 当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。 slow_query_log_file 记录日志的文件名 log_queries_not_using_indexes 这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。 检测执行效率1. 查看慢查询日志查看slow_query_log_file配置的文件 2. show processlist 命令 SHOW PROCESSLIST显示哪些线程正在运行 各列的含义和用途 ID列：一个标识，你要kill一个语句的时候很有用，用命令杀掉此查询 mysqladmin kill 进程号。 user列：显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句。 host列：显示这个语句是从哪个ip的哪个端口上发出的。用于追踪出问题语句的用户。 db列：显示这个进程目前连接的是哪个数据库。 command列：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）。 time列：此这个状态持续的时间，单位是秒。 state列：显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个 sql语句，以查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成 info列：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据 3. explain来了解SQL执行的状态 explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句 3.1 用法 在select语句前加上explain就可以了 例如： 1explain select * from info where uid = 1234 order by id desc limit 1\G; 运行结果： 12345678910 id: 1 select_type: SIMPLE table: info type: refpossible_keys: uid key: uid key_len: 8 ref: const rows: 18 Extra: Using index condition; Using where; Using filesort 3.2 列含义 table: 显示这一行的数据是关于哪张表的 select_type: 表示 SELECT 的 类型，常见的取值有 SIMPLE （简单表，即不使用表连接或者子查询）、 PRIMARY （主查询，即外层的查询）、 UNION （ UNION 中的第二个或者后面的查询语句）、 SUBQUERY （子查询中的第一个 SELECT ）等 type : 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL 表示表的连接类型，性能由好到差的连接类型为 system （表中仅有一行，即常量表）、 const （单表中最多有一个匹配行，例如 primary key 或者 unique index ）、 eq_ref （对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index ）、 ref （与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index ，而是使用普通的索引）、 ref_or_null （ 与 ref 类似，区别在于条件中包含对 NULL 的查询 ） 、 index_merge ( 索引合并优化 ) 、 unique_subquery （ in 的后面是一个查询主键字段的子查询）、 index_subquery （ 与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、 range （单表中的范围查询）、 index （对于前面的每一行，都通过查询索引来得到数据）、 all （对于前面的每一行，都通过全表扫描来得到数据） possible_keys: 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 key: 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句 中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 key_len: 使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref: 显示索引的哪一列被使用了，如果可能的话，是一个常数 rows: MYSQL认为必须检查的用来返回请求数据的行数 extra: 执行情况的说明和描述 参考: MySQL常见面试题 MySQL性能优化总结 MySQL分区表详解 常见面试题整理–数据库篇（每位开发者必备） 表的垂直拆分和水平拆分 如何查找MySQL中查询慢的SQL语句 mysql 数据类型1、整型 MySQL数据类型 含义（有符号） tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~8388607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22*10的18次方) 取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~255)。int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。 2、浮点型(float和double) MySQL数据类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数，d小数位 设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。 3、定点数 浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。 4、字符串(char,varchar,_text) MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char和varchar：1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。3.char类型的字符串检索速度要比varchar类型的快。varchar和text：1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。2.text类型不能有默认值。3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。 5.二进制数据(_Blob) 1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。2._BLOB存储的数据只能整体读出。3._TEXT可以指定字符集，_BLO不用指定字符集。 6.日期时间类型 MySQL数据类型 含义 date 日期 ‘2008-12-2’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2008-12-2 22:06:44’ timestamp 自动存储记录修改时间 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。 数据类型的属性 MySQL关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集]]></content>
      <tags>
        <tag>面试</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux网络编程]]></title>
    <url>%2F2018-02-05-linux-network-program.html</url>
    <content type="text"><![CDATA[select, poll和epoll的区别 什么是多路I/O复用（Epoll）（1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理（2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件（3） 为了提升服务器线程处理效率，有以下三种思路 （1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转 （2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N） （3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1) 其它开源软件采用的模型 Nginx：多进程单线程模型Memcached：单进程多线程模型]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见算法]]></title>
    <url>%2F2018-02-05-algorithm-php.html</url>
    <content type="text"><![CDATA[文章参考：todayqq/PHPerInterviewGuide 常用的排序算法的时间复杂度和空间复杂度 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n^2) O(n^2) 稳定 O(1) 快速排序 O(n^2) O(n*logn) 不稳定 O(logn)~O(n) 选择排序 O(n^2) O(n^2) 稳定 O(1) 二叉树排序 O(n^2) O(n*logn) 不一顶 O(n) 插入排序 O(n^2) O(n^2) 稳定 O(1) 堆排序 O(n*logn) O(n*logn) 不稳定 O(1) 希尔排序 O O 不稳定 O(1) 冒泡排序 插入排序和冒泡排序在平均和最坏情况下的时间复杂度都是O(n^2)，最好情况下都是O(n)，空间复杂度是O(1) 原理:比较相邻两个元素,如果前一个元素大于后一个元素则向后移,然后跟后边元素依次比较直到最大值冒泡到最后一个元素 结论:假设数组长度为n,则共经过N=n-1轮排序,每轮进行N-i次比较,我们可以使用双层循环语句,外层循环控制轮次,内层循环控制比较次数 1234567891011121314function bubble_sort($arr) &#123; $count = count($arr); for($i=0; $i &lt; $count-1; $i++) &#123; for($j=0; $j &lt; $count-1-$i; $j++) &#123; if($arr[$j] &gt; $arr[$j+1]) &#123;//倒序排只需把大于号换成小于号即可 $temp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $temp; &#125; &#125; &#125; return $arr;&#125;print_r(bubble_sort([6, 3, 8, 2, 9, 1, 2])); 运行结果:12345678910Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 6 [5] =&gt; 8 [6] =&gt; 9) 参考: PHP 冒泡排序 快速排序 快速排序是对冒泡排序的一种改进，不稳定，平均时间复杂度：O(nlogn) 实现 原理: 选择一个基准数(一般为第一个元素),新建两个空数组,遍历整个数组元素,如果数组元素比基准数小,则放到left数组,如果大于基准数则放到right数组,然后在对新数组递归进行相同的操作 基准数: 第一个元素 递归点: 新构造的数组个数大于1则继续进行拆分排序 递归出口: 数组个数小于等于1或非数组 123456789101112131415161718192021function quick_sort($arr) &#123; $count = count($arr); if($count &lt;= 1) &#123; return $arr; &#125; $base = $arr[0]; $left = $right = array(); for($i=1; $i &lt; $count; $i++) &#123; if($arr[$i] &lt; $base) &#123; //倒序排只需把符号换成大于号即可 $left[] = $arr[$i]; &#125; else &#123; $right[] = $arr[$i]; &#125; &#125; $left = quick_sort($left); $right = quick_sort($right); return array_merge($left, array($base), $right);&#125;$arr = [6,3,8,6,4,4,2,9,5,1];print_r(quick_sort($arr)); 运行结果：12345678910111213Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 4 [5] =&gt; 5 [6] =&gt; 6 [7] =&gt; 6 [8] =&gt; 8 [9] =&gt; 9) 参考： php实现快速排序 复杂度证明最优情况 在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，我们就有了下面的不等式推断推导如下：12345T（n）≤2T（n/2） +n，T（1）=0 T（n）≤2（2T（n/4）+n/2） +n=4T（n/4）+2n T（n）≤4（2T（n/8）+n/4） +2n=8T（n/8）+3n …… T（n）≤nT（1）+（log2n）×n= O(nlogn) 在最优的情况下，快速排序算法的时间复杂度为O(nlogn). 最坏情况在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录也就是枢轴的位置，因此比较次数为 ，最终其时间复杂度为O(n^2)。 平均情况平均的情况，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：由数学归纳法可证明，其数量级为O(nlogn)。 就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。 参考：9.9.2 快速排序复杂度分析 二分查找（折半查找） 时间复杂度：O(log2n)以2为底n的对数 实现 需求: 提供一个有序数组和一个目标数字,找出该数字在有序数组中的位置 原理： 知道起始位置和结束位置(默认为数组起点和终点索引值), 取数组中间位置数字与目标数字比较. 如果目标值小于中间值,则目标值在中间位置之前,此时再次二分，起始位置不变,结束位置变更为中间位置-1. 如果中间值小于目标值,则目标值在中间位置之后,此时再次二分，起始位置为中间位置+1,结束位置不变. 如果中间值等于目标值则返回中间位置 12345678910111213141516171819202122232425function binary_search($target, $arr) &#123; $low = 0; $high = count($arr) -1; while($low &lt;= $high) &#123; //&lt;=兼容target = 1情况 $mid = floor(($low+$high) / 2); //var_dump($low.'_'.$high.'_'.$mid);//打印比较过程 if($target &lt; $arr[$mid]) &#123; $high = $mid -1; &#125; if($target &gt; $arr[$mid]) &#123; $low = $mid +1; &#125; if($target == $arr[$mid]) &#123; return $mid; &#125; &#125; //var_dump($low.'_'.$high.'_'.$mid);//打印比较过程 return false;&#125;$target = 7;//分别测试target=1,2,7$arr = [1, 2, 3, 6, 8, 9, 10, 13, 14];//共9个数字var_dump($target);print_r($arr);$ret = binary_search($target, $arr);var_dump($ret); 运行结果：1234567891011121314int(7)Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 6 [4] =&gt; 8 [5] =&gt; 9 [6] =&gt; 10 [7] =&gt; 13 [8] =&gt; 14)bool(false) 参考：php实现二分查找法 二分查找时间复杂度计算方法二分查找原理：有目标元素t和长度为n的有序数组a，查找t在a中的位置。首先取中间元素c = a[n/2]与t比较。如果t和c相等则返回，如果t比c小，则从左侧部分继续取中间元素c，否则从右侧部分取中间元素进行比较，依次循环。所以时间复杂度的计算就是循环次数的计算，如下推导： 次数 剩余操作元素数目 1 n 2 n/2 3 n/4 4 n/8 .. …. k n/(2^(k-1)) 最终剩余操作元素数目为n/(2^(k-1)) &gt;=1，去除常数计算即：2^k = n,复杂度为O(log2n)以2为底n的对数 Twitter Snowflake核心思想snowflake是twitter开源的分布式ID生成算法，其核心思想是：产生一个long型(64bit)的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)个，也就是大约400W的ID，完全能满足业务的需求。 实现 12| 41 bits: Timestamp | 3 bits: 区域 | 10 bits: 机器编号 | 10 bits: 序列号 |return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (paddingnum &lt;&lt; regionIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; 毫秒数计算：需要选择某一天的毫秒级时间戳为基准时间戳，然后用当前时间戳与基准时间戳相减 序列号计算：同一毫秒内序列号自增，超过最大值则溢出等待下一毫秒 最后分别对Timestamp、区域、机器编号、序列号分别向左做相对应的位运算，然后进行与操作得到最终的唯一id注意 需要控制好所有服务器的时间，使用统一的ntp时间服务器，否则生成的id无法保持增长趋势 这个id可用的时间大概是：2^41/1000/3600/24/365 ≈ 79年 检测数组中是否存在重复数字问题描述有长度为n的数组，内容是n，里面当然会有些重复的（只有重复2次的情况），举个例子 8,1,2,3,4,5,2,8 找出重复的数字 注意：特殊条件：长度为n，内容是n 思路一循环一遍，把读取过的数据放入一个数据结构中，比如“哈希表”中，再每次判断哈希表中是否已经存在，来判断是否重复 思路二使用当前数组的“索引”和“这个索引的数据是否为负数”来做共同承担“哈希表”的职责。遍历数组的值，值-1作为索引值，也就是哈希值，重复的值对应生成的索引值是一样的，这时候将该索引值对应的value变为负数，如果下次重复的值作为索引获取value小于1则认为是重复的。1234567891011def a( nums): b = [] for x in nums: if nums[abs(x) - 1] &lt; 0: b.append(abs(x)) else: nums[abs(x) - 1] *= -1 return bif __name__ == '__main__': print(a([8,1,2,3,4,5,2,8])) 德州扑克算法问题描述从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2-10为数字本身，A为1，J为11，Q为12，K为13， 而大小王可以看成任意数字，如何实现？ 实现思路由于大小王是特殊数字，暂且把他们看作为0，拿到5张牌后去掉大小王，然后进行排序，排序后只需要判断相邻两张牌不能重复，如果重复则不是顺子，如果不是顺子则需要判断最大值与最小值的差与0的个数的关系。 确认5张牌中除了0，其余数字没有重复的（可以用表统计的方法）; 满足这样的逻辑：（max，min分别代表5张牌中的除0以外的最大值最小值）如果没有0，则max-min=4，则为顺子，否则不是 如果有一个0，则max-min=4或者3，则为顺子，否则不是 如果有两个0，则max-min=4或者3或者2，则为顺子，否则不是 最大值和最小值在1）中就可以获得，这样就不用排序了。 扩展阅读 PHP实现各种经典算法 PHP常见算法-面试篇 常用算法PHP版 全局唯一ID设计 常用的排序算法的时间复杂度和空间复杂度 二分查找时间复杂度的计算 9.9.2 快速排序复杂度分析 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP知识点]]></title>
    <url>%2F2018-01-31-tcp_ip_point.html</url>
    <content type="text"><![CDATA[三次握手第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认； 第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。 第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了，但是，此时主动关闭方还可以接受数据，此时主动关闭方状态为：FIN_WAIT_1 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），此时被动关闭方状态为：CLOSE_WAIT 第三次挥手：被动关闭方发送一个FIN，进入LAST_ACK状态。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。ps：四次挥手示意图中client准确来说是主动关闭一方，server为被动关闭一方。 常见状态码 CLOSED: 这个没什么好说的了，表示初始状态。 LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 ESTABLISHED：这个容易理解了，表示连接已经建立了。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 常见问题1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以关闭连接时的ACK报文和FIN报文多数情况下都是分开发送的。 3. 什么是2MSL？2MSL(maximum segment lifetime) 等待一段时间，防止最后的FIN的ACK包丢失，对方未收到ACK会重发FIN TCP连接在2MSL时间内 ip,port不能重新被bind 4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）。但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 参考面试笔试–TCP/IP知识点HTTP/TCP常见面试问题总结从输入url到页面展示到底发生了什么]]></content>
      <categories>
        <category>技术支撑</category>
        <category>网络工程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言指针]]></title>
    <url>%2F2018-01-16-c-pointer-define.html</url>
    <content type="text"><![CDATA[1. 指针的定义方式：示例一：123int a = 5;int *p;p = &amp;a; 说明：p为指针变量，int p 中的为类型说明符，声明p的类型为指针变量类型。指针变量必须是指向内存地址（内存指针），&amp;符为取地址运算符。示例二： 12int a = 5;int *p = &amp;a; 说明：先声明一个指针变量，然后对这个指针变量进行赋值。 2. 指针变量的使用123int a = 5;int *p = &amp;a;printf("*p = %d", *p); 说明：这里的printf(“ p = %d“, p);中的与上边声明指针变量的int p的含义是不同的，这里的*为指针运算符，不是类型说明符。 printf("*&amp;a = %d", *&amp;a); //运行结果为a本身 由于*和&amp;的优先级相同，所以会先进行&amp;a进行取a的内存地址，然后在通过*指针运算符，指向a的内存地址并返回这块内存单元存放的数据。 总结 int *p 声明指针变量的* 为类型说明符，他的性质和int long的作用相似，都是说明变量的类型。 *p 获取指针变量的为指针运算符，和&amp;的类型都是一样的就是参与运算的，只是&amp;获取的是内存的地址，获取的是内存地址为该指针变量上存储的数据]]></content>
      <categories>
        <category>编程语言</category>
        <category>C</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点总结(持续更新~~)]]></title>
    <url>%2F2018-01-15-knowledge-point.html</url>
    <content type="text"><![CDATA[面试知识点分类 算法 数据结构 设计模式 Linux网络编程 语言基础 软件应用和优化 编程思想 什么是OO语言 Gearman Gearman分布式任务处理系统（一）简介和工作原理 Gearman系列文章 PHP 2017最新PHP面试题 PHPer面试指南 面试题汇总1 面试题汇总2 PHP面试总结全 3-5年的PHPer常见的面试题 Nginx+PHP-fpm运行原理详解 PHP框架 yaf官方文档 laravel 学习笔记 —— 神奇的服务容器 laravel教程 swoole官方文档 swoole官方首页 golang 京东三级列表页持续架构优化 — Golang + Lua (OpenResty) 最佳实践 Go Web 框架性能比拼 2017 春季版 GIN框架 go 语言框架 gin 的中文文档 Golang精编100题 2017年超有价值的Golang文章 go入门知识汇总 Go语言经典笔试题 lua和openresty和nginx openresty官方文档 Nginx面试中最常见的18道题 抱佛脚必备 nginx面试要点–持续更新中 浅谈nginx + lua在安全中的一些应用 shell 分析nginx日志 教你玩转 Nginx 日志 nginx日志切割shell脚本 redis redis-热点 面试常见问题 redis面试总结 memcached面试题集锦 也谈谈 Redis 和 Memcached 的区别 你应该知道的Memcached与Redis的区别与如何抉择 redis面试总结 NoSQL数据库：Redis内存使用优化与存储 单进程单线程的Redis如何能够高并发 Redis 五种数据类型的常见用法以及应用场景 Redis 分区实现原理 redis的类型、原理及使用场景 基于redis的分布式锁实现 Redis Cluster深入与实践 API和传输格式 比起JSON 更方便、更快速、更简短的Protobuf 格式 RESTful API 设计指南 Google Protocol Buffer 的使用和原理 算法 冒泡和快速排序思想和实现 极客学院基础算法一 算法基础(极客学院) 时间复杂度和空间复杂度详解 高并发环境下生成订单唯一流水号方法:SnowFlake 全局唯一ID设计 大数据算法：对5亿数据进行排序 经典排序算法 - 归并排序Merge sort 一致性哈希算法在分布式缓存中的应用 分布式存储和一致性hash 数据结构 数据结构之字符串、散列和布隆过滤器 数据结构(极客学院) 数据结构之数组、链表、字符串、散列、布隆过滤器 名企数据结构面试题(极客学院) 设计模式 PHP 经典设计模式(完整版) 五种常见的 PHP 设计模式 PHP 设计模式 设计模式（一）——设计模式概述 设计模式(极客学院) MapReduce 如何简单解释 MapReduce 算法 ElasticStack系列 分页查询From&amp;Size VS scroll 使用scroll实现Elasticsearch数据遍历和深度分页 面试小结之Elasticsearch篇 ElasticStack HTTP/TCP/IP TAT.tennylvHTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 HTTP/2资料总结 HTTP/TCP常见面试问题总结 hit-alibaba 从输入URL到页面加载发生了什么？ 面试笔试–TCP/IP知识点 计算机网络常见面试题总结 http协议详解及htt面试题目，常见的http状态码 mysql 常见面试题整理–数据库篇（每位开发者必备） 阿里巴巴MySQL DBA面试题答案(欢迎进来讨论) MySQL索引原理及实现 MySQL常见面试题 MySQL存储引擎InnoDB与Myisam的六大区别 如何保证主从复制数据一致性 MySQL性能优化总结 每秒处理10万订单乐视集团支付架构 MySQL innoDB索引底层原理详解 如何查找MySQL中查询慢的SQL语句 MYSQL性能调优: 对聚簇索引和非聚簇索引的认识 python Python完整 常见面试题整理–Python代码篇 常见面试题整理–Python概念篇 Python面试必须要看的15个问题 Python 的闭包和装饰器 javaweb spring面试题总结 JAVA面试题 java web部分 linux系统和网络编程 Linux网络编程(极客学院) 计算机网络篇 操作系统篇 操作系统常见面试题总结 176条DevOps人员常用的linux命令速查表 Linux IO模式及 select、poll、epoll详解 常见多线程并发服务器编程模型 IO复用、多进程和多线程三种并发编程模型 进程间通信的方式——信号、管道、消息队列、共享内存 linux性能分析常用命令详解 Linux Web服务器网站故障分析常用的命令 LINUX常用的日志分析命令 网站排障分析常用的命令 Socket 基本概念 socket编程(python) Linux Socket编程（不限Linux） 揭开Socket编程的面纱 Socket基础原理 运维 搜狐Linux运维工程师面试 运维必须掌握的27道Linux面试题 运维面试题和答案 2017年企业运维岗经典面试题 Linux系统运维常见面试简答题系列（二） 2017年企业运维岗经典面试题（28题） Linux 查看负载 安全 前端需要知道的web安全知识 缓存 Web缓存详解 你有自己的Web缓存知识体系吗 缓存更新的套路 http缓存与cdn相关技术 架构 SOA和微服务架构的区别 SOA描述了一种架构模型，微服务是具体的实现? 从运维角度看中大型网站架构的演变之路 系统吞吐量（TPS）、用户并发量、性能测试概念和公式 吞吐量（Throughput）、QPS、并发数、响应时间（RT）对系统性能的影响]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识体系分类]]></title>
    <url>%2F2018-01-14-knowledge-system-catgory.html</url>
    <content type="text"><![CDATA[个人知识体系(持续完善~~) 包含未触及但想学习的领域 编程语言 Java Python GoLang PHP C++ C 指针 Node.js JavaScript HTML5 CSS3 技术支撑 操作系统 Linux MacOS Windows iOS 网络工程 OSI TCP/IP HTTP/HTTPS HTTP 1.X / HTTP 2 软件工程 算法 数据结构 设计模式 代码规范 数学 后端开发 Linux网络编程 Web前端 前端框架 jQuery Vue.js 数据格式 JSON XML JSONP Protobuf 测试 单元测试 JUnit 集成测试 自动化测试 研发工具 思维导图&amp;建模 UML 版本控制系统 Git Svn 调试工具 Charles、Wireshark Postman IDE Jetbrains IntelliJ IDEA PhpStorm Sublime Text Android Studio 构建工具 Gradle Maven 效率工具 番茄钟 Markdown 滴答清单 运维管理 监控 告警 日志 架构师 性能优化 应用技术 消息队列(MQ) 缓存 软技能 面试 知识管理 开源项目 技术博客 技术分享 时间管理 番茄工作法 目标管理 甘特图 思维导图 项目管理 团队管理 安全 移动开发 云计算 OpenStack 容器(Container) 微服务(MicroService) 大数据 MySQL NoSQL Redis MongoDB Memcached Zookeeper Kafka ElasticStack Hadoop Spark 人工智能(AI) 机器学习 财经 参考 程序员技能图谱]]></content>
      <tags>
        <tag>知识系统</tag>
        <tag>技能图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀博客]]></title>
    <url>%2F2018-01-09-excellent-blog.html</url>
    <content type="text"><![CDATA[java Hollis 机器学习 码农场 前端 IIssNan hexo+next Doublemine]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
