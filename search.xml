<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CURL用法]]></title>
    <url>%2F2018-02-08-curl-usage.html</url>
    <content type="text"><![CDATA[选项 -w 从文件中读取要打印信息的格式 -o /dev/null：把响应的内容丢弃，因为我们这里并不关心它，只关心请求的耗时情况 -s 不要打印进度条 -L 页面使用了301重定向，这时我们可以添加-L参数来跟踪URL重定向 -i --include 查看头信息, 页面响应头会和页面源码（响应体）一起返回 -I --head 只返回头信息不返回页面源码 -X 指定请求方法，配合--data添加提交数据 --data 添加提交数据,格式:”a=a1&amp;b=b1” -H --header 来指定请求头:curl -H &#39;Content-Type:application/json&#39; -H &#39;Authorization: bearer eyJhbGciOiJIUzI1NiJ9&#39; itbilu.com 请求耗时查看使用curl -w命令配置文件新建curl-format.txt文件，内容为：12345678time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\n ----------\n time_total: %&#123;time_total&#125;\n 使用123456789curl -w "@curl-format.txt" -o /dev/null -s -L "http://cizixs.com"time_namelookup: 0.012 time_connect: 0.227 time_appconnect: 0.000 time_redirect: 0.000 time_pretransfer: 0.227 time_starttransfer: 0.443 ---------- time_total: 0.867 使用httpstat命令安装pip install httpstat 使用12345# 默认请求httpstat www.baidu.com# form表单提交httpstat www.baidu.com -XPOST --data "a=a1&amp;b=b1" 参考curl 命令行工具的使用及命令参数说明使用 curl 命令分析请求的耗时情况httpstat工具]]></content>
      <tags>
        <tag>curl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysqlinnodb索引底层原理详解]]></title>
    <url>%2F2018-02-07-mysql-innodb-index.html</url>
    <content type="text"><![CDATA[MySQL的索引类型从数据结构角度 B+树索引(O(nlogn)) hash索引： 仅仅能够满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询, 无法通过操作索引来排序 检索效率最高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引 不能避免全表扫描,当存在大量相同hash值得时候，hash索引的效率会变低 FULLTEXT索引:支持full-text的字段只有char、varchar、text数据类型, 主要是用来代替like “%*%”效率低下的问题 从物理存储角度 聚簇索引（clustered index） 非聚簇索引（non-clustered index） 从逻辑角度 主键索引(PRIMARY)：主键索引是一种特殊的唯一索引，不允许有空值 普通索引(NORMAL)或单列索引 多列索引（复合索引)：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合 唯一索引或者非唯一索引 索引添加 1ALTER TABLE `tab1` ADD INDEX `idx_index_name` USING BTREE (`field1`, `field2`) comment ''; 平衡二叉树（Balanced Binary Tree)性质 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1 并且左右两个子树都是一棵平衡二叉树。 常用算法平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等 BTree,B+TreeB树(即二叉搜索树) 所有非叶子结点至多拥有两个儿子（Left和Right） 所有结点存储一个关键字； 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树； B+树 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； 总结 B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3； B+Tree索引实现原理B+树概念B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。 B+树示意图： InnoDB数据页结构组成部分：File Header(文件头)、Page Header(页头)、Infimun + Supremum Records、User Records(用户记录，即行记录)、Free Space(空闲空间)、Page Directory(页目录)、File Trailer(文件结尾信息) 页是InnoDB存储引擎管理数据库的最小磁盘单位,InnoDB中的页大小为16KB，且不可以更改。 叶子节点(页与页之间)是双向链表串起来的，头连上一页的尾，尾连下一页的头 每个数据页中有两个虚拟的行记录，用来限定记录的边界。(行记录是记录在页中的，同时是在页内行记录之间也是双向链表链接的) 页目录(Page Directory)通过顺序排放的记录指针(也叫槽)存放了记录的相对位置，这些通过这些槽找到具体的数据位置 页目录中存放了记录的相对位置，有些时候这些记录指针称为Slots（槽）或者目录槽，与其他数据库不同的是，InnoDB并不是每个记录拥有一个槽，InnoDB中的槽是一个稀疏目录，即一个槽中可能属于多个记录，最少属于4个目录，最多属于8个目录。槽中记录按照键顺序存放，这样可以利用二叉查找迅速找到记录的指针。但是由于InnoDB中的Slots是稀疏目录，二叉查找的结果只是一个粗略的结果，所以InnoDB必须通过recorder header中的next_record来继续查找相关记录。同时slots很好的解释了recorder header中的n_owned值的含义，即还有多少记录需要查找，因为这些记录并不包括在slots中 查询B+树索引的流程首先通过B+树索引找到叶节点，再找到对应的数据页，然后将数据页加载到内存中，通过二分查找Page Directory中的槽，查找出一个粗略的目录，然后根据槽的指针指向链表中的行记录，之后在链表中依次查找。 注意： B+树索引不能找到具体的一条记录，而是只能找到对应的页。把页从磁盘装入到内存中，再通过Page Directory进行二分查找，同时此二分查找也可能找不到具体的行记录（有可能会找到），只是能找到一个接近的链表中的点，再从此点开始遍历链表进行查找。 聚簇索引/非聚簇索引区别： 聚簇索引一般是为主键索引，一张表只能有一个聚簇索引，B+树的叶子节点存储了行数据和主键。 非聚簇索引可以有多个，叶节点除了包含关键字键值外还包含聚集索引的主键 聚集索引 聚集索引是按每张表的主键构造的一颗B+树，并且叶节点中存放着整张表的行记录数据，因此也让聚集索引的节点成为数据页，这个特性决定了索引组织表中数据也是索引的一部分。由于实际的数据页只能按照一颗B+树进行排序，所以每张表只能拥有一个聚集索引。查询优化器非常倾向于采用聚集索引，因为其直接存储行数据，所以主键的排序查询和范围查找速度非常快。 不是物理上的连续，而是逻辑上的，不过在刚开始时数据是顺序插入的所以是物理上的连续，随着数据增删，物理上不再连续。 辅助索引 辅助索引页级别不包含行的全部数据。叶节点除了包含键值以外，每个叶级别中的索引行中还包含了一个书签，该书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。其中存的就是聚集索引的键。 辅助索引的存在并不影响数据在聚集索引的结构组织。InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引找到一个完整的行记录。当然如果只是需要辅助索引的值和主键索引的值，那么只需要查找辅助索引就可以查询出索要的数据，就不用再去查主键索引了。 什么是一级索引、二级索引及生成场景每个InnoDB表具有一个特殊的索引称为聚簇索引（也叫聚集索引，聚类索引，簇集索引）。 如果表上定义有主键，该主键索引就是聚簇索引。 如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。 表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes） MyISAM和InnoDB索引实现原始数据如图： MyISAM引擎索引实现方式索引实现原理 是按列值与行号来组织索引的。它的叶子节点中保存的实际上是指向存放数据的物理块的指针。从MYISAM存储的物理文件我们能看出，MYISAM引擎的索引文件（.MYI）和数据文件(.MYD)是相互独立的。 主键索引与二级索引 MyISAM的主键索引和二级索引叶子节点存放的都是：列值与行号的组合，叶子节点中保存的是数据的物理地址 MYISAM的主键索引和二级索引没有任何区别：主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。 InnoDB引擎索引实现方式1. 聚簇索引(一级索引) 聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC）和余下的列(如col2)，如下图： 2. 非聚簇索引(二级索引) InnoDB的二级索引与主键索引有很大的不同，InnoDB的的二级索引的叶子节点存放的是：KEY字段加主键值，而不是行指针(row pointers)，如下图 二级索引查询步骤：先查到主键值，然后InnoDB再根据查到的主键值通过主键索引找到对应的数据块。 INNODB和MYISAM的主键索引与二级索引的对比如图： 参考资料：高性能MYSQL 参考平衡树BTree,B-Tree,B+Tree,B*Tree都是什么MySQL有哪些索引类型 ?mysql索引类型 normal, unique, full textMySQL_innoDB索引底层原理详解MYSQL性能调优: 对聚簇索引和非聚簇索引的认识面试知识点6：MySQL中InnoDB的一级索引、二级索引]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>索引原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试题汇总 (三)]]></title>
    <url>%2F2018-02-07-php-Interview-question-3.html</url>
    <content type="text"><![CDATA[归并排序算法原理算法思路 时间复杂度：O(nlogn) 把 n 个记录看成 n 个长度为 l 的有序子表 进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 实例两个正序数组，如[3 4 7 9], [2 6 8] 如何合并成一个正序数组假设：序列A：3 4 7 9序列B：2 6 8序列C：空合并思路是：先申请一个序列，将指针分别指向3和2，这时候进行比较，3大于2，所以把2放到序列C，序列B指针后移到6，这时候序列A的3小于6，把3放到序列C，A序列指针后移4小于序列B的6，把4放到序列C，依次类推。。。直到最后只剩下序列A中的9，把9合并到序列C，完成归并排序 一致性HASH原理和应用 问题：单机redis20G如何承载500G的cache（考虑redis集群应用） 应用场景如何对请求与缓存服务器之间进行精准映射,以及优雅的扩展，剔除缓存服务器，提升缓存服务的容错性和扩展性 容错性：指当系统中某一个或几个服务器变得不可用时，整个系统是否可以正确高效运行； 扩展性：指当加入新的服务器后，整个系统是否可以正确高效运行。 算法概述一致性哈希将整个哈希空间组织成一个虚拟的圆环，假如整个哈希函数的值空间为0 - 2^32 -1(一个32位的无符号整形)，如下图:整个空间按顺时针方向组织,0和232-1在零点中方向重合 第一步：在哈希闭环中确定各台服务器位置 将各台服务器的ip或主机名为关键字通过H函数得到一个哈希值，然后在哈希闭环中标注位置。如下图3台redis服务： 第二步：定位数据访问的服务器 将数据key使用相同的函数H计算出哈希值h，通根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器 例如我们缓存服务器中有A、B、C、D四个key对应的数据对象，经过哈希计算后，在环空间上的位置如下： 容错性与可扩展性分析 假设redis-2宕机：ACD节点并不受影响，只有B节点被重定向至Redis-0 如果我们在系统中增加一台服务器Redis-3 Server：对于C这个key，重新定位至Redis-3 服务器，其他非C的key均不受影响 数据倾斜问题1. 问题概述 一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，必然造成大量数据集中到Redis-1上，而只有极少量会定位到Redis-0上。如下图 2. 使用虚拟节点解决 对每一个服务节点多计算N个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布 第一步：为每个机器多增加N个虚拟节点 为每个机器多计算三个虚拟节点，分别计算“Redis-1 #1”、“Redis-1 #2”、“Redis-1 #3”、“Redis-0 #1”、“Redis-0 #2”、“Redis-0 #3”的哈希值，于是形成六个虚拟节点: 第二步：将虚拟节点映射到实际节点 数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Redis-1#1”、“Redis-1#2”、“Redis-1#3”三个虚拟节点的数据均定位到Redis-1上 参考一致性哈希算法在分布式缓存中的应用 MySQL索引Redis常用类型及内部实现原理考察：常用类型和zset的实现原理参考Redis原理和应用场景 进程、线程、轻量级进程、协程和go中的Goroutine并行和并发区别?并行是指程序的运行状态，要有两个线程正在执行才能算是Parallelism；并发指程序的逻辑结构，Concurrency则只要有两个以上线程还在执行过程中即可。简单地说，Parallelism要在多核或者多处理器情况下才能做到，而Concurrency则不需要。 为什么要用协程?协程是否需要进行内核态的切换？答案：不需要 参考：进程、线程、轻量级进程、协程和go中的Goroutine 那些事儿进程、线程、轻量级进程、协程与 go 的 goroutine【转载+整理】Golang协程详解 TCP/IP协议考察：三次握手、四次挥手、为什么需要三次握手？为什么需要2MSL？ HTTP协议协议详解和HTTP头相关参数的使用（expired,cache）HTTP状态码]]></content>
      <tags>
        <tag>面试</tag>
        <tag>一致性哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序算法]]></title>
    <url>%2F2018-02-07-algorithm-merging-sorting.html</url>
    <content type="text"><![CDATA[算法思路 把 n 个记录看成 n 个长度为 l 的有序子表 进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 原理归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，其中的分治法是常用的一种解决问题的方法，现在流行的云计算其实就是一种分治法的应用。 归并算法详解 归并排序的中心思想：申请一个空序列，将两个已经排序好的序列，合并成一个排序的序列 假设：序列A：3 4 7 9序列B：2 6 8序列C：空合并思路是：先申请一个序列，将指针分别指向3和2，这时候进行比较，3大于2，所以把2放到序列C，序列B指针后移到6，这时候序列A的3小于6，把3放到序列C，A序列指针后移4小于序列B的6，把4放到序列C，依次类推。。。直到最后只剩下序列A中的9，把9合并到序列C，完成归并排序 分治法 字面解释就是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个思想在实际工作中的作用非常大，特别是处理大数据和做复杂运算的时候。 假设：无序序列：4 3 7 9 2 8 6将数组分成长度为2，并使每个子数组有序：[3, 4] [7, 9] [2, 8] [6]然后分别两个一对进行归并，然后就可以得到最终的有序序列：2 3 4 6 7 8 缺点归并排序的一个缺点是它需要存储器有另一个大小等于数据项数目的数组。如果初始数组几乎占满整个存储器，那么归并排序将不能工作，但是如果有足够的空间，归并排序会是一个很好的选择。 参考常见排序算法 - 归并排序 (Merge Sort)_有图经典排序算法 - 归并排序Merge sort详解PHP归并排序的实现大数据算法：对5亿数据进行排序]]></content>
      <tags>
        <tag>算法</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点汇总]]></title>
    <url>%2F2018-02-07-interview-knowledge-point.html</url>
    <content type="text"><![CDATA[知识点面试知识点总结(持续更新~~) 算法常见算法 PHPPHP面试题汇总一php面试题汇总二Nginx+PHP-fpm运行原理详解2017最新PHP面试题设计模式设计模式面试题 LinuxLinux服务器网站故障分析常用的命令linux网络编程TCP/IP知识点 MySQLMySQL知识点MySQL性能优化总结 NoSQLNoSQL数据库知识点]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux服务器网站故障分析常用的命令]]></title>
    <url>%2F2018-02-07-linux-failure-analysis-command.html</url>
    <content type="text"><![CDATA[常用命令简单说明grep 命令 grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来 格式grep [option] pattern file 选项-v –revert-match #显示不包含匹配文本的所有行-w –word-regexp #只显示全字符合的列-h –no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称 awk命令 是一种处理文本文件的语言，是一个强大的文本分析工具 规则：awk [选项参数] ‘条件1{动作1} 条件2{动作2} …’ 文件名（ 如果条件1，执行动作1；如果条件2，执行动作2 ） 变量 ：$1：提取第一列 ,$2提取第二列, 选项-F :指定输入文件折分隔符 输出print：会在每个输出之后自动加入一个换行符printf：标准格式输出命令，需要换行需手动加入 应用123awk '&#123;printf $2 "\t" $3"\n"&#125;' user.txtawk -F, '&#123;print $1,$2&#125;' log.txtawk -F '[ ,]' '&#123;print $1,$2,$5&#125;' log.txt # 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割 cut命令 提取列: cut [选项] 文件 选项:-f 列号 （ –field 提取第几列 ）-d 分隔符 （ –delimiter 按照指定分隔符分割列 ） 应用：1cut -d ":" -f 1,3 /etc/passwd # :分隔，输出1，3行 sed命令 数据进行选取、替换、删除、新增的命令 使用方法：sed [选项] ‘[动作]’ 文件名 选项-n : 一般sed命令会把所有数据都输出到屏幕；如果加入此选项，则只会把经过sed命令处理的行输出到屏幕。(如：sed -n ‘2p’ user.txt # 输出第二行) 动作d : 删除，删除指定的行。p : 打印，输出指定的行。s : 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似）如：sed “s/r//g” user.txt 替换r为空 实例：12sed -n '2p' user.txt # 输出第二行, p一般都要和-n使用，不加-n会显示出所有的行sed "s/r//g" user.txt # 替换r为空 sort命令 排序 选项-n：按数值排序，默认按ASCII码值排序\u：在输出行中去除重复行-r：降序(默认是降序)-o：输出结果重定向到文件\t：指定间隔符(配合-k指定列数排序)-k: 指定列排序 netstat 命令 用于显示各种网络相关信息，如网络连接，路由表，接口状态 选项-a (all)显示所有选项，默认不显示LISTEN相关(如果需要显示LISTEN相关需增加-l选项)-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名 系统连接状态 查看TCP连接状态常用：1netstat -ant |awk '&#123;print $6&#125;'|sort|uniq -c|sort -rn 可用：1234netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125;;END &#123;for(a in S) print a, S[a]&#125;' netstat -n | awk '/^tcp/ &#123;++state[$NF]&#125;; END &#123;for(key in state) print key,"t",state[key]&#125;'netstat -n | awk '/^tcp/ &#123;++arr[$NF]&#125;;END &#123;for(k in arr) print k,"t",arr[k]&#125;'netstat -n |awk '/^tcp/ &#123;print $NF&#125;'|sort|uniq -c|sort -rn 查找请求数20个IPnetstat -anlp|grep 80|grep tcp|awk &#39;{print $5}&#39;|awk -F: &#39;{print $1}&#39;|sort|uniq -c|sort -nr|head -n20 netstat -ant |awk &#39;/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}&#39; |sort -rn|head -n20 用tcpdump嗅探80端口的访问看看谁最高tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#39; | sort | uniq -c | sort -nr |head -20 查找较多time_wait连接netstat -n|grep TIME_WAIT|awk &#39;{print $5}&#39;| cut -d &#39;:&#39; -f 1 | sort|uniq -c|sort -rn|head -n2 找查较多的SYN连接netstat -an | grep SYN | awk &#39;{print $5}&#39; | awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -nr | more 根据端口列进程netstat -ntlp | grep 80 | awk &#39;{print $NF}&#39; | cut -d &#39;/&#39; -f1 nginx日志知识 nginx有一个非常灵活的日志记录模式。每个级别的配置可以有各自独立的访问日志。日志格式通过log_format命令来定义。 access_log指令语法: access_log path [format [buffer=size [flush=time]]];123access_log path format gzip [=level] [buffer=size] [flush=time];access_log syslog:server=address\[,parameter=value] [format];access_log off; 默认值: access_log logs/access.log combined;配置段: http, server, location, if in location, limit_exceptgzip：压缩等级。buffer：设置内存缓存区大小。flush：保存在缓存区中的最长时间。不记录日志：access_log off;使用默认combined格式记录日志：access_log logs/access.log 或 access_log logs/access.log combined; log_format指令 语法: log_format name string …; 默认值: log_format combined “…”; 配置段: httpname表示格式名称，string表示等义的格式。 默认配置：log_format有一个默认的无需设置的combined日志格式 1log_format combined '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"'; 对应的日志记录:12127.0.0.1 - - [21/Sep/2016:10:57:04 +0800] "GET / HTTP/1.1" 302 5 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36" "-" 127.0.0.1 - - [21/Sep/2016:10:57:04 +0800] "GET /dashboard.php HTTP/1.1" 200 26652 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36" "-" 日志格式变量含义 1234567891011121314151617$remote_addr, $http_x_forwarded_for 记录客户端IP地址$remote_user 记录客户端用户名称$request 记录请求的URL和HTTP协议$status 记录请求状态$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。$bytes_sent 发送给客户端的总字节数。$connection 连接的序列号。$connection_requests 当前通过一个连接获得的请求数量。$msec 日志写入时间。单位为秒，精度是毫秒。$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。$http_referer 记录从哪个页面链接访问过来的$http_user_agent 记录客户端浏览器相关信息$request_length 请求的长度（包括请求行，请求头和请求正文）。$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。$time_iso8601 ISO8601标准格式下的本地时间。$time_local 通用日志格式下的本地时间。[warning]发送给客户端的响应头拥有“sent_http_”前缀。 比如$sent_http_content_range。[/warning] 常见问题 获取真实客户IP：如果nginx位于负载均衡器，squid，nginx反向代理之后，web服务器无法直接获取到客户端真实的IP地址了。 $remote_addr获取反向代理的IP地址。反向代理服务器在转发请求的http头信息中，可以增加X-Forwarded-For信息，用来记录 客户端IP地址和客户端请求的服务器地址。PS: 获取用户真实IP 参见http://www.ttlsa.com/html/2235.html 网站日志分析篇(nginx) 获得访问前10位的ip地址 123cat nginx.log | awk '&#123;print $1&#125;' | sort | uniq -c | sort -nr | head -n 10 cat nginx.log|awk '&#123;counts[$(1)]+=1&#125;; END &#123;for(url in counts) print counts[url], url&#125;' | sort -nr 访问次数最多的文件或页面,取前20cat nginx.log | awk &#39;{print $7}&#39; | grep -E &quot;^/.*&quot; | sort | uniq -c | sort -nr | head -n 20 统计404的连接cat nginx.log | awk &#39;/ 404 /{print $7}&#39; | sort | uniq -c | sort -nr | more 系统Debug分析篇1.调试命令strace -p pid2.跟踪指定进程的PIDgdb -p pid 参考：Linux Web服务器网站故障分析常用的命令nginx日志配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式面试题]]></title>
    <url>%2F2018-02-06-design-pattern-interview-question.html</url>
    <content type="text"><![CDATA[控制反转（IoC）与依赖注入（DI） 控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。 通过IoC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。 参考：控制反转（IoC）与依赖注入（DI） 理解PHP依赖注入和Laravel的IOC容器依赖注入：把一个类中可变换的部分提取出来抽象为单独的类，然后在将实例变量注入到原来的类中，供原始类进行使用IOC容器：控制反转是工程中解耦合的思想，本来需要自己new的类现在完全交给了容器去实例化，比如类A依赖B类，容器创建B的实例，类A只管使用即可。Laravel中Phalcon\DI就是这个容器的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass SomeComponent&#123; protected $_di; public function __construct($di) &#123; $this-&gt;_di = $di; &#125; public function someDbTask() &#123; // Get the connection service // Always returns a new connection $connection = $this-&gt;_di-&gt;get('db'); &#125; public function someOtherDbTask() &#123; // Get a shared connection service, // this will return the same connection everytime $connection = $this-&gt;_di-&gt;getShared('db'); //This method also requires a input filtering service $filter = $this-&gt;_db-&gt;get('filter'); &#125;&#125;$di = new Phalcon\DI();//Register a "db" service in the container$di-&gt;set('db', function()&#123; return new Connection(array( "host" =&gt; "localhost", "username" =&gt; "root", "password" =&gt; "secret", "dbname" =&gt; "invo" ));&#125;);//Register a "filter" service in the container$di-&gt;set('filter', function()&#123; return new Filter();&#125;);//Register a "session" service in the container$di-&gt;set('session', function()&#123; return new Session();&#125;);//Pass the service container as unique parameter$some = new SomeComponent($di);$some-&gt;someTask(); 参考：理解PHP 依赖注入|Laravel IoC容器]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018-02-05-design-pattern.html</url>
    <content type="text"><![CDATA[创建性模式单例模式(Singleton) 要求：只有一个实例，自行创建实例并对外提供这个实例 实现:1234567891011121314151617181920212223class Mysql &#123; private static $conn; private function __construct() &#123; self::$conn = new PDO("mysql:dbname=testdb;host=127.0.0.1", "root", "root"); &#125; public static function getInstance() &#123; if(!(self::$conn instanceof self))&#123; self::$conn = self; &#125; return self::$conn; &#125; //防止对象被复制 public function __clone()&#123; trigger_error('Clone is not allowed !'); &#125; //防止反序列化后创建对象 public function __wakeup() &#123; trigger_error('Unserialized is not allowed !'); &#125;&#125;$mysql = Mysql::getInstance(); 简单工厂模式 要求：获取一个实例不通过new关键字获取，都是通过一个工厂类的工厂方法得到这个类的实例 规则： 工厂类必须有一个工厂方法 工厂类必须能够返回一个业务类实例 一次只能创建和返回一个实例 实现：123456789101112131415161718192021222324252627&lt;?phpclass SimpleFactory &#123; public function create($name) &#123; return new $name(); &#125;&#125;abstract class Vehicle &#123; abstract public function driveTo($dest);&#125;class Bicycle extends Vehicle &#123; public function driveTo($dest) &#123; return '骑自行车去:'.$dest; &#125;&#125;class Car extends Vehicle &#123; public function driveTo($dest) &#123; return '开汽车去:'.$dest; &#125;&#125;//应用$factory = new SimpleFactory();$vehicle = $factory -&gt; create('Bicycle');print($vehicle -&gt; driveTo('北京')); 结构性模式适配器模式接口的应用12345678910111213141516171819202122232425262728293031323334interface Database &#123; public function connect(); public function query(); public function close();&#125;class DBMysql implements Database &#123; public function connect() &#123; var_dump(__METHOD__); &#125; public function query() &#123; var_dump(__METHOD__); &#125; public function close() &#123; var_dump(__METHOD__); &#125;&#125;class DBPdo implements Database &#123; public function connect() &#123; var_dump(__METHOD__); &#125; public function query() &#123; var_dump(__METHOD__); &#125; public function close() &#123; var_dump(__METHOD__); &#125;&#125;$database = new DBMysql();//切换数据库只要改这一行就行了，因为后面的都是标准接口方法，不管哪个数据库都一样$database-&gt;connect();$database-&gt;query();$database-&gt;close(); 问题有的三方接口并没有按照标准接口实现，如下：123456789101112//第三方数据库类class Oracle &#123; public function oracleConnect()&#123; //Oracle 的逻辑 &#125;; public function oracleQuery()&#123; //Oracle 的逻辑 &#125;; public function oracleClose()&#123; //Oracle 的逻辑 &#125;;&#125; 这时候适配器就派上用场了，用这个适配器将异类的方法转换为接口标准方法适配器模式12345678910111213141516class Adapter implements Database &#123; private $adaptee; function __construct($adaptee) &#123; $this-&gt;adaptee = $adaptee; &#125; //这里把异类的方法转换成了 接口标准方法，下同 public function connect()&#123; $this-&gt;adaptee-&gt;oracleConnect(); &#125;; public function query()&#123; $this-&gt;adaptee-&gt;oracleQuery(); &#125;; public function close()&#123; $this-&gt;adaptee-&gt;oracleClose(); &#125;;&#125; 应用：123456$adaptee = new Oracle(); $adapter = new Adapter($adaptee);//只要改这个类就行了，后面的都可以不用改；$database = $adapter;$database-&gt;connect();$database-&gt;query();$database-&gt;close(); 装饰器模式解决问题：为某个方法装饰可以自由删除或增加的逻辑(如果遇到) 场景：比如有一个煮咖啡的程序，默认是纯咖啡，如何方便的选择是否加糖、加奶、加巧克力呢？ 1234567//主咖啡程序class plainCoffee &#123; public function makeCoffee()&#123; $this-&gt;addCoffee(); &#125; public function addCoffee()&#123;&#125;&#125; 一般逻辑：加糖 1234567class sweetCoffee extends plainCoffee &#123; public function makeCoffee()&#123; $this-&gt;addCoffee(); $this-&gt;addSugar(); &#125; public function addSugar()&#123;&#125;&#125; 弊端：如果这时候加奶、加巧克力就需要继续继承重写makeCoffee 装饰器方式：在addCoffee前后增加逻辑处理 1234567891011121314151617181920212223//调整煮咖啡程序class plainCoffee &#123; private $decorators; public function addDecorator($decorator)&#123; $this-&gt;decorators[] = $decorator; &#125; private function before()&#123; foreach($this-&gt;decorators as $decorator)&#123; $decorator-&gt;before() &#125; &#125; private function after()&#123; foreach($this-&gt;decorators as $decorator)&#123; $decorator-&gt;after() &#125; &#125; public function makeCoffee()&#123; $this-&gt;before(); $this-&gt;addCoffee(); $this-&gt;after(); &#125; public function addCoffee()&#123;&#125;&#125; 编写装饰器： 12345678class sweetCoffeeDecorator&#123; public function before()&#123; &#125; public function after()&#123; $this-&gt;addSugar(); &#125; public function addSugar()&#123;&#125;&#125; 应用：加糖加奶只需要增加装饰器即可，不需要只需注释掉。 1234$coffee = new plainCoffee();$coffee-&gt;addDecorator(new sweetCoffeeDecorator());$coffee-&gt;addDecorator(new milkCoffeeDecorator());$coffee-&gt;makeCoffee(); 总结：当你extends用过后又遇到需要再次extends的情况时，不妨考虑一下装饰器模式 依赖注入原理：把一个类不可能更换的部分 和 可更换的部分分离开来，通过注入的方式来使用，从而达到解耦的目的。一个数据库连接类12345678910111213141516171819202122//数据库连接class Mysql&#123; private $host; private $port; private $username; private $password; private $db_name; public function __construct()&#123; $this-&gt;host = '127.0.0.1'; $this-&gt;port = 22; $this-&gt;username = 'root'; $this-&gt;password = ''; $this-&gt;db_name = 'my_db'; &#125; public function connect()&#123; return mysqli_connect($this-&gt;host,$this-&gt;username ,$this-&gt;password,$this-&gt;db_name,$this-&gt;port); &#125;&#125;//使用：$db = new Mysql();$con = $db-&gt;connect(); 依赖注入：将可变部分(配置)提取出来抽象为一个类，然后在注入到原类中，这样就完成了配置文件和连接逻辑的分离。123456789101112131415161718192021222324252627282930313233343536373839404142//配置类class MysqlConfiguration &#123; private $host; private $port; private $username; private $password; private $db_name; public function __construct($host, $port, $username, $password, $db_name) &#123; $this-&gt;host = $host; $this-&gt;port = $port; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;db_name = $db_name; &#125; public function getHost() &#123; return $this-&gt;host; &#125; public function getPort() &#123; return $this-&gt;port; &#125; public function getUsername()&#123; return $this-&gt;username; &#125; public function getPassword() &#123; return $this-&gt;password; &#125; public function getDbName() &#123; return $this-&gt;db_name; &#125;&#125;//Mysql变更为：class Mysql &#123; private $configuration; public function __construct(MysqlConfiguration $config) &#123; $this-&gt;configuration = $config; &#125; public function connect() &#123; return mysqli_connect($this-&gt;configuration-&gt;getHost(), $this-&gt;configuration-&gt;getUsername(), $this-&gt;configuration-&gt;getPassword, $this-&gt;configuration-&gt;getDbName(), $this-&gt;configuration-&gt;getPort()); &#125;&#125; 使用：$config是注入Mysql的，这就是所谓的依赖注入。123$config = new MysqlConfiguration('127.0.0.1','root','','my_db',22);$db = new Mysql($config);$con = $db-&gt;connect(); 链式操作123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Employee&#123; public $name; public $surName; public $salary; public function setName($name) &#123; $this-&gt;name = $name; return $this; &#125; public function setSurname($surname) &#123; $this-&gt;surName = $surname; return $this; &#125; public function setSalary($salary) &#123; $this-&gt;salary = $salary; return $this; &#125; public function __toString() &#123; $employeeInfo = 'Name: ' . $this-&gt;name . PHP_EOL; $employeeInfo .= 'Surname: ' . $this-&gt;surName . PHP_EOL; $employeeInfo .= 'Salary: ' . $this-&gt;salary . PHP_EOL; return $employeeInfo; &#125;&#125;//链式操作的效果$employee = (new Employee()) -&gt;setName('Tom') -&gt;setSurname('Smith') -&gt;setSalary('100');echo $employee;# 输出结果# Name: Tom# Surname: Smith# Salary: 100 行为性模式观察者模式需求：有一个listener和handler，当listener监听到一个事件发生，多个handler自动处理对应的逻辑原理： 声明抽象事件发生者类(EventGenerator)，负责添加观察者和逐一调用观察者的update方法进行通知。 声明观察者接口类(Observer)，提供抽象方法update，所有的观察者都实现这个接口 具体的事件继承EventGenerator类，然后调用addObserver添加观察者，调用trigger进行触发。 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//声明一个抽象的事件发生者基类abstract class EventGenerator&#123; private $observers = array(); //添加观察者方法 function addobserver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; //对每个添加的观察者进行事件通知 function notify() &#123; //对每个观察者逐个去更新 foreach($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125;//声明一个观察者接口interface observer &#123; function update($event_info = null);&#125;//声明具体事件类，继承了主事件class Event extends EventGenerator&#123; function trigger() &#123; echo "Event&lt;br/&gt;"; $this-&gt;notify(); &#125;&#125;//声明多个观察者class Observer1 implements observer&#123; function update($event_info = null) &#123; echo "逻辑1&lt;br/&gt;"; &#125;&#125;class Observer2 implements observer&#123; function update($event_info = null) &#123; echo "逻辑2&lt;br/&gt;"; &#125;&#125; 应用：12345//Event基类里的foreach，可以实现一个事件对应多个观察者$event = new Event;$event-&gt;addObserver(new Observer1);$event-&gt;addObserver(new Observer2);$event-&gt;trigger(); 策略模式需求 ：针对大量ifelse判断上下文的环境所作出的策略。原理：提供一个策略接口(Strategy)，其中定义待实现方法，其他策略实现这个接口，业务逻辑中只调用接口中定义的方法。举例：商城的首页，男的进来看男性商品，女的进来看女性商品，不男不女…以此类推，各种条件下用不同策略展示不同商品实现:123456789101112131415161718192021222324252627//showStrategy.php 展示策略接口interface showStrategy&#123; public function showCategory();&#125;//maleShowStrategy.php 男性用户展示策略class maleShowStrategy implements showStrategy &#123; // 具体策略A public function showCategory()&#123; echo '展示男性商品目录'; &#125;&#125;//femaleShowStrategy.php 女性用户展示策略class femaleShowStrategy implements showStrategy &#123; // 具体策略B public function showCategory()&#123; echo '展示女性商品目录'; &#125;&#125;//page.php 展示页面class Page&#123; private $_strategy; public function __construct(Strategy $strategy) &#123; $this-&gt;_strategy = $strategy; &#125; public function showPage() &#123; $this-&gt;_strategy-&gt;showCategory(); &#125;&#125; 使用12345678if(isset($_GET['male']))&#123; $strategy = new maleShowStrategy();&#125;elseif(isset($_GET['female']))&#123; $strategy = new femaleShowStrategy();&#125;//注意看这里上下，Page类不再依赖一种具体的策略，而是只需要绑定一个抽象的接口，这就是传说中的控制反转（IOC）。$question = new Page($strategy);$question-&gt;showPage(); 总结仔细看上面的例子，不复杂，我们发现有2个好处： 它把if else 抽离出来了，不需要在每个类里都写if else；它成功的实现了控制反转，Page类里没有具体的依赖策略，这样我们就可以随时添加和删除 不同的策略。 模板方法这是最常见的设计模式之一，其实质就是父类提供一系列模板方法，有的实现了逻辑，有的只是一个接口。而子类继承大部分共有方法，同时对接口方法进行不同的实现，从而完成对父类模板的个性化改造，起到一对多的解耦目的。 可以说PHP的抽象类就是为了实现这个设计模式而推出的功能，在PHP中，抽象类本身就是模板方法模式。应用: 123456789101112131415161718192021222324252627282930313233343536//Journey.php 模板类abstract class Journey&#123; private $thingsToDo = []; //final关键字的作用是不让这个方法被子类覆盖 final public function takeATrip() &#123; $this-&gt;thingsToDo[] = $this-&gt;buyAFlight(); $this-&gt;thingsToDo[] = $this-&gt;takePlane(); $this-&gt;thingsToDo[] = $this-&gt;enjoyVacation(); $buyGift = $this-&gt;buyGift(); if ($buyGift !== null) &#123; $this-&gt;thingsToDo[] = $buyGift; &#125; $this-&gt;thingsToDo[] = $this-&gt;takePlane(); &#125;//子类必须实现的抽象方法 abstract protected function enjoyVacation(): string; protected function buyGift() &#123; return null; &#125; private function buyAFlight(): string &#123; return 'Buy a flight ticket'; &#125; private function takePlane(): string &#123; return 'Taking the plane'; &#125; //把所有旅行中干过的事情列出来 public function getThingsToDo(): array &#123; return $this-&gt;thingsToDo; &#125;&#125; 123456789101112131415161718192021//BeachJourney.php子类一class BeachJourney extends Journey&#123; protected function enjoyVacation(): string &#123; return "Swimming and sun-bathing"; &#125;&#125;//BeachJourney.php子类二class CityJourney extends Journey&#123; protected function enjoyVacation(): string &#123; return "Eat, drink, take photos and sleep"; &#125;//覆盖父类已有方法 protected function buyGift(): string &#123; return "Buy a gift"; &#125;&#125; 参考： 四种常见设计模式 PHP 经典设计模式]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux网络编程]]></title>
    <url>%2F2018-02-05-linux-network-program.html</url>
    <content type="text"><![CDATA[select, poll和epoll的区别 什么是多路I/O复用（Epoll）（1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理（2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件（3） 为了提升服务器线程处理效率，有以下三种思路 （1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转 （2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N） （3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1) 其它开源软件采用的模型 Nginx：多进程单线程模型Memcached：单进程多线程模型]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL知识点]]></title>
    <url>%2F2018-02-05-mysql.html</url>
    <content type="text"><![CDATA[数据库三大范式1. 第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式 第一范式需要按照系统的实际需求来定。比如一般”地址”这个属性都是一个字段就可以了，但是如果系统经常访问城市，那就可以对地址进行拆分，这样在对地址进行查询的时候就比较的方便。 上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能 2. 第二范式(确保表中的每列都和主键相关) 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中 如图：订单信息表：一个订单中可能有多个商品，所以将订单号和商品编号作为联合主键。上图中商品名称、单位、价格只与商品有关于订单号无关，所以是不满足第二范式的。这时候应该把商品信息拆分为单独的表，如下： 3. 第三范式(确保每列都和主键列直接相关,而不是间接相关) 满足第三范式（3NF）必须先满足第二范式（2NF）。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息 参考数据库设计三大范式 mysql创建索引原则 较频繁的作为查询条件的字段应该创建索引 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 更新非常频繁的字段不适合创建索引 不会出现在WHERE子句中的字段不该创建索引 数据库优化的思路1. SQL语句优化 避免select * 字段尽可能的使用 NOT NULL 尽量避免在 !=或&lt;&gt;和not in操作符,避免全表扫描 where 及 order by 涉及的列上建立索引 尽量少使用join查询 2. 索引优化合理增加索引，查看 mysql创建索引原则 3. 数据库结构优化 范式优化：消除冗余（节省空间） 反范式优化:比如适当加冗余等（减少join) 表的垂直拆分和水平拆分 4. 服务器硬件优化 提升服务器硬件配置 5. 缓存机制 添加缓存机制，使用(redis,memcache) 不经常改动的使用静态页面 表的垂直拆分和水平拆分垂直拆分 垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表 原则 把不常用的字段单独放在一张表; 把text，blob等大字段拆分出来放在附表中; 经常组合查询的列放在一张表中;ps:垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关键起来即可; 水平拆分 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放. 拆分原则通常使用取模的方式来进行表的拆分 应用比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4通过用ID取模的方法把数据分散到四张表内Id%4+1 = [1,2,3,4]插入：在insert时还需要一张临时表uid_temp来提供自增的ID,该表的唯一用处就是提供自增的ID;得到自增的ID后,又通过取模法进行分表插入然后查询,更新,删除也是通过取模的方法来查询1234$_GET['id'] = 17,17%4 + 1 = 2, $tableName = 'users'.'2'Select * from users2 where id = 17; 注意:进行水平拆分后的表,字段的列和类型和原表应该是相同的,但是要记得去掉auto_increment自增长 drop,delete与truncate的区别 delete和truncate只删除表的数据不删除表的结构, trucate删除表数据自增id从1开始，delete删除可加where语句 速度,一般来说: drop&gt; truncate &gt;delete delete语句是dml,这个操作会放到rollback中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 数据库事务的四个特性及含义 数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。 持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚 查找慢SQL查询开启慢查询配置 slow_query_log 这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。 long_query_time 当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。 slow_query_log_file 记录日志的文件名 log_queries_not_using_indexes 这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。 检测执行效率1. 查看慢查询日志查看slow_query_log_file配置的文件 2. show processlist 命令 SHOW PROCESSLIST显示哪些线程正在运行 各列的含义和用途 ID列：一个标识，你要kill一个语句的时候很有用，用命令杀掉此查询 mysqladmin kill 进程号。 user列：显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句。 host列：显示这个语句是从哪个ip的哪个端口上发出的。用于追踪出问题语句的用户。 db列：显示这个进程目前连接的是哪个数据库。 command列：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）。 time列：此这个状态持续的时间，单位是秒。 state列：显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个 sql语句，以查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成 info列：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据 3. explain来了解SQL执行的状态 explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句 3.1 用法 在select语句前加上explain就可以了 例如： 1explain select * from info where uid = 1234 order by id desc limit 1\G; 运行结果： 12345678910 id: 1 select_type: SIMPLE table: info type: refpossible_keys: uid key: uid key_len: 8 ref: const rows: 18 Extra: Using index condition; Using where; Using filesort 3.2 列含义 table: 显示这一行的数据是关于哪张表的 select_type: 表示 SELECT 的 类型，常见的取值有 SIMPLE （简单表，即不使用表连接或者子查询）、 PRIMARY （主查询，即外层的查询）、 UNION （ UNION 中的第二个或者后面的查询语句）、 SUBQUERY （子查询中的第一个 SELECT ）等 type : 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL 表示表的连接类型，性能由好到差的连接类型为 system （表中仅有一行，即常量表）、 const （单表中最多有一个匹配行，例如 primary key 或者 unique index ）、 eq_ref （对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index ）、 ref （与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index ，而是使用普通的索引）、 ref_or_null （ 与 ref 类似，区别在于条件中包含对 NULL 的查询 ） 、 index_merge ( 索引合并优化 ) 、 unique_subquery （ in 的后面是一个查询主键字段的子查询）、 index_subquery （ 与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、 range （单表中的范围查询）、 index （对于前面的每一行，都通过查询索引来得到数据）、 all （对于前面的每一行，都通过全表扫描来得到数据） possible_keys: 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 key: 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句 中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 key_len: 使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref: 显示索引的哪一列被使用了，如果可能的话，是一个常数 rows: MYSQL认为必须检查的用来返回请求数据的行数 extra: 执行情况的说明和描述 参考:MySQL常见面试题MySQL性能优化总结MySQL分区表详解常见面试题整理–数据库篇（每位开发者必备）表的垂直拆分和水平拆分如何查找MySQL中查询慢的SQL语句]]></content>
      <tags>
        <tag>面试</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL数据库知识点]]></title>
    <url>%2F2018-02-05-nosql-db.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常见算法]]></title>
    <url>%2F2018-02-05-algorithm-php.html</url>
    <content type="text"><![CDATA[文章参考：todayqq/PHPerInterviewGuide 冒泡排序 插入排序和冒泡排序在平均和最坏情况下的时间复杂度都是O(n^2)，最好情况下都是O(n)，空间复杂度是O(1) 原理:比较相邻两个元素,如果前一个元素大于后一个元素则向后移,然后跟后边元素依次比较直到最大值冒泡到最后一个元素 结论:假设数组长度为n,则共经过N=n-1轮排序,每轮进行N-i次比较,我们可以使用双层循环语句,外层循环控制轮次,内层循环控制比较次数 1234567891011121314function bubble_sort($arr) &#123; $count = count($arr); for($i=0; $i &lt; $count-1; $i++) &#123; for($j=0; $j &lt; $count-1-$i; $j++) &#123; if($arr[$j] &gt; $arr[$j+1]) &#123;//倒序排只需把大于号换成小于号即可 $temp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $temp; &#125; &#125; &#125; return $arr;&#125;print_r(bubble_sort([6, 3, 8, 2, 9, 1, 2])); 运行结果:12345678910Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 6 [5] =&gt; 8 [6] =&gt; 9) 参考: PHP 冒泡排序 快速排序 快速排序是对冒泡排序的一种改进，时间复杂度：O(nlogn) 原理: 选择一个基准数(一般为第一个元素),新建两个空数组,遍历整个数组元素,如果数组元素比基准数小,则放到left数组,如果大于基准数则放到right数组,然后在对新数组递归进行相同的操作 基准数: 第一个元素 递归点: 新构造的数组个数大于1则继续进行拆分排序 递归出口: 数组个数小于等于1或非数组 123456789101112131415161718192021222324function quick_sort($arr) &#123; if(!is_array($arr)) &#123; return false; &#125; $count = count($arr); if($count &lt;= 1) &#123; return $arr; &#125; $base = $arr[0]; $left = $right = array(); for($i=1; $i &lt; $count; $i++) &#123; if($arr[$i] &lt; $base) &#123; //倒序排只需把符号换成大于号即可 $left[] = $arr[$i]; &#125; else &#123; $right[] = $arr[$i]; &#125; &#125; $left = quick_sort($left); $right = quick_sort($right); return array_merge($left, array($base), $right);&#125;$arr = [6,3,8,6,4,4,2,9,5,1];print_r(quick_sort($arr)); 运行结果：12345678910111213Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 4 [5] =&gt; 5 [6] =&gt; 6 [7] =&gt; 6 [8] =&gt; 8 [9] =&gt; 9) 参考： php实现快速排序 二分查找（折半查找） 时间复杂度：O(logn) 需求: 提供一个有序数组和一个目标数字,找出该数字在有序数组中的位置 原理： 知道起始位置和结束位置(默认为数组起点和终点索引值), 取数组中间位置数字与目标数字比较. 如果目标值小于中间值,则目标值在中间位置之前,此时再次二分，起始位置不变,结束位置变更为中间位置-1. 如果中间值小于目标值,则目标值在中间位置之后,此时再次二分，起始位置为中间位置+1,结束位置不变. 如果中间值等于目标值则返回中间位置 12345678910111213141516171819202122232425function binary_search($target, $arr) &#123; $low = 0; $high = count($arr) -1; while($low &lt;= $high) &#123; //&lt;=兼容target = 1情况 $mid = floor(($low+$high) / 2); //var_dump($low.'_'.$high.'_'.$mid);//打印比较过程 if($target &lt; $arr[$mid]) &#123; $high = $mid -1; &#125; if($target &gt; $arr[$mid]) &#123; $low = $mid +1; &#125; if($target == $arr[$mid]) &#123; return $mid; &#125; &#125; //var_dump($low.'_'.$high.'_'.$mid);//打印比较过程 return false;&#125;$target = 7;//分别测试target=1,2,7$arr = [1, 2, 3, 6, 8, 9, 10, 13, 14];//共9个数字var_dump($target);print_r($arr);$ret = binary_search($target, $arr);var_dump($ret); 运行结果：1234567891011121314int(7)Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 6 [4] =&gt; 8 [5] =&gt; 9 [6] =&gt; 10 [7] =&gt; 13 [8] =&gt; 14)bool(false) 参考：php实现二分查找法算法就简单罗列这几种，了解更多就看看扩展阅读吧。 Twitter Snowflake核心思想snowflake是twitter开源的分布式ID生成算法，其核心思想是：产生一个long型(64bit)的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)个，也就是大约400W的ID，完全能满足业务的需求。 实现 12| 41 bits: Timestamp | 3 bits: 区域 | 10 bits: 机器编号 | 10 bits: 序列号 |return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (paddingnum &lt;&lt; regionIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; 毫秒数计算：需要选择某一天的毫秒级时间戳为基准时间戳，然后用当前时间戳与基准时间戳相减 序列号计算：同一毫秒内序列号自增，超过最大值则溢出等待下一毫秒 最后分别对Timestamp、区域、机器编号、序列号分别向左做相对应的位运算，然后进行与操作得到最终的唯一id注意 需要控制好所有服务器的时间，使用统一的ntp时间服务器，否则生成的id无法保持增长趋势 扩展阅读 PHP实现各种经典算法 PHP常见算法-面试篇 常用算法PHP版 全局唯一ID设计]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php面试题汇总二]]></title>
    <url>%2F2018-02-04-php-interview-question-2.html</url>
    <content type="text"><![CDATA[PHP面试题汇总 (二)文章内容主要参考：https://github.com/ycrao/mynotes 问题来源：http://tieba.baidu.com/p/3612369052http://blog.csdn.net/hyr352114576/article/details/49638345https://my.oschina.net/u/574366/blog/64814 for与foreach哪个更快?参考答案：http://www.cnblogs.com/niniwzw/archive/2008/06/03/1212535.html foreach 的效率要比 for 高很多，也许有很大的一个原因是 for 要进行很多次条件判断。所以以后能用 foreach 的地方就用 foreach ，可以提高1倍的效率。 如果循环内要调用函数，用 array_walk 最好，它的效率要比 for 高出1倍，要比 foreach 高出43%的效率。 PECL 和 PEAR 有什么区别？参考答案：http://jingyan.baidu.com/article/e9fb46e1a3eb277521f76619.html PECL (PHP Extension Community Library) 可以看作 PEAR (PHP Extension and Application Repository) 的一个组成部分，提供了与 PEAR 类似的功能。不同的是 PEAR 的所有扩展都是用纯粹的 PHP 代码编写的，用户在下载到 PEAR 扩展以后可以直接使用将扩展的代码包含到自己的 PHP 文件中使用。而 PECL 是使用 C 语言开发的，通常用于补充一些用 PHP 难以完成的底层功能，往往需要重新编译或者在配置文件中设置后才能在用户自己的代码中使用。 最直接的表述：PEAR 是 PHP 的上层扩展，PECL 是 PHP 的底层扩展。它们都是为特定的应用提供现成的函数或者类。 如何处理多服务器共享 Session ?参考答案：http://www.toutiao.com/a6294758409293086977/ 思路：引入统一session接入点 大致上有三种方式可以处理： 数据库/文件同步 session cookie 同步 session 缓存 (如 memcache ）同步 session 延伸：单独提供session服务，所有机器从这个服务获取session数据 推荐使用cache和数据库结合的实现方式，保证高效和稳定 什么是跨站脚本？SQL注入？1. 跨站脚本攻击的原理和防范 原理 XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意脚本代码，而程序对于用户输入内容未过滤，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而达到恶意攻击用户的特殊目的。 跨站脚本攻击的危害：窃取cookie、放蠕虫、网站钓鱼 … 跨站脚本攻击的分类主要有：存储型XSS、反射型XSS、DOM型XSS 防范：过滤非法字符(html,js,css)（strip_tags、htmlspecialchars） 2. SQL注入 原理SQL 注入是发生于应用程序数据库层的安全漏洞。用户输入的参数拼凑SQL查询语句，使用户可以控制SQL查询语句 防范：不要使用拼接的sql，使用占位符 使用预编译语句 检查数据类型 参考：http://blog.csdn.net/jbb0403/article/details/36626515http://www.cnblogs.com/ITtangtang/p/3982297.html 描述一下大流量高并发量网站的解决方案 确认服务器硬件是否足够支持当前的流量。 使用 memcache或redis 缓存技术，将动态数据缓存到文件中，动态网页直接调用这些文件，而不必在访问数据库。 禁止外部的盗链。外部网站的图片或者文件盗链往往会带来大量的负载压力，因此应该严格限制外部对自身图片或者文件盗链，可以通过apache的URL重定向来防止盗链。 控制大文件的下载。大文件的下载会占用很大的流量，对于非SCSI硬盘来说会消耗，使得网站响应能力下降。 使用不同的主机分流主要流量。 使用流量统计软件。在网站上安装一个流量统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化。 如何防盗链参考引用: https://yq.aliyun.com/articles/57931 设置Referer（原理：判断来源地址是否与白名单地址匹配） 签名URL(原理：签名URL，增加url的有效时间) PHP内存管理机制与垃圾回收机制参考答案：http://www.cnblogs.com/zk0533/p/5667122.html php 的内存管理机制是：预先给出一块空间，用来存储变量，当空间不够时，再申请一块新的空间。 存储变量名，存在符号表。 变量值存储在内存空间。 在删除变量的时候，会将变量值存储的空间释放，而变量名所在的符号表不会减小。 php 垃圾回收机制是： 在5.2版本或之前版本，PHP会根据 引用计数 （ refcount ）值来判断是不是垃圾，如果refcount值为0，PHP会当做垃圾释放掉，这种回收机制有缺陷，对于环状引用的变量无法回收。 在5.3之后版本改进了垃圾回收机制。具体如下： 如果发现一个 zval 容器中的 refcount 在增加，说明不是垃圾；如果发现一个 zval 容器中的 refcount 在减少，如果减到了0，直接当做垃圾回收；如果发现一个 zval 容器中的 refcount 在减少，并没有减到0，PHP 会把该值放到缓冲区，当做有可能是垃圾的怀疑对象；当缓冲区达到了临界值，PHP 会自动调用一个方法去遍历每一个值，如果发现是垃圾就清理。 为什么要对数据库进行主从分离?参考答案：https://my.oschina.net/candiesyangyang/blog/203425 读写服务器可单独优化，提高可用性 降低写服务器压力 主从只负责各自的写和读，极大程度的缓解X锁和S锁争用，提高并发性 延伸：什么是X锁和S锁？ 共享锁(S锁Share Locks)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排它锁：排它锁又称为写锁（(eXclusive lock,简记为X锁)），若事物T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。 多线程和多进程的区别为？参考答案： http://www.cnblogs.com/kaituorensheng/p/3603057.html https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319292979766bd3285c9d6b4942a8ea9b4e9cfb48d8000 进程是资源分配的最小单位，线程是CPU调度的最小单位 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 相同点：进程线程间切换都会消耗系统资源 ps： 进程可靠性高原因：比如fork多个子进程，单独某个进程出现问题，不影响其他进程，而多个子线程如果某个子线程挂了可能导致整个进程挂掉 TCP/IP 网络协议，OSI 7 层指是什么？参考答案：http://blog.csdn.net/jenminzhang/article/details/47017741 TCP/IP 5层 指的是： 12345678910应用层HTTP、FTP、SMTP、DNS、DSP、Telnet、Gopher、WAIS……传输层TCP、UDP、DVP……网络层IP、ICMP、AKP、RARP、UUCP……接口层Ethernet、Arpanet、PDN……物理层只要能传输IP数据报（Datagram），允许任何协议…… OSI 7层指的是： 1234567应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet表示层 数据格式化，代码转换，数据加密 没有协议会话层 解除或建立与别的接点的联系 没有协议传输层 提供端对端的接口 TCP，UDP网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 TCP/IP知识点参考：https://gaoshangs.github.io/2018-01-31-tcp_ip_point.html 三次握手第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。 常见问题1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误，造成资源浪费。 2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？建立连接时候ACK和SYN可以放到一个报文发送，而关闭连接时被动方可能未全部完成数据的发送，所以ACK和SYN回分两次发送。 3. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 CGI/FastCGI/php-fpm和nginx通信原理cgi、fast-cgi协议 cgi的历史 早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像PHP等动态语言。webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？ 为了解决不同的语言解释器(如php、Python解释器)与webserver的通信，于是出现了cgi协议。只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。 fast-cgi的改进 有了cgi协议，解决了php解释器与webserver通信的问题，webserver终于可以处理动态语言了。但是，webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程。这样有10000个请求，就需要fork、kill php-cgi进程10000次。 有没有发现很浪费资源？ 于是，出现了cgi的改良版本，fast-cgi。fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。 php-fpm是什么 php-fpm即php-Fastcgi Process Manager.php-fpm是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种进程。master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。 nginx和php-fpm运行原理和流程Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpmwww.example.com| | Nginx| | 路由到www.example.com/index.php| | 加载nginx的fast-cgi模块| | fast-cgi监听127.0.0.1:9000地址| | www.example.com/index.php请求到达127.0.0.1:9000| | php-fpm 监听127.0.0.1:9000| | php-fpm 接收到请求，启用worker进程处理请求| | php-fpm 处理完请求，返回给nginx| | nginx将结果通过http返回给浏览器 参考Nginx+PHP-fpm运行原理详解]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试题汇总一]]></title>
    <url>%2F2018-02-04-php-Interview-question-1.html</url>
    <content type="text"><![CDATA[PHP面试题汇总(基础)文章内容主要参考：https://github.com/ycrao/mynotes 1. echo(),print(),print_r()的区别？三者均可以输出信息，但是各有自己的特点： 类型 输出变量个数 输出变量类型 返回值 速度 echo 语言结构 一个或多个 简单类型变量，如int、string 无 最快 print 语言结构 一个 简单类型变量，如int、string int 快 print_r 函数 一个 复杂类型，如数组、对象 bool 慢 2. 语句include和require的区别是什么?在失败的时候： include 产生一个 warning ，而 require 直接产生错误中断； require 在运行前载入； include 在运行时载入； require_once 和 include_once 可以避免重复包含同一文件。 3. php中传值与传引用有啥区别?&amp;表示传引用；函数中参数传引用会将参数进行改变；一般在输出参数有多个的时候可以考虑使用引用。 123456$num = 10function multiply(&amp;$num)&#123; $num = $num * 10;&#125;multiply($num);echo $num; 4. 下面哪项没有将john添加到users数组中？1234(a) $users[] = &apos;john&apos;;(b) array_add($users,&apos;john&apos;);(c) array_push($users,&apos;john&apos;);(d) $users ||= &apos;john&apos;; 答案为bd，php 里面无 array_add 函数，d项为语法错误的表达。 5. HTTP协议中几个状态码的含义。123456789101112200 OK 客户端请求成功301 Moved Permanently 请求永久重定向302 Moved Temporarily 请求临时重定向304 Not Modified 文件未修改，可以直接使用缓存的文件。400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden 服务器拒绝执行请求，即没有权限404 Not Found 请求的资源不存在，例如，输入了错误的URL500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。502 Bad Gateway 错误的网关，上游服务器错误(如php-fpm挂掉了)503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。504 Gateway Timeout 网关超时（上游服务器超时） 参考：HTTP状态码详解502 VS 504 6. 写出一些php魔术方法。1234567891011121314__construct() 实例化类时自动调用。__destruct() 类对象使用结束时自动调用。__set() 在给未定义的属性赋值的时候调用。__get() 调用未定义的属性时候调用。__isset() 使用isset()或empty()函数时候会调用。__unset() 使用unset()时候会调用。__sleep() 使用serialize序列化时候调用。__wakeup() 使用unserialize反序列化的时候调用。__call() 调用一个不存在的方法的时候调用。__callStatic()调用一个不存在的静态方法是调用。__toString() 把对象转换成字符串的时候会调用。比如 echo。__invoke() 当尝试把对象当方法调用时调用。__set_state() 当使用var_export()函数时候调用。接受一个数组参数。__clone() 当使用clone复制一个对象时候调用。 7. MySQL存储引擎 MyISAM 和 InnoDB 的区别 MyISAM InnoDB 构成上的区别 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。 数据文件的扩展名为.MYD (MYData)。 索引文件的扩展名是.MYI (MYIndex)。 基于磁盘的资源是InnoDB表空间数据文件(.frm和它的日志文件(.ibd)，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB 事务处理上方面 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持 InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能 SELECT UPDATE,INSERT，Delete操作 如果执行大量的SELECT，MyISAM是更好的选择 1.如果你的数据执行大量的INSERT**或**UPDATE，出于性能方面的考虑，应该使用InnoDB表 2.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 3.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用 AUTO_INCREMENT类型的字段 在MyISAM表中，可以和其他字段一起建立联合索引 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引 表的具体行数 select count() from table,MyISAM只要简单的读出保存好的行数，注意的是，当count()语句包含 where条件时，两种表的操作是一样的 InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行 锁 表锁 提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%” 8. 说出一些MySQL优化方法？1234567a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e. 添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 9. 下面$r的结果是：123456&lt;?php$a = in_array('01', array('1')); // true$a1 = in_array('01', array('1'), true); // false $b = '01' == 1; // true$b1 = '02' == 1; // false$r = $a == $b A trueB false 答案为A 10. 说下php中empty()和isset()的区别。 Expression gettype() empty() is_null() isset() boolean : if($x) $x = “”; string TRUE FALSE TRUE FALSE $x = null; NULL TRUE TRUE FALSE FALSE var $x; NULL TRUE TRUE FALSE FALSE $x is undefined NULL TRUE TRUE FALSE FALSE $x = array(); array TRUE FALSE TRUE FALSE $x = array(‘a’, ‘b’); array FALSE FALSE TRUE TRUE $x = false; boolean TRUE FALSE TRUE FALSE $x = true; boolean FALSE FALSE TRUE TRUE $x = 1; integer FALSE FALSE TRUE TRUE $x = 42; integer FALSE FALSE TRUE TRUE $x = 0; integer TRUE FALSE TRUE FALSE $x = -1; integer FALSE FALSE TRUE TRUE $x = “1”; string FALSE FALSE TRUE TRUE $x = “0”; string TRUE FALSE TRUE FALSE $x = “-1”; string FALSE FALSE TRUE TRUE $x = “php”; string FALSE FALSE TRUE TRUE $x = “true”; string FALSE FALSE TRUE TRUE $x = “false”; string FALSE FALSE TRUE TRUE 引用：PHP 类型比较表 isset 用于检测变量是否被设置，使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE 。empty 如果 var 是非空或非零的值，则 empty() 返回 FALSE。换句话说，&quot;&quot;、0、&quot;0&quot;、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE 。 如果变量为 0 ，则empty()会返回TRUE，isset()会返回TRUE；如果变量为空字符串，则empty()会返回TRUE，isset()会返回TRUE；如果变量未定义，则empty()会返回TRUE，isset()会返回FLASE。 注意：isset() 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已设置，可使用 defined() 函数。当要 判断一个变量是否已经声明的时候 可以使用 isset 函数；当要 判断一个变量是否已经赋予数据且不为空 可以用 empty函数；当要 判断 一个变量 存在且不为空 先 isset 函数 再用 empty 函数； 11. cookie和session的区别、cookie禁用后session还可以用吗？工作流程： 以下以PHP为例： 你第一次访问网站时， 服务端脚本中开启了Sessionsession_start();， 服务器会生成一个不重复的 SESSIONID 的文件session_id();，比如在/var/lib/php/session目录 并将返回(Response)如下的HTTP头 Set-Cookie:PHPSESSIONID=xxxxxxx 客户端接收到Set-Cookie的头，将PHPSESSIONID写入cookie 当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端 服务器识别PHPSESSIONID这个cookie，然后去session目录查找对应session文件， 找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置 区别： 1、cookie就是服务器发放给客户端的一些标识，保存在客户端，让客户端每次请求的时候带上，以区分不同的用户； 2、session是服务器存放在自己那里的用户相关的数据，用每次用户带来的cookie去提取出来，恢复一个之前访问的历史或者相关环境。 3、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie 参考： https://segmentfault.com/q/1010000007715137 http://blog.csdn.net/baidu_31337243/article/details/48954445]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP知识点]]></title>
    <url>%2F2018-01-31-tcp_ip_point.html</url>
    <content type="text"><![CDATA[三次握手第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。 常见状态码 CLOSED: 这个没什么好说的了，表示初始状态。 LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 ESTABLISHED：这个容易理解了，表示连接已经建立了。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 常见问题1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 2. 为什么建立连接协议是三次握手，而关闭连接却是四次挥手呢？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以关闭连接时的ACK报文和FIN报文多数情况下都是分开发送的。 3. 什么是2MSL？2MSL(maximum segment lifetime) 等待一段时间，防止最后的FIN的ACK包丢失，对方未收到ACK会重发FIN TCP连接在2MSL时间内 ip,port不能重新被bind 4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）。但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 参考面试笔试–TCP/IP知识点HTTP/TCP常见面试问题总结]]></content>
      <categories>
        <category>技术支撑</category>
        <category>网络工程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言指针]]></title>
    <url>%2F2018-01-16-c-pointer-define.html</url>
    <content type="text"><![CDATA[1. 指针的定义方式：示例一：123int a = 5;int *p;p = &amp;a; 说明：p为指针变量，int p 中的为类型说明符，声明p的类型为指针变量类型。指针变量必须是指向内存地址（内存指针），&amp;符为取地址运算符。示例二： 12int a = 5;int *p = &amp;a; 说明：先声明一个指针变量，然后对这个指针变量进行赋值。 2. 指针变量的使用123int a = 5;int *p = &amp;a;printf("*p = %d", *p); 说明：这里的printf(“ p = %d“, p);中的与上边声明指针变量的int p的含义是不同的，这里的*为指针运算符，不是类型说明符。 printf("*&amp;a = %d", *&amp;a); //运行结果为a本身 由于*和&amp;的优先级相同，所以会先进行&amp;a进行取a的内存地址，然后在通过*指针运算符，指向a的内存地址并返回这块内存单元存放的数据。 总结 int *p 声明指针变量的* 为类型说明符，他的性质和int long的作用相似，都是说明变量的类型。 *p 获取指针变量的为指针运算符，和&amp;的类型都是一样的就是参与运算的，只是&amp;获取的是内存的地址，获取的是内存地址为该指针变量上存储的数据]]></content>
      <categories>
        <category>编程语言</category>
        <category>C</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点总结(持续更新~~)]]></title>
    <url>%2F2018-01-15-knowledge-point.html</url>
    <content type="text"><![CDATA[面试知识点分类 算法 数据结构 设计模式 Linux网络编程 语言基础 软件应用和优化 编程思想 什么是OO语言 Gearman Gearman分布式任务处理系统（一）简介和工作原理 Gearman系列文章 PHP 2017最新PHP面试题 PHPer面试指南 面试题汇总1 面试题汇总2 PHP面试总结全 3-5年的PHPer常见的面试题 Nginx+PHP-fpm运行原理详解 PHP框架 yaf官方文档 laravel 学习笔记 —— 神奇的服务容器 laravel教程 swoole官方文档 swoole官方首页 golang 京东三级列表页持续架构优化 — Golang + Lua (OpenResty) 最佳实践 Go Web 框架性能比拼 2017 春季版 GIN框架 go 语言框架 gin 的中文文档 Golang精编100题 2017年超有价值的Golang文章 go入门知识汇总 Go语言经典笔试题 lua和openresty和nginx openresty官方文档 Nginx面试中最常见的18道题 抱佛脚必备 nginx面试要点–持续更新中 浅谈nginx + lua在安全中的一些应用 shell 分析nginx日志 教你玩转 Nginx 日志 nginx日志切割shell脚本 redis redis-热点 面试常见问题 redis面试总结 memcached面试题集锦 也谈谈 Redis 和 Memcached 的区别 你应该知道的Memcached与Redis的区别与如何抉择 redis面试总结 NoSQL数据库：Redis内存使用优化与存储 单进程单线程的Redis如何能够高并发 Redis 五种数据类型的常见用法以及应用场景 Redis 分区实现原理 redis的类型、原理及使用场景 API和传输格式 比起JSON 更方便、更快速、更简短的Protobuf 格式 RESTful API 设计指南 Google Protocol Buffer 的使用和原理 算法 冒泡和快速排序思想和实现 极客学院基础算法一 算法基础(极客学院) 时间复杂度和空间复杂度详解 高并发环境下生成订单唯一流水号方法:SnowFlake 全局唯一ID设计 大数据算法：对5亿数据进行排序 经典排序算法 - 归并排序Merge sort 一致性哈希算法在分布式缓存中的应用 分布式存储和一致性hash 数据结构 数据结构之字符串、散列和布隆过滤器 数据结构(极客学院) 数据结构之数组、链表、字符串、散列、布隆过滤器 名企数据结构面试题(极客学院) 设计模式 PHP 经典设计模式(完整版) 五种常见的 PHP 设计模式 PHP 设计模式 设计模式（一）——设计模式概述 设计模式(极客学院) MapReduce 如何简单解释 MapReduce 算法 ElasticStack系列 分页查询From&amp;Size VS scroll 使用scroll实现Elasticsearch数据遍历和深度分页 面试小结之Elasticsearch篇 ElasticStack HTTP/TCP/IP TAT.tennylvHTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 HTTP/2资料总结 HTTP/TCP常见面试问题总结 hit-alibaba 从输入URL到页面加载发生了什么？ 面试笔试–TCP/IP知识点 计算机网络常见面试题总结 http协议详解及htt面试题目，常见的http状态码 mysql 常见面试题整理–数据库篇（每位开发者必备） 阿里巴巴MySQL DBA面试题答案(欢迎进来讨论) MySQL索引原理及实现 MySQL常见面试题 MySQL存储引擎InnoDB与Myisam的六大区别 如何保证主从复制数据一致性 MySQL性能优化总结 每秒处理10万订单乐视集团支付架构 MySQL innoDB索引底层原理详解 如何查找MySQL中查询慢的SQL语句 MYSQL性能调优: 对聚簇索引和非聚簇索引的认识 python Python完整 常见面试题整理–Python代码篇 常见面试题整理–Python概念篇 Python面试必须要看的15个问题 Python 的闭包和装饰器 javaweb spring面试题总结 JAVA面试题 java web部分 linux系统和网络编程 Linux网络编程(极客学院) 计算机网络篇 操作系统篇 操作系统常见面试题总结 176条DevOps人员常用的linux命令速查表 Linux IO模式及 select、poll、epoll详解 常见多线程并发服务器编程模型 IO复用、多进程和多线程三种并发编程模型 进程间通信的方式——信号、管道、消息队列、共享内存 linux性能分析常用命令详解 Linux Web服务器网站故障分析常用的命令 LINUX常用的日志分析命令 网站排障分析常用的命令 Socket 基本概念 socket编程(python) Linux Socket编程（不限Linux） 揭开Socket编程的面纱 Socket基础原理 运维 搜狐Linux运维工程师面试 运维必须掌握的27道Linux面试题 运维面试题和答案 2017年企业运维岗经典面试题 Linux系统运维常见面试简答题系列（二） 2017年企业运维岗经典面试题（28题） Linux 查看负载 安全 前端需要知道的web安全知识 缓存 Web缓存详解 你有自己的Web缓存知识体系吗 缓存更新的套路 http缓存与cdn相关技术 架构 SOA和微服务架构的区别 SOA描述了一种架构模型，微服务是具体的实现?]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识体系分类]]></title>
    <url>%2F2018-01-14-knowledge-system-catgory.html</url>
    <content type="text"><![CDATA[个人知识体系(持续完善~~) 包含未触及但想学习的领域 编程语言 Java Python GoLang PHP C++ C 指针 Node.js JavaScript HTML5 CSS3 技术支撑 操作系统 Linux MacOS Windows iOS 网络工程 OSI TCP/IP HTTP/HTTPS HTTP 1.X / HTTP 2 软件工程 算法 数据结构 设计模式 代码规范 数学 后端开发 Linux网络编程 Web前端 前端框架 jQuery Vue.js 数据格式 JSON XML JSONP Protobuf 测试 单元测试 JUnit 集成测试 自动化测试 研发工具 思维导图&amp;建模 UML 版本控制系统 Git Svn 调试工具 Charles、Wireshark Postman IDE Jetbrains IntelliJ IDEA PhpStorm Sublime Text Android Studio 构建工具 Gradle Maven 效率工具 番茄钟 Markdown 滴答清单 运维管理 监控 告警 日志 架构师 性能优化 应用技术 消息队列(MQ) 缓存 软技能 面试 知识管理 开源项目 技术博客 技术分享 时间管理 番茄工作法 目标管理 甘特图 思维导图 项目管理 团队管理 安全 移动开发 云计算 OpenStack 容器(Container) 微服务(MicroService) 大数据 MySQL NoSQL Redis MongoDB Memcached Zookeeper Kafka ElasticStack Hadoop Spark 人工智能(AI) 机器学习 财经 参考 程序员技能图谱]]></content>
      <tags>
        <tag>知识系统</tag>
        <tag>技能图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀博客]]></title>
    <url>%2F2018-01-09-excellent-blog.html</url>
    <content type="text"><![CDATA[java Hollis 机器学习 码农场 前端 IIssNan hexo+next Doublemine]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
