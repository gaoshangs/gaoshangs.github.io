<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP/IP知识点]]></title>
    <url>%2F2018-01-31-tcp_ip_point.html</url>
    <content type="text"><![CDATA[三次握手第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，这时候主动关闭方会进入TIME_WAIT状态，等2MSL后即可回到CLOSED可用状态了。至此，完成四次挥手。 常见状态码 CLOSED: 这个没什么好说的了，表示初始状态。 LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 ESTABLISHED：这个容易理解了，表示连接已经建立了。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 常见问题1. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 2. 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以关闭连接时的ACK报文和FIN报文多数情况下都是分开发送的。 3. 什么是2MSL？2MSL(maximum segment lifetime) 等待一段时间，防止最后的FIN的ACK包丢失，对方未收到ACK会重发FIN TCP连接在2MSL时间内 ip,port不能重新被bind 4. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）。但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 参考面试笔试–TCP/IP知识点HTTP/TCP常见面试问题总结]]></content>
      <categories>
        <category>技术支撑</category>
        <category>网络工程</category>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言指针]]></title>
    <url>%2F2018-01-16-c-pointer-define.html</url>
    <content type="text"><![CDATA[1. 指针的定义方式：示例一：123int a = 5;int *p;p = &amp;a; 说明：p为指针变量，int p 中的为类型说明符，声明p的类型为指针变量类型。指针变量必须是指向内存地址（内存指针），&amp;符为取地址运算符。示例二： 12int a = 5;int *p = &amp;a; 说明：先声明一个指针变量，然后对这个指针变量进行赋值。 2. 指针变量的使用123int a = 5;int *p = &amp;a;printf("*p = %d", *p); 说明：这里的printf(“ p = %d“, p);中的与上边声明指针变量的int p的含义是不同的，这里的*为指针运算符，不是类型说明符。 printf("*&amp;a = %d", *&amp;a); //运行结果为a本身 由于*和&amp;的优先级相同，所以会先进行&amp;a进行取a的内存地址，然后在通过*指针运算符，指向a的内存地址并返回这块内存单元存放的数据。 总结 int *p 声明指针变量的* 为类型说明符，他的性质和int long的作用相似，都是说明变量的类型。 *p 获取指针变量的为指针运算符，和&amp;的类型都是一样的就是参与运算的，只是&amp;获取的是内存的地址，获取的是内存地址为该指针变量上存储的数据]]></content>
      <categories>
        <category>编程语言</category>
        <category>C</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试知识点总结(持续更新~~)]]></title>
    <url>%2F2018-01-15-knowledge-point.html</url>
    <content type="text"><![CDATA[面试知识点分类 算法 数据结构 设计模式 Linux网络编程 语言基础 软件应用和优化 编程思想 什么是OO语言 Gearman Gearman分布式任务处理系统（一）简介和工作原理 Gearman系列文章 PHP PHP面试总结全 面试题汇总1 面试题汇总2 PHP框架 yaf官方文档 laravel 学习笔记 —— 神奇的服务容器 laravel教程 swoole官方文档 swoole官方首页 golang 京东三级列表页持续架构优化 — Golang + Lua (OpenResty) 最佳实践 Go Web 框架性能比拼 2017 春季版 GIN框架 go 语言框架 gin 的中文文档 Golang精编100题 2017年超有价值的Golang文章 go入门知识汇总 lua和openresty和nginx openresty官方文档 Nginx面试中最常见的18道题 抱佛脚必备 nginx面试要点–持续更新中 浅谈nginx + lua在安全中的一些应用 shell 分析nginx日志 教你玩转 Nginx 日志 nginx日志切割shell脚本 redis redis-热点 面试常见问题 redis面试总结 memcached面试题集锦 也谈谈 Redis 和 Memcached 的区别 你应该知道的Memcached与Redis的区别与如何抉择 redis面试总结 API和传输格式 比起JSON 更方便、更快速、更简短的Protobuf 格式 RESTful API 设计指南 Google Protocol Buffer 的使用和原理 算法 冒泡和快速排序思想和实现 极客学院基础算法一 算法基础(极客学院) 时间复杂度和空间复杂度详解 数据结构 数据结构之字符串、散列和布隆过滤器 数据结构(极客学院) 数据结构之数组、链表、字符串、散列、布隆过滤器 名企数据结构面试题(极客学院) 设计模式 五种常见的 PHP 设计模式 PHP 设计模式 设计模式（一）——设计模式概述 设计模式(极客学院) MapReduce 如何简单解释 MapReduce 算法 ElasticStack系列 分页查询From&amp;Size VS scroll 使用scroll实现Elasticsearch数据遍历和深度分页 面试小结之Elasticsearch篇 ElasticStack HTTP/TCP/IP TAT.tennylvHTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 HTTP/2资料总结 HTTP/TCP常见面试问题总结 hit-alibaba 从输入URL到页面加载发生了什么？ 面试笔试–TCP/IP知识点 计算机网络常见面试题总结 http协议详解及htt面试题目，常见的http状态码 mysql 常见面试题整理–数据库篇（每位开发者必备） 阿里巴巴MySQL DBA面试题答案(欢迎进来讨论) MySQL索引原理及实现 MySQL常见面试题 python Python完整 常见面试题整理–Python代码篇 常见面试题整理–Python概念篇 Python面试必须要看的15个问题 javaweb spring面试题总结 JAVA面试题 java web部分 linux系统和网络编程 Linux网络编程(极客学院) 计算机网络篇 操作系统篇 操作系统常见面试题总结 176条DevOps人员常用的linux命令速查表 Linux IO模式及 select、poll、epoll详解 常见多线程并发服务器编程模型 IO复用、多进程和多线程三种并发编程模型 进程间通信的方式——信号、管道、消息队列、共享内存 linux性能分析常用命令详解 Linux Web服务器网站故障分析常用的命令 LINUX常用的日志分析命令 网站排障分析常用的命令 Socket 基本概念 socket编程(python) Linux Socket编程（不限Linux） 揭开Socket编程的面纱 Socket基础原理 运维 搜狐Linux运维工程师面试 运维必须掌握的27道Linux面试题 运维面试题和答案 2017年企业运维岗经典面试题 Linux系统运维常见面试简答题系列（二） 2017年企业运维岗经典面试题（28题） 安全 前端需要知道的web安全知识 缓存 Web缓存详解 你有自己的Web缓存知识体系吗 缓存更新的套路 架构 SOA和微服务架构的区别 SOA描述了一种架构模型，微服务是具体的实现?]]></content>
      <categories>
        <category>软技能</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识体系分类]]></title>
    <url>%2F2018-01-14-knowledge-system-catgory.html</url>
    <content type="text"><![CDATA[个人知识体系(持续完善~~) 包含未触及但想学习的领域 编程语言 Java Python GoLang PHP C++ C 指针 Node.js JavaScript HTML5 CSS3 技术支撑 操作系统 Linux MacOS Windows iOS 网络工程 OSI TCP/IP HTTP/HTTPS HTTP 1.X / HTTP 2 软件工程 算法 数据结构 设计模式 代码规范 数学 后端开发 Linux网络编程 Web前端 前端框架 jQuery Vue.js 数据格式 JSON XML JSONP Protobuf 测试 单元测试 JUnit 集成测试 自动化测试 研发工具 思维导图&amp;建模 UML 版本控制系统 Git Svn 调试工具 Charles、Wireshark Postman IDE Jetbrains IntelliJ IDEA PhpStorm Sublime Text Android Studio 构建工具 Gradle Maven 效率工具 番茄钟 Markdown 滴答清单 运维管理 监控 告警 日志 架构师 性能优化 应用技术 消息队列(MQ) 缓存 软技能 面试 知识管理 开源项目 技术博客 技术分享 时间管理 番茄工作法 目标管理 甘特图 思维导图 项目管理 团队管理 安全 移动开发 云计算 OpenStack 容器(Container) 微服务(MicroService) 大数据 MySQL NoSQL Redis MongoDB Memcached Zookeeper Kafka ElasticStack Hadoop Spark 人工智能(AI) 机器学习 财经 参考 程序员技能图谱]]></content>
      <tags>
        <tag>知识系统</tag>
        <tag>技能图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀博客]]></title>
    <url>%2F2018-01-09-excellent-blog.html</url>
    <content type="text"><![CDATA[java Hollis 机器学习 码农场 前端 IIssNan hexo+next Doublemine]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
